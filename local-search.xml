<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo主题</title>
    <link href="/2022/05/06/2022-05-06-hexo/"/>
    <url>/2022/05/06/2022-05-06-hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="本文主要是写一下如何增加hexo主题"><a href="#本文主要是写一下如何增加hexo主题" class="headerlink" title="本文主要是写一下如何增加hexo主题"></a>本文主要是写一下如何增加hexo主题</h1><h2 id="1-申请github账号"><a href="#1-申请github账号" class="headerlink" title="1.申请github账号"></a>1.申请github账号</h2><p><a href="https://github.com/liutongbin2017">github账号</a></p><h2 id="2-在github上创建项目，项目名称可以以github-io结尾也可以随意结尾"><a href="#2-在github上创建项目，项目名称可以以github-io结尾也可以随意结尾" class="headerlink" title="2.在github上创建项目，项目名称可以以github.io结尾也可以随意结尾"></a>2.在github上创建项目，项目名称可以以github.io结尾也可以随意结尾</h2><h2 id="3-项目创建完成之后，找个文件开始安装hexo主题"><a href="#3-项目创建完成之后，找个文件开始安装hexo主题" class="headerlink" title="3. 项目创建完成之后，找个文件开始安装hexo主题"></a>3. 项目创建完成之后，找个文件开始安装hexo主题</h2><h2 id="4-如下"><a href="#4-如下" class="headerlink" title="4. 如下"></a>4. 如下</h2><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">npm install -g hexo-cli<br>mkdir blog<br>hexo init blog（在blog文件中初始化）<br></code></pre></td></tr></table></figure><h2 id="5-输入指令预览"><a href="#5-输入指令预览" class="headerlink" title="5.输入指令预览"></a>5.输入指令预览</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">hexo <span class="hljs-keyword">new</span> test_my_site<br>hexo g<br>hexo s<br><span class="hljs-comment">// localhost:4000</span><br></code></pre></td></tr></table></figure><h2 id="6-根目录找到-config-yml文件"><a href="#6-根目录找到-config-yml文件" class="headerlink" title="6. 根目录找到_config.yml文件"></a>6. 根目录找到_config.yml文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// 配置deploy</span><br><span class="hljs-attr">deploy</span>:<br>     <span class="hljs-attr">type</span>: git<br>     <span class="hljs-attr">repo</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/git账号/项目名称.git</span><br>     <span class="hljs-attr">branch</span>: 分支<br></code></pre></td></tr></table></figure><h2 id="7-安装插件"><a href="#7-安装插件" class="headerlink" title="7. 安装插件"></a>7. 安装插件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install hexo-deployer-git --save<br><span class="hljs-comment">// 输入指令实现github部署</span><br>hexo clean &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><h2 id="8-访问git的域名即可"><a href="#8-访问git的域名即可" class="headerlink" title="8. 访问git的域名即可"></a>8. 访问git的域名即可</h2><h3 id="链接位置：项目-⇒settings⇒pages"><a href="#链接位置：项目-⇒settings⇒pages" class="headerlink" title="链接位置：项目 ⇒settings⇒pages"></a>链接位置：项目 ⇒settings⇒pages</h3>]]></content>
    
    
    <categories>
      
      <category>调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS Object</title>
    <link href="/2021/01/06/2021-01-06-object/"/>
    <url>/2021/01/06/2021-01-06-object/</url>
    
    <content type="html"><![CDATA[<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>该方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br><span class="hljs-comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(returnedTarget);<br><span class="hljs-comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><br><br><span class="hljs-string">`Object.assign()第一级是深拷贝，第二级及其他就变成浅拷贝，因为assign()拷贝的是（可枚举）属性值`</span><br><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span> , <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1);<br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2));<br><span class="hljs-comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br><span class="hljs-comment">// &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2));<br><span class="hljs-comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><br>obj2.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br><span class="hljs-comment">// &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2));<br><span class="hljs-comment">// &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><br>obj2.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;<br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br><span class="hljs-comment">// &#123; a: 1, b: &#123; c: 3&#125;&#125;</span><br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2));<br><span class="hljs-comment">// &#123; a: 2, b: &#123; c: 3&#125;&#125;</span><br><br><span class="hljs-comment">// Deep Clone</span><br>obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span> , <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-keyword">let</span> obj3 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">a</span> = <span class="hljs-number">4</span>;<br>obj1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">4</span>;<br><span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj3));<br><span class="hljs-comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>该方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for…in循环遍历该对象时返回的顺序一致（区别在于for-in循环还会枚举原型链中的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> object1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;someString&#x27;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> object1) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// &quot;a: someString&quot;</span><br><span class="hljs-comment">// &quot;b: 42&quot;</span><br><br><span class="hljs-string">`Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同`</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)); <span class="hljs-comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span><br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;c&#x27;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)); <span class="hljs-comment">// [ [&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;] ]</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> <span class="hljs-subst">$&#123;value&#125;</span>`</span>); <span class="hljs-comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p>该方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-number">42</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj);<br><br>obj.<span class="hljs-property">prop</span> = <span class="hljs-number">33</span>;<br><span class="hljs-comment">// Throws an error in strict mode</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">prop</span>);<br><span class="hljs-comment">// expected output: 42</span><br></code></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p>把键值对列表转换成一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Map转化为Object</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([ [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>], [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">42</span>] ]);<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><span class="hljs-comment">// Array转化为Object</span><br><span class="hljs-keyword">const</span> arr = [ [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] ];<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>判断两个值是否为同一个值<br><code>Object.is(value1,value2) //返回值：一个 Boolean 类型标示两个参数是否是同一个值。</code><br><code>// value1:被比较的第一个参数</code><br><code>// value2:被比较的第二个参数</code></p><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p>判断一个对象是否是可扩展（是否可以哎它上面添加新的属性）<br><code>Object.isExtensible(obj)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 新对象默认是可扩展的.</span><br><span class="hljs-keyword">var</span> empty = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(empty); <span class="hljs-comment">// === true</span><br><br><span class="hljs-comment">// ...可以变的不可扩展.</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(empty);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(empty); <span class="hljs-comment">// === false</span><br><br><span class="hljs-comment">// 密封对象是不可扩展的.</span><br><span class="hljs-keyword">var</span> sealed = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(&#123;&#125;);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(sealed); <span class="hljs-comment">// === false</span><br><br><span class="hljs-comment">// 冻结对象也是不可扩展.</span><br><span class="hljs-keyword">var</span> frozen = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;&#125;);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(frozen); <span class="hljs-comment">// === false</span><br></code></pre></td></tr></table></figure><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p>判断一个对象是否被冻结<br><code>Object.isFrozen(obj)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个对象默认是可扩展的,所以它也是非冻结的.</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(&#123;&#125;); <span class="hljs-comment">// === false</span><br><br><span class="hljs-comment">// 一个不可扩展的空对象同时也是一个冻结对象.</span><br><span class="hljs-keyword">var</span> vacuouslyFrozen = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(&#123;&#125;);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(vacuouslyFrozen) <span class="hljs-comment">//=== true;</span><br><br><span class="hljs-comment">// 一个非空对象默认也是非冻结的.</span><br><span class="hljs-keyword">var</span> oneProp = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(oneProp) <span class="hljs-comment">//=== false</span><br><br><span class="hljs-comment">// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,</span><br><span class="hljs-comment">// 因为p属性仍然是可以配置的(而且可写的).</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(oneProp);<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(oneProp) <span class="hljs-comment">//=== false</span><br><br><span class="hljs-comment">// 此时,如果删除了这个属性,则它会成为一个冻结对象.</span><br><span class="hljs-keyword">delete</span> oneProp.<span class="hljs-property">p</span>;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(oneProp) <span class="hljs-comment">//=== true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS Array</title>
    <link href="/2021/01/01/2021-01-01-array/"/>
    <url>/2021/01/01/2021-01-01-array/</url>
    
    <content type="html"><![CDATA[<h3 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h3><p>从类数组对象或者可迭代对象中创建一个新的数组实例（属于浅拷贝）</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">form</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// [&#x27;f&#x27;,&#x27;o&#x27;,&#x27;o&#x27;]</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br><span class="hljs-comment">// [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>用一个固定值填充一个数组中从起始索引到终止索引内的全部元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">fill</span>(value,start,end)<span class="hljs-string">`</span><br><span class="hljs-string">1. Value:用来填充数数组元素的值；</span><br><span class="hljs-string">2. Start：起始索引，默认是0；可选</span><br><span class="hljs-string">3. End：终止索引，默认为this.length 可选</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-comment">// array.fill(0,2,4)</span><br><span class="hljs-comment">// [1,2,0,0,5]</span><br><span class="hljs-comment">// array.fill(5,1)</span><br><span class="hljs-comment">// [1,5,5,5,5]</span><br><span class="hljs-comment">// array.fill(6)</span><br><span class="hljs-comment">// [6,6,6,6,6]</span><br></code></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>创建一个新的数组，其包含通过所提供函数实现的测试的所有元素,不会    改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">&#x27;spray&#x27;</span>, <span class="hljs-string">&#x27;limit&#x27;</span>, <span class="hljs-string">&#x27;elite&#x27;</span>, <span class="hljs-string">&#x27;exuberant&#x27;</span>, <span class="hljs-string">&#x27;destruction&#x27;</span>, <span class="hljs-string">&#x27;present&#x27;</span>];<br><span class="hljs-keyword">const</span> result = words.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.<span class="hljs-property">length</span> &gt; <span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><span class="hljs-comment">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>返回数组中满足提供的测试函数的第一个元素的值，不会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">130</span>,<span class="hljs-number">44</span>]<br>array.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> element &gt; <span class="hljs-number">100</span>)<br><span class="hljs-comment">// 130</span><br><span class="hljs-comment">// array [5,12,8,130,44] 未改变原数组</span><br></code></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><p>返回数组中满足提供的测试函数的第一个元素的索引，若没有找到对应元素则返回-1</p><h4 id="应用场景：检索元素是否存在，用-1来做判断"><a href="#应用场景：检索元素是否存在，用-1来做判断" class="headerlink" title="应用场景：检索元素是否存在，用-1来做判断"></a>应用场景：检索元素是否存在，用-1来做判断</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">130</span>,<span class="hljs-number">44</span>]<br>array.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> element &gt; <span class="hljs-number">13</span>)<br><span class="hljs-comment">// 3</span><br>array.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> element &gt; <span class="hljs-number">200</span>)<br><span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h3><p>用于将嵌套的数组拉平，组成一个新数组<br><code>var newArray = arr.flat([depth]),depth:指定要提取嵌套数组的结构深度，默认    值是1 ,(Infinity，比较特殊，无论嵌套多少层都会转换成1维数组i)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br>arr.<span class="hljs-title function_">flat</span>()<br><span class="hljs-comment">// [0,1,2,3,4]</span><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[[[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]]]<br>arr2.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// [0,1,2,[3,4]]</span><br>arr2.<span class="hljs-title function_">flat</span>(<span class="hljs-number">3</span>)<br><span class="hljs-comment">// [0,1,2,3,4]</span><br>arr2.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)<br><span class="hljs-comment">// [0,1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p>对原数组的每个成员执行一个函数，对返回值组成的数组执行一次flat方法，flatMap只能展开一层数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x * <span class="hljs-number">2</span>])<br><span class="hljs-comment">// [[2],[4],[6],[8]]</span><br>arr.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x * <span class="hljs-number">2</span>])<br><span class="hljs-comment">// [2,4,6,8]</span><br>arr.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [[x * <span class="hljs-number">2</span>]])<br><span class="hljs-comment">// [[2],[4],[6],[8]]</span><br></code></pre></td></tr></table></figure><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>判断一个数组中是否包含一个指定的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// true</span><br><span class="hljs-keyword">const</span> pets = [<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>,<span class="hljs-string">&#x27;bat&#x27;</span>]<br>pets.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-comment">// true</span><br>pets.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;at&#x27;</span>)<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，返回(-1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> beasts= [<span class="hljs-string">&#x27;ant&#x27;</span>,<span class="hljs-string">&#x27;bison&#x27;</span>,<span class="hljs-string">&#x27;camel&#x27;</span>,<span class="hljs-string">&#x27;duck&#x27;</span>,<span class="hljs-string">&#x27;bison&#x27;</span>]<br>beasts.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;ant&#x27;</span>)<br><span class="hljs-comment">// true</span><br>beasts.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;camel&#x27;</span>)<br><span class="hljs-comment">// true</span><br>beasts.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;camel&#x27;</span>)<br><span class="hljs-comment">// 2</span><br>beasts.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;bison&#x27;</span>)<br><span class="hljs-comment">// 1</span><br>beasts.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;sss&#x27;</span>)<br><span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><p>返回指定元素在数组中的最后一个的索引，如果不存在返回-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> animals = [<span class="hljs-string">&#x27;Dodo&#x27;</span>,<span class="hljs-string">&#x27;Tiger&#x27;</span>,<span class="hljs-string">&#x27;Penguin&#x27;</span>,<span class="hljs-string">&#x27;Dodo&#x27;</span>]<br>animals.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;Dodo&#x27;</span>)<br><span class="hljs-comment">// 3</span><br>animals.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;Tiger&#x27;</span>)<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>将一个数组的所有元素连接成一个字符串并返回这个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> elements = [<span class="hljs-string">&#x27;Fire&#x27;</span>,<span class="hljs-string">&#x27;Air&#x27;</span>,<span class="hljs-string">&#x27;Water&#x27;</span>];<br>elements.<span class="hljs-title function_">join</span>()<br><span class="hljs-comment">// &quot;Fire,Air,Water&quot;</span><br>elements.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// &quot;FireAirWater&quot;</span><br>elements.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &quot;Fire-Air-Water&quot;</span><br></code></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p>从一个数组中删除并返回最后一个元素，原数组会被改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> plants = [<span class="hljs-string">&#x27;broccoli&#x27;</span>,<span class="hljs-string">&#x27;cauliflower&#x27;</span>,<span class="hljs-string">&#x27;cabbage&#x27;</span>,<span class="hljs-string">&#x27;kale&#x27;</span>,<span class="hljs-string">&#x27;tomato&#x27;</span>]<br>plants.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">//会改变原数组</span><br><span class="hljs-comment">// tomato</span><br>plants<br><span class="hljs-comment">// [&#x27;broccoli&#x27;,&#x27;cauliflower&#x27;,&#x27;cabbage&#x27;,&#x27;kale&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>对数组中的每个元素执行一个由您提供的reducer函数，将其结果汇总为单个返回值<br><code>arr.reduce(function(pre,cur) &#123;     ... &#125;,init)</code></p><ol><li>arr:表示原数组；</li><li>pre:表示上一次调用回调时的返回值，或者初始值init;</li><li>cur:表示正在处理的数组元素</li><li>Index:表示当前正在处理的数组元素的索引，若提供init值，则索引为0，否则索引为1；</li><li>Init:表示初始值<h4 id="最长用到的就是pre和cur-用法实例"><a href="#最长用到的就是pre和cur-用法实例" class="headerlink" title="最长用到的就是pre和cur 用法实例"></a>最长用到的就是pre和cur 用法实例</h4><code>var arr = [3,9,4,3,6,0,9]</code> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">求数组项之和 <br><span class="hljs-keyword">var</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev,cur</span>)&#123;<br>    <span class="hljs-keyword">return</span> pre + cur<br>&#125;,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//0+3+9+3+6+0+9</span><br></code></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">求数组项最大值<br><span class="hljs-keyword">var</span> max = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev,cur</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(prev,cur)<br>&#125;)<br>由于未传入初始值，所以开始时prev的值为数组第一项<span class="hljs-number">3</span>，cur的值为数组第二项<span class="hljs-number">9</span>，取最大值后继续进入下一轮回调<br></code></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   数组去重<br>   <span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev,cur</span>) &#123;<br>       prev.<span class="hljs-title function_">indexOf</span>(cur) === -<span class="hljs-number">1</span> &amp;&amp; prev.<span class="hljs-title function_">push</span>(cur);<br>       <span class="hljs-keyword">return</span> prev<br>   &#125;,[])<br>   实现原理：<br>   ① 初始化一个空数组<br>   ② 将需要去重处理的数组中的第<span class="hljs-number">1</span>项在初始化数组中查找，如果找不到（空数组中肯定找不到），就将该项添加到初始化数组中<br>   ③ 将需要去重处理的数组中的第<span class="hljs-number">2</span>项在初始化数组中查找，如果找不到，就将该项继续添加到初始化数组中<br>   ④ ……<br>⑤ 将需要去重处理的数组中的第n项在初始化数组中查找，如果找不到，就将该项继续添加到初始化数组中<br>⑥ 将这个初始化数组返回<br></code></pre></td></tr></table></figure></li></ol><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><p>从数组中删除第一个元素，并返回该元素，原始数组会被更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>array.<span class="hljs-title function_">shift</span>()<br><span class="hljs-comment">// 1</span><br>array<br><span class="hljs-comment">//[2,3]</span><br></code></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>返回一个新的数组对象，这一对象是一个由begin和end决定的原数组的浅拷贝，(包括begin，不包括end)，原始数组不变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">slice</span>(begin,end)<br><span class="hljs-comment">// 当begin为负数时，表示从倒数第几个元素开始提取</span><br><span class="hljs-keyword">const</span> animals = [<span class="hljs-string">&#x27;ant&#x27;</span>, <span class="hljs-string">&#x27;bison&#x27;</span>, <span class="hljs-string">&#x27;camel&#x27;</span>, <span class="hljs-string">&#x27;duck&#x27;</span>, <span class="hljs-string">&#x27;elephant&#x27;</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animals.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animals.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br><span class="hljs-comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animals.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>));<br><span class="hljs-comment">// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>测试数组中是不是至少有一个元素通过了被提供的函数测试，返回Boolean类型的值，方法数组中只要有一个为真，返回的就是true，反之则为false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">10</span>);  <span class="hljs-comment">// false</span><br>[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>通过删除或者替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容，原数组会改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> months = [<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;March&#x27;</span>, <span class="hljs-string">&#x27;April&#x27;</span>, <span class="hljs-string">&#x27;June&#x27;</span>];<br>months.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>);<br><span class="hljs-comment">// inserts at index 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months);<br><span class="hljs-comment">// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]</span><br><br>months.<span class="hljs-title function_">splice</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;May&#x27;</span>);<br><span class="hljs-comment">// replaces 1 element at index 4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months);<br><span class="hljs-comment">// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="toLocalString"><a href="#toLocalString" class="headerlink" title="toLocalString()"></a>toLocalString()</h3><p>返回一个字符串表示数组中的元素，数组中的元素将使用各自的toLocaleString方法转换成字符串吗，这些字符串将使用一个特定语言环境的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;12 Dec 1997 14:12:00 UTC&#x27;</span>)];<br><span class="hljs-comment">// [1, &quot;a&quot;, Fri Dec 12 1997 22:12:00 GMT+0800 (中国标准时间)]</span><br><span class="hljs-keyword">const</span> localeString = array.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;en&#x27;</span>,&#123;<span class="hljs-attr">timeZone</span>:<span class="hljs-string">&#x27;UTC&#x27;</span>&#125;);<br><span class="hljs-comment">// &quot;1,a,12/12/1997, 2:12:00 PM&quot;</span><br><span class="hljs-comment">// en:代表时间格式：英国、美国等默认的时间格式</span><br><span class="hljs-comment">// timeZone:代表的是时区，UTC代表的是默认时区</span><br></code></pre></td></tr></table></figure><h3 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h3><p>返回一个字符串，代表该数组的源代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// array.toSource()</span><br><span class="hljs-keyword">var</span> alpha = <span class="hljs-title function_">newArray</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br>alpha.<span class="hljs-title function_">toSource</span>()<br><span class="hljs-comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><p>返回一个新的array iterator对象，该对象包含每个索引的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">const</span> iterator = array.<span class="hljs-title function_">values</span>() <span class="hljs-comment">// 返回的是一个对象</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> iterator) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;<br><span class="hljs-comment">// &quot;a&quot;</span><br><span class="hljs-comment">// &quot;b&quot;</span><br><span class="hljs-comment">// &quot;c&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>REACT</title>
    <link href="/2020/05/11/2020-5-11-react/"/>
    <url>/2020/05/11/2020-5-11-react/</url>
    
    <content type="html"><![CDATA[<h3 id="react的extends的含义："><a href="#react的extends的含义：" class="headerlink" title="react的extends的含义："></a>react的extends的含义：</h3><p>es6形式的extends React.Component定义的组件</p><h3 id="react的redux"><a href="#react的redux" class="headerlink" title="react的redux"></a>react的redux</h3><p>action：要想更新state重的数据，需要发起一个action；action就是一个普通的javascript对象；<br>reducer：为了把action和state串起来，开发了一些函数(reducer)，reducer只是一个接收state和action，并返回新的state函数</p><h3 id="redux三大基本原则"><a href="#redux三大基本原则" class="headerlink" title="redux三大基本原则"></a>redux三大基本原则</h3><ol><li>单一数据源：整个应用的state被存储在一棵object tree中，并且这个object tree只存在于唯一一个store中；</li><li>state是只读的，唯一改变state的方法是action；</li><li>使用纯函数来修改数据</li></ol><h3 id="redux基础"><a href="#redux基础" class="headerlink" title="redux基础"></a>redux基础</h3><p>action-reducer-store-数据流</p><h3 id="store职责"><a href="#store职责" class="headerlink" title="store职责"></a>store职责</h3><ol><li>维持应用的state；</li><li>提供getState()方法获取state；</li><li>提供dispatch(action)方法更新state；</li><li>通过subscribe(listener)注册监听器；</li><li>通过subScribe(listener)返回的函数注销监听器</li></ol><h3 id="实现容器组件"><a href="#实现容器组件" class="headerlink" title="实现容器组件"></a>实现容器组件</h3><p>技术上讲，容器组件就是使用store.subscribe()从redux state树中读取部分数据，并通过props来把这些数据提供给要渲染的组件，可以手工开发容器组件，但建议使用react redux库的connect()方法来生成，这个方法做了性能优化来避免不必要的重复渲染。（这样你就不必为了性能而手动实现 React 性能优化建议 中的 shouldComponentUpdate 方法。）</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/2020/04/03/2020-04-03-interview/"/>
    <url>/2020/04/03/2020-04-03-interview/</url>
    
    <content type="html"><![CDATA[<h3 id="http与https的区别与作用："><a href="#http与https的区别与作用：" class="headerlink" title="http与https的区别与作用："></a>http与https的区别与作用：</h3><ol><li>https数据传输期间对信息进行加密；  </li><li>使用https可以提高seo，提高搜索排名；<br><a href="http://www.dede58.com/web/17553.html">为何会提高seo</a> </li><li>https是使用TLS/SSL加密的http协议；  </li><li>http的端口是80，https是433，https需要ca申请证书，一般免费证书很少，需要交费；  </li><li>http协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网(wwww:World Wide Web)服务器传输超文本到本地浏览器的传送协议。http是一个基于TCP/IP通信协议来传递数据(HTML文件，图片，查询结果等)。</li></ol><h3 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h3><p>闭包就是能够读取其他函数内部变量的函数，例如在js中，只有函数内部的自函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。<br><a href="https://blog.csdn.net/weixin_43586120/article/details/89456183">详解</a></p><h3 id="react与vue区别："><a href="#react与vue区别：" class="headerlink" title="react与vue区别："></a>react与vue区别：</h3><h4 id="react优点："><a href="#react优点：" class="headerlink" title="react优点："></a>react优点：</h4><p>虚拟DOM，丰富的js库；  </p><h4 id="react缺点："><a href="#react缺点：" class="headerlink" title="react缺点："></a>react缺点：</h4><p>react只是一个库，并不是完整的框架，需要配合react-router及redux或者dva；  </p><h4 id="vue优点："><a href="#vue优点：" class="headerlink" title="vue优点："></a>vue优点：</h4><p>易于上手，占用空间小；  </p><h4 id="vue缺点："><a href="#vue缺点：" class="headerlink" title="vue缺点："></a>vue缺点：</h4><p>框架市场份额小。  </p><h4 id="正式比较："><a href="#正式比较：" class="headerlink" title="正式比较："></a>正式比较：</h4><p>react使用的是jsx，vue使用的是html，react提供了一种Flux/Redux架构的创新解决方案，单向数据流，替代了传统的<a href="https://www.runoob.com/design-pattern/mvc-pattern.html"><em>MVC</em></a>框架；vue使用的是vuex的架构，架构不一样；react使用Create React App脚手架工具，vue使用vue-cli</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>HSTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6常见问题</title>
    <link href="/2020/04/01/2020-04-01-text/"/>
    <url>/2020/04/01/2020-04-01-text/</url>
    
    <content type="html"><![CDATA[<h3 id="es6的promise："><a href="#es6的promise：" class="headerlink" title="es6的promise："></a>es6的promise：</h3><p>看似同步的代码，解决异步问题，跳出回调地狱；一个promise是一个等待被执行的对象，当他执行完毕之后，其状态会变成resolved或者rejected;promise是同步的，then是异步的；  </p><p>es6处理异步的请求：promise和async-await</p><h3 id="es6的symbol："><a href="#es6的symbol：" class="headerlink" title="es6的symbol："></a>es6的symbol：</h3><p>这是一种新的数据类型，他的值是唯一的不可变的，是独一无二的值；<br><a href="http://es6.ruanyifeng.com/#docs/symbol"><em>详解</em></a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>HSTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题(-)</title>
    <link href="/2020/01/22/2021-01-22-leetcode-one/"/>
    <url>/2020/01/22/2021-01-22-leetcode-one/</url>
    
    <content type="html"><![CDATA[<p>本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，补充js基础</p><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a>：<br>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>你可以按任意顺序返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">示例1:<br>输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br><br>示例2:<br>输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br><br>示例3:<br>输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h4 id="答案一："><a href="#答案一：" class="headerlink" title="答案一："></a>答案一：</h4><p>我的方法:for循环获取减法并且判断数组是否存在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> arrayIndex = []<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;= nums.<span class="hljs-property">length</span>;i++) &#123;<br>        <span class="hljs-keyword">let</span> newData = target -  nums[i];<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-title function_">indexOf</span>(target -  nums[i]) &gt; -<span class="hljs-number">1</span> &amp;&amp; nums.<span class="hljs-title function_">lastIndexOf</span>(newData) !== i) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nums.<span class="hljs-title function_">lastIndexOf</span>(newData))<br>            arrayIndex = [i,nums.<span class="hljs-title function_">lastIndexOf</span>(newData)]<br>            <span class="hljs-keyword">return</span> arrayIndex<br>        &#125;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2.整数反转"></a>2.整数反转</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a>：<br>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs llvm">示例<span class="hljs-number">1</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br>输出：<span class="hljs-number">321</span><br><br>示例<span class="hljs-number">2</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">-123</span><br>输出：<span class="hljs-number">-321</span><br><br>示例<span class="hljs-number">3</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">120</span><br>输出：<span class="hljs-number">21</span><br><br>示例<span class="hljs-number">4</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h4><p>我的方法：转换成字符串然后声生成数组，reverse，然后正则去掉’,’；比较繁琐与麻烦<br>Math.pow():用来写次方的方法 2的31次方===Math.pow(2,31)</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param &#123;number&#125; x</span><br><span class="hljs-comment"> * @return &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">reverse</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    let newX;<br>    let flag = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(x) &gt;= <span class="hljs-number">0</span>) &#123;<br>        newX = x.toString().<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-built_in">reverse</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        flag = <span class="hljs-number">-1</span><br>        newX = Math.<span class="hljs-built_in">abs</span>(x).toString().<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-built_in">reverse</span>()  <br>    &#125;<br>    let newNumber = <span class="hljs-built_in">Number</span>(newX.toString().<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/,/g</span>,<span class="hljs-string">&#x27;&#x27;</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">-2</span>,<span class="hljs-number">31</span>)) &lt;= newNumber &amp;&amp;  newNumber &lt;=<span class="hljs-built_in">Number</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>))) &#123;<br>        <span class="hljs-keyword">return</span> flag*newNumber<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h3><p>这个答案相当简洁，运用了Math的用法，以及字符串简单转换</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">Math.<span class="hljs-keyword">sign</span>():获取传入的值判断是正负，正值是<span class="hljs-number">1</span>，负值是-<span class="hljs-number">1</span>；<br>Math.<span class="hljs-built_in">abs</span>():将数字取绝对值<br>var <span class="hljs-built_in">reverse</span> = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">x</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">sign</span> = Math.<span class="hljs-keyword">sign</span>(<span class="hljs-keyword">x</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">res</span> = (Math.<span class="hljs-built_in">abs</span>(<span class="hljs-keyword">x</span>) + <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) * <span class="hljs-keyword">sign</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">res</span> &gt; Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span> || <span class="hljs-keyword">res</span> &lt; Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) * -<span class="hljs-number">1</span>) <span class="hljs-keyword">res</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-回文数"><a href="#3-回文数" class="headerlink" title="3.回文数"></a>3.回文数</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">121</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span><br><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">-121</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">false</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><br><span class="hljs-attribute">示例 3</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">10</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">false</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">从右向左读, 为 01 。因此它不是一个回文数。</span><br></code></pre></td></tr></table></figure><h3 id="答案一-1"><a href="#答案一-1" class="headerlink" title="答案一"></a>答案一</h3><p>我的答案是将数字转换成字符串然后倒转，判断Number值是否相等</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">x = <span class="hljs-number">121</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">var</span> newX = x.toString().<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(x) === <span class="hljs-built_in">Number</span>(newX)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内置对象之数组</title>
    <link href="/2019/11/12/2019-11-12-js-array/"/>
    <url>/2019/11/12/2019-11-12-js-array/</url>
    
    <content type="html"><![CDATA[<p>本文为了详细记录JavaScript内置对象中的一些方法</p>]]></content>
    
    
    <categories>
      
      <category>js基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器输入 URL 回车之后发生了什么</title>
    <link href="/2019/09/16/2019-09-16-browser-input-all/"/>
    <url>/2019/09/16/2019-09-16-browser-input-all/</url>
    
    <content type="html"><![CDATA[<p>不久前看了一篇文章<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么</a>, 感觉讲的实在很好所以在此我也想总结一下,当自己被问到这个问题的时候会如何回答呢?</p><p>在浏览器输入 URL 回车之后发生了什么？<br>大致流程如下</p><ul><li>1.URL解析</li><li>2.DNS查询；</li><li>3.建立TCP连接；</li><li>4.发送HTTP请求；</li><li>5.服务器处理请求；</li><li>6.返回响应结果；</li><li>7.关闭TCP连接；</li><li>8.浏览器解析HTML；</li><li>9.浏览器布局渲染；</li></ul><p>当我们在浏览器输入网址回车后,一切从这里开始</p><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><blockquote><p><code>HSTS(HTTP Strict Transport Security), 强制客户端使用 HTTPS 访问页面</code>,<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/">你不知道的HSTS</a></p></blockquote><p>首先判断你输入的是一个合法的URL还是一个带搜索的关键词</p><ul><li>如果输入的是内容则将输入内容自动编码。</li><li>输入的是网址向服务器请求我们想要的页面内容则开始进行DNS域名查询</li></ul><p>浏览器需要首先确认的是域名所对应的服务器在哪里,将域名解析成对应的服务器IP地址这项工作,是由DNS服务器来完成的.<br>客户端收到你输入的域名地址后,</p><ul><li>1.首先会从浏览器缓存中查找是否有对应域名</li><li>2.操作系统缓存</li><li>3.路由器DNS缓存</li><li>4.查找本地的hosts文件</li><li>5.ISP的DNS服务器</li><li>6.根域名服务器 <a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8">维基百科</a></li></ul><blockquote><p><code>ISP</code>是<code>Internet Service Provider(因特网服务提供商)</code>的简称,ISP有专门的DNS服务器应对DNS查询请求.每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来。</p></blockquote><blockquote><p>ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）。</p></blockquote><h4 id="根域名服务器查询"><a href="#根域名服务器查询" class="headerlink" title="根域名服务器查询"></a>根域名服务器查询</h4><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：<br><img src="https://cdn.darknights.cn/assets/images/in-post/browser-input/search.png"></p><p>需要注意的点</p><ul><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li><li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li><li><a href="https://www.bisend.cn/blog/dns-ji-chi-yu-wu-ran">什么是 DNS 劫持</a></li><li><a href="https://zhuanlan.zhihu.com/p/50043595">前端 dns-prefetch 优化</a></li></ul><p>递归查询：<br>    主机向本地域名服务器的查询一般都是采用递归查询。<br>    如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址</p><p>迭代查询：<br>    本地域名服务器向根域名服务器的查询通常是采用迭代查询。<br>    当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP/IP 分四层,在发送数据时,每层都要对数据进行封装</p><p><img src="https://cdn.darknights.cn/assets/images/in-post/browser-input/tcp.png"></p><h4 id="应用层-发送HTTP请求"><a href="#应用层-发送HTTP请求" class="headerlink" title="应用层:发送HTTP请求"></a>应用层:发送HTTP请求</h4><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h4 id="传输层-TCP传输报文"><a href="#传输层-TCP传输报文" class="headerlink" title="传输层: TCP传输报文"></a>传输层: TCP传输报文</h4><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。<a href="https://github.com/jawil/blog/issues/14">通俗解释TCP协议三次握手</a>、<a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html">计算机网络</a></p><blockquote><p><a href="https://blog.csdn.net/cpcpcp123/article/details/52739407">SYN 泛洪攻击</a></p></blockquote><h4 id="网络层-IP协议查询Mac地址"><a href="#网络层-IP协议查询Mac地址" class="headerlink" title="网络层: IP协议查询Mac地址"></a>网络层: IP协议查询Mac地址</h4><p>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。<br>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 <a href="https://zhuanlan.zhihu.com/p/28771785">ARP 协议</a>查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 <a href="https://zhuanlan.zhihu.com/p/28771785">ARP</a> 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><h4 id="链路层-以太网协议"><a href="#链路层-以太网协议" class="headerlink" title="链路层: 以太网协议"></a>链路层: 以太网协议</h4><p>根据以太网协议将数据分为以”帧”为单位的数据包, 每一帧分为两个部分:</p><ul><li>标头: 数据包的发送者、接受者、数据类型</li><li>数据: 数据包具体内容</li></ul><blockquote><p>Mac地址<br>以太网规定了连入网络的所有设备都必须具备“网卡”接口, 数据包都是从一块网卡传递到另一块网卡,网卡地址就是Mac地址.每一个Mac地址都是独一无二的,具备了一对一的能力.</p></blockquote><blockquote><p>广播<br>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。 但是接受方回应是单播.</p></blockquote><h4 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a>服务器接受请求</h4><h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><h4 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h4><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。<br>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><h4 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h4><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="浏览器接受响应"><a href="#浏览器接受响应" class="headerlink" title="浏览器接受响应"></a>浏览器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p><h3 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h3><p><img src="https://cdn.darknights.cn/assets/images/in-post/browser-input/core.png"></p><p><img src="https://cdn.darknights.cn/assets/images/in-post/browser-input/process.png"></p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="https://hellogithub2014.github.io/2017/09/24/how-do-network-connect/">从浏览器输入url按回车后发生了什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/50043595">浏览器探究&amp;前端优化指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/28771785">ARP</a></li><li><a href="https://www.bisend.cn/blog/dns-ji-chi-yu-wu-ran">什么是DNS劫持与DNS污染</a></li><li><a href="https://juejin.im/post/59ba146c6fb9a00a4636d8b6">深入理解Http请求、DNS劫持与解析</a></li><li><a href="https://blog.csdn.net/it_rod/article/details/79939651">HTTP基础与DNS分析</a></li><li><a href="https://www.cnblogs.com/gopark/p/8430916.html">DNS原理及其解析过程</a></li><li><a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么</a></li><li><a href="http://www.cnblogs.com/xsilence/">DNS查找域名的过程</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>HSTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结(简单版五)</title>
    <link href="/2019/09/08/2019-09-08-leetcode-five/"/>
    <url>/2019/09/08/2019-09-08-leetcode-five/</url>
    
    <content type="html"><![CDATA[<p>本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</p><h3 id="1-两个数组的交集"><a href="#1-两个数组的交集" class="headerlink" title="1.两个数组的交集"></a>1.两个数组的交集</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a>：<br>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">示例 1:<br><br>输入: nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出: <span class="hljs-comment">[2]</span><br>示例 2:<br><br>输入: nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出: <span class="hljs-comment">[9,4]</span><br><br></code></pre></td></tr></table></figure><p>说明:</p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><h4 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h4><p>自己的解法常规思路不推荐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> intersection = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) &#123;<br>    <br>    <span class="hljs-keyword">let</span> resultDup = [];<br>    nums1.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>        nums2.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span>(val == v) &#123;<br>                resultDup.<span class="hljs-title function_">push</span>(val);<br>            &#125;<br>        &#125;)<br>    &#125;);<br>    <br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">while</span>(resultDup.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> val = resultDup.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">if</span>(resultDup.<span class="hljs-title function_">indexOf</span>(val) &lt; <span class="hljs-number">0</span>) &#123;<br>            result.<span class="hljs-title function_">push</span>(val);    <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>    <br>&#125;;<br><br></code></pre></td></tr></table></figure><p>同样js解法利用Set去重复</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> intersection = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) &#123;<br>    <span class="hljs-keyword">let</span> hash1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(nums1)<br>    <span class="hljs-keyword">let</span> hash2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(has1.<span class="hljs-title function_">has</span>(nums2[i])) &#123;<br>            hash2.<span class="hljs-title function_">add</span>(nums2[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [...hash2]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>利用数组api解法,更简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> intersection = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums1, nums2</span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(nums1.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> nums2.<span class="hljs-title function_">includes</span>(v)))];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        HashSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(Integer n : nums1) set1.add(n);<br><br>        HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(Integer n : nums2) set2.add(n);<br><br>        set1.retainAll(set2);<br><br>        <span class="hljs-type">int</span>[] output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[set1.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s : set) output[idx++] = s;<br>        <span class="hljs-keyword">return</span> output;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-独一无二的出现次数"><a href="#2-独一无二的出现次数" class="headerlink" title="2.独一无二的出现次数"></a>2.独一无二的出现次数</h3><p> <a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/">独一无二的出现次数</a>:<br> 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p><p>提示：</p><ul><li>1 &lt;= arr.length &lt;= 1000</li><li>-1000 &lt;= arr[i] &lt;= 1000</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nix">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：在该数组中，<span class="hljs-number">1</span> 出现了 <span class="hljs-number">3</span> 次，<span class="hljs-number">2</span> 出现了 <span class="hljs-number">2</span> 次，<span class="hljs-number">3</span> 只出现了 <span class="hljs-number">1</span> 次。没有两个数的出现次数相同。<br>示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br>示例 <span class="hljs-number">3</span>：<br><br>输入：<span class="hljs-attr">arr</span> = [-<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-1"><a href="#答案一-1" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniqueOccurrences = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> objMap = &#123;&#125;<br>    <br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(objMap.<span class="hljs-title function_">hasOwnProperty</span>(val)) &#123;<br>            objMap[val]++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            objMap[val] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;)<br>    <br>    <span class="hljs-keyword">let</span> arr1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(objMap);<br>    <span class="hljs-keyword">let</span> arr2 = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr1)];<br>    <br>    <span class="hljs-keyword">return</span> arr1.<span class="hljs-property">length</span> === arr2.<span class="hljs-property">length</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-1"><a href="#答案二-1" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">uniqueOccurrences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        Set&lt;Inetger&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> data: arr) &#123;<br>            <span class="hljs-keyword">if</span>(map.get(data) == <span class="hljs-literal">null</span>) map.put(data,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> map.put(data, map.get(data) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Integer i : map.values()) &#123;<br>            <span class="hljs-keyword">if</span>(!set.add(i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-转置矩阵"><a href="#3-转置矩阵" class="headerlink" title="3.转置矩阵"></a>3.转置矩阵</h3><p><a href="https://leetcode-cn.com/problems/transpose-matrix/submissions/">转置矩阵</a>:<br>给定一个矩阵 A， 返回 A 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 1000</li><li>1 &lt;= A[0].length &lt;= 1000</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[1,4,7],[2,5,8],[3,6,9]]</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-string">[[1,4],[2,5],[3,6]]</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-2"><a href="#答案一-2" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> transpose = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = A[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> alen = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> tmpl = [];<br>        A.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idex</span>) =&gt;</span> &#123;<br>            tmpl.<span class="hljs-title function_">push</span>(val[i]);<br>        &#125;);<br>        result.<span class="hljs-title function_">push</span>(tmpl);<br>    &#125;<br>    <br>   <span class="hljs-keyword">return</span> result;<br>    <br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="4-重复-N-次的元素"><a href="#4-重复-N-次的元素" class="headerlink" title="4.重复 N 次的元素"></a>4.重复 N 次的元素</h3><p><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/submissions/">重复 N 次的元素</a>:<br>在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。</p><p>返回重复了 N 次的那个元素。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">1</span>：<br><br>输入：[<span class="hljs-number">1,2,3,3</span>]<br>输出：<span class="hljs-number">3</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：[<span class="hljs-number">2,1,2,5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>示例 <span class="hljs-number">3</span>：<br><br>输入：[<span class="hljs-number">5,1,5,2</span>,<span class="hljs-number">5,3,5,4</span>]<br>输出：<span class="hljs-number">5</span><br><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>4 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt; 10000</li><li>A.length 为偶数</li></ul><h4 id="答案一-3"><a href="#答案一-3" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> repeatedNTimes = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    A.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a-b);<br>    <span class="hljs-keyword">let</span> len = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">let</span> cur = A[i]<br>            <span class="hljs-keyword">let</span> prev = A[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(cur - prev === <span class="hljs-number">0</span>) &#123;<br>                result = cur;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-按奇偶排序数组-II"><a href="#5-按奇偶排序数组-II" class="headerlink" title="5.按奇偶排序数组 II"></a>5.按奇偶排序数组 II</h3><p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">按奇偶排序数组 II</a>:<br>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p><p>提示：</p><ul><li>2 &lt;= A.length &lt;= 20000</li><li>A.length % 2 == 0</li><li>0 &lt;= A[i] &lt;= 1000</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">示例：<br><br>输入：<span class="hljs-selector-attr">[4,2,5,7]</span><br>输出：<span class="hljs-selector-attr">[4,5,2,7]</span><br>解释：<span class="hljs-selector-attr">[4,7,2,5]</span>，<span class="hljs-selector-attr">[2,5,4,7]</span>，<span class="hljs-selector-attr">[2,7,4,5]</span> 也会被接受。<br></code></pre></td></tr></table></figure><h4 id="答案一-4"><a href="#答案一-4" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortArrayByParityII = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> oArr = A.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> (val % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> eArr = A.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> (val % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>            result.<span class="hljs-title function_">push</span>(eArr.<span class="hljs-title function_">shift</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(oArr.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>    <br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-2"><a href="#答案二-2" class="headerlink" title="答案二"></a>答案二</h4><p>java容易理解的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sortArrayByParityII(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> arr;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(odd &lt; len &amp;&amp; even &lt; len) &#123;<br>            <span class="hljs-keyword">while</span>(odd &lt; len &amp;&amp; arr[odd] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>                odd += <span class="hljs-number">2</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(even &lt; len &amp;&amp; arr[even] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                even += <span class="hljs-number">2</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(odd &lt; len &amp;&amp; even &lt; len) &#123;<br>                swap(arr, odd, even);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> odd, <span class="hljs-type">int</span> even)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[odd];<br>        arr[odd] = arr[even];<br>        arr[even] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案三"><a href="#答案三" class="headerlink" title="答案三"></a>答案三</h4><p>js双指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> sortArrayByParityII = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123; <br>    <span class="hljs-keyword">let</span> len = A.<span class="hljs-property">length</span>,<br>        i = <span class="hljs-number">0</span>,<br>        j = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(; i &lt; len; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">while</span>(A[j] % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>);j += <span class="hljs-number">2</span>;<br><br>        [A[i], A[j]] = [A[j], A[i]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-单值二叉树"><a href="#6-单值二叉树" class="headerlink" title="6.单值二叉树"></a>6.单值二叉树</h3><p><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">单值二叉树</a>:<br>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p><p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p><p>提示：</p><ul><li>给定树的节点数范围是 [1, 100]。</li><li>每个节点的值都是整数，范围为 [0, 99] 。</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">示例 <span class="hljs-number">1</span>：<br><br>输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-5"><a href="#答案一-5" class="headerlink" title="答案一"></a>答案一</h4><p>更优雅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUnivalTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> helper(root, root.val);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(val != root.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> helper(root.left, val) &amp;&amp; helper(root.right, val);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUnivalTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        IsUnivalTree(root, root.val);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">IsUnivalTree</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root.val == val) &#123;<br>            IsunivalTree(root.left, val);<br>            IsunivalTree(root.right, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isUnivalTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">helper</span>(root, root.<span class="hljs-property">val</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span> !== val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">left</span>, val) &amp;&amp; <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">right</span>, val);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-找出给定方程的正整数解"><a href="#7-找出给定方程的正整数解" class="headerlink" title="7.找出给定方程的正整数解~~~"></a>7.找出给定方程的正整数解~~~</h3><p><a href="https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/">找出给定方程的正整数解</a>:<br>给出一个函数  f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。</p><p>给定函数是严格单调的，也就是说：</p><p>f(x, y) &lt; f(x + 1, y)</p><p>f(x, y) &lt; f(x, y + 1)<br>函数接口定义如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">CustomFunction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Returns positive integer f(x, y) for any given positive integer x and y.</span><br>  <span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y);<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。  </p><p>你可以将满足条件的 结果数对 按任意顺序返回。</p><p>提示：</p><ul><li>1 &lt;= function_id &lt;= 9</li><li>1 &lt;= z &lt;= 100</li><li>题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。</li><li>在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br>示例 <span class="hljs-number">1</span>：<br><br>输入：function_id = <span class="hljs-number">1</span>, z = <span class="hljs-number">5</span><br>输出：<span class="hljs-string">[[1,4],[2,3],[3,2],[4,1]]</span><br>解释：function_id = <span class="hljs-number">1</span> 表示 f(x, y) = x + y<br>示例 <span class="hljs-number">2</span>：<br><br>输入：function_id = <span class="hljs-number">2</span>, z = <span class="hljs-number">5</span><br>输出：<span class="hljs-string">[[1,5],[5,1]]</span><br>解释：function_id = <span class="hljs-number">2</span> 表示 f(x, y) = x * y<br><br></code></pre></td></tr></table></figure><h4 id="答案一-6"><a href="#答案一-6" class="headerlink" title="答案一"></a>答案一</h4><p>分析:题目没有看懂,但是可以读懂代码</p><p>双层循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is the CustomFunction&#x27;s API interface.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * function CustomFunction() &#123;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer, integer</span>&#125; x, y</span><br><span class="hljs-comment"> *     <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">integer</span>&#125;</span><br><span class="hljs-comment"> *     this.f = function(x, y) &#123;</span><br><span class="hljs-comment"> *         ...</span><br><span class="hljs-comment"> *     &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">CustomFunction</span>&#125; <span class="hljs-variable">customfunction</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer</span>&#125; <span class="hljs-variable">z</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">integer[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> findSolution = <span class="hljs-keyword">function</span>(<span class="hljs-params">customfunction, z</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">1000</span>; x++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> y = <span class="hljs-number">1</span>; y &lt;= <span class="hljs-number">1000</span>; y++) &#123;<br>            <span class="hljs-keyword">if</span>(customfunction.<span class="hljs-title function_">f</span>(x, y) &gt; z) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(customfunction.<span class="hljs-title function_">f</span>(x, y) === z) &#123;<br>                <span class="hljs-keyword">let</span> ans = [x, y];<br>                res.<span class="hljs-title function_">push</span>(ans);<br>            &#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is the CustomFunction&#x27;s API interface.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * function CustomFunction() &#123;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer, integer</span>&#125; x, y</span><br><span class="hljs-comment"> *     <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">integer</span>&#125;</span><br><span class="hljs-comment"> *     this.f = function(x, y) &#123;</span><br><span class="hljs-comment"> *         ...</span><br><span class="hljs-comment"> *     &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">CustomFunction</span>&#125; <span class="hljs-variable">customfunction</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer</span>&#125; <span class="hljs-variable">z</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">integer[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> findSolution = <span class="hljs-keyword">function</span>(<span class="hljs-params">customfunction, z</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">1000</span> &amp;&amp; y &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt;= <span class="hljs-number">1000</span>) &#123;<br>        <span class="hljs-keyword">if</span>(customfunction.<span class="hljs-title function_">f</span>(x, y) === z) &#123;<br>            <span class="hljs-keyword">let</span> ans = [x ,y];<br>            res.<span class="hljs-title function_">push</span>(ans);<br>            x++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(customfunction.<span class="hljs-title function_">f</span>(x, y) &gt; z) &#123;<br>            y--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="8-Excel表列序号"><a href="#8-Excel表列序号" class="headerlink" title="8.Excel表列序号"></a>8.Excel表列序号</h3><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/submissions/">Excel表列序号</a>:</p><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs clean">例如，<br><br>    A -&gt; <span class="hljs-number">1</span><br>    B -&gt; <span class="hljs-number">2</span><br>    C -&gt; <span class="hljs-number">3</span><br>    ...<br>    Z -&gt; <span class="hljs-number">26</span><br>    AA -&gt; <span class="hljs-number">27</span><br>    AB -&gt; <span class="hljs-number">28</span> <br>    ...<br>示例 <span class="hljs-number">1</span>:<br><br>输入: <span class="hljs-string">&quot;A&quot;</span><br>输出: <span class="hljs-number">1</span><br>示例 <span class="hljs-number">2</span>:<br><br>输入: <span class="hljs-string">&quot;AB&quot;</span><br>输出: <span class="hljs-number">28</span><br>示例 <span class="hljs-number">3</span>:<br><br>输入: <span class="hljs-string">&quot;ZY&quot;</span><br>输出: <span class="hljs-number">701</span><br></code></pre></td></tr></table></figure><h4 id="答案一-7"><a href="#答案一-7" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> titleToNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= len) &#123;<br>        <span class="hljs-keyword">let</span> num = arr.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">let</span> cur = num.<span class="hljs-title function_">charCodeAt</span>() - <span class="hljs-number">64</span>;<br>        sum += cur * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">26</span>, i - <span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结(简单版四)</title>
    <link href="/2019/09/07/2019-09-07-leetcode-four/"/>
    <url>/2019/09/07/2019-09-07-leetcode-four/</url>
    
    <content type="html"><![CDATA[<p>本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</p><h3 id="1-反转字符串中的单词-III"><a href="#1-反转字符串中的单词-III" class="headerlink" title="1.反转字符串中的单词 III"></a>1.反转字符串中的单词 III</h3><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/submissions/">反转字符串中的单词 III</a>：<br>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Let&#x27;s take LeetCode contest&quot;</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot; </span><br></code></pre></td></tr></table></figure><h4 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseWords = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> (s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>))).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h4><p>稍微有点取巧的做法，reverse函数也可以用双指针实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> <br>    &#123;<br>        String[] sp=s.split(<span class="hljs-string">&quot; &quot;</span>);<br>        StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=sp.length-<span class="hljs-number">1</span>;i++)<br>        &#123;<br>            StringBuilder t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            t.append(sp[i]);<br>            sb.append(t.reverse().toString()).append(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.substring(<span class="hljs-number">0</span>,sb.length()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-反转字符串"><a href="#2-反转字符串" class="headerlink" title="2.反转字符串"></a>2.反转字符串</h3><p><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a>:<br>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span><br>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-1"><a href="#答案一-1" class="headerlink" title="答案一"></a>答案一</h4><p>reverse</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">character[]</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify s in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseString = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">reverse</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-1"><a href="#答案二-1" class="headerlink" title="答案二"></a>答案二</h4><p>其实本题并不是想考reverse, 感觉应该是想考reverse的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">character[]</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify s in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseString = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">var</span> len = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, center = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>); i &lt; center; i++) &#123;<br>        <span class="hljs-keyword">let</span> edx = len - i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> temp = s[edx];<br>        s[edx] = s[i];<br>        s[i] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-数组拆分-I"><a href="#3-数组拆分-I" class="headerlink" title="3.数组拆分 I"></a>3.数组拆分 I</h3><p><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a>:<br>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p>提示:</p><ul><li>n 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ul><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[1,4,3,2]</span><br><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></code></pre></td></tr></table></figure><h4 id="答案一-2"><a href="#答案一-2" class="headerlink" title="答案一"></a>答案一</h4><p>首先排序 ,然后将index为奇数的进行求和.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> arrayPairSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> sortNums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    sortNums.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val, key</span>) &#123;<br>      <span class="hljs-keyword">if</span>(key % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)  &#123;<br>          sum += val;<br>      &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-键盘行"><a href="#4-键盘行" class="headerlink" title="4.键盘行"></a>4.键盘行</h3><p><a href="https://leetcode-cn.com/problems/keyboard-row/">键盘行</a>:</p><p>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/keyboard.png"><br>注意：</p><ul><li>你可以重复使用键盘上同一字符。</li><li>你可以假设输入的字符串将只包含字母。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">示例：<br><br>输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Alaska&quot;</span>, <span class="hljs-string">&quot;Dad&quot;</span>, <span class="hljs-string">&quot;Peace&quot;</span>]</span><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Alaska&quot;</span>, <span class="hljs-string">&quot;Dad&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="答案一-3"><a href="#答案一-3" class="headerlink" title="答案一"></a>答案一</h4><p>分析: 定好map对应关系 两层遍历就可以,可以先取到首字母的指然后判断是否跟首字母相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">words</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findWords = <span class="hljs-keyword">function</span>(<span class="hljs-params">words</span>) &#123;<br>    <span class="hljs-keyword">let</span> alObj = &#123;<br>        <span class="hljs-attr">q</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">w</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">e</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">t</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">u</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">i</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">q</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">o</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">p</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">s</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">d</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">f</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">g</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">h</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">j</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">k</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">l</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">c</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">v</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>,<span class="hljs-attr">m</span>: <span class="hljs-number">2</span><br>    &#125;;<br>    <br>    <span class="hljs-keyword">let</span> lWords = words.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.<span class="hljs-title function_">toLowerCase</span>());<br>    <span class="hljs-keyword">let</span> leng = lWords.<span class="hljs-property">length</span>;<br>    <br>    <span class="hljs-keyword">let</span> result = [];<br>    <br>    lWords.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">str, key</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;    <br>        <span class="hljs-keyword">let</span> first =  alObj[str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>)];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">let</span> current = alObj[str.<span class="hljs-title function_">charAt</span>(i)];<br>            <span class="hljs-keyword">if</span>(first !== current) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            result.<span class="hljs-title function_">push</span>(words[key]);<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> result;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-2"><a href="#答案二-2" class="headerlink" title="答案二"></a>答案二</h4><p>正则表达式匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findWords = <span class="hljs-keyword">function</span>(<span class="hljs-params">words</span>) &#123;<br>    <span class="hljs-keyword">let</span> reg1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;[qwertyuiop]&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br>    <span class="hljs-keyword">let</span> reg2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;[asdfghjkl]&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br>    <span class="hljs-keyword">let</span> reg3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;[zxcvbnm]&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br>    <span class="hljs-keyword">let</span> result = [];<br>    words.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> flag1 = reg1.<span class="hljs-title function_">test</span>(word);<br>        <span class="hljs-keyword">let</span> flag2 = reg2.<span class="hljs-title function_">test</span>(word);<br>        <span class="hljs-keyword">let</span> flag3 = reg3.<span class="hljs-title function_">test</span>(word);<br>        <br>        <span class="hljs-keyword">if</span>((flag1 &amp;&amp; !flag2 &amp;&amp; !flag3)||(!flag1 &amp;&amp; !flag2 &amp;&amp; flag3)||(!flag1 &amp;&amp; flag2 &amp;&amp; !flag3))&#123;<br>            result.<span class="hljs-title function_">push</span>(word);<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> result;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="答案三"><a href="#答案三" class="headerlink" title="答案三"></a>答案三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] findWords(String[] workds) &#123;<br>        <span class="hljs-keyword">if</span>(words == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        String[] lines = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<br>            <span class="hljs-string">&quot;qwertyuiop&quot;</span>,<br>            <span class="hljs-string">&quot;asdfghjkl&quot;</span>,<br>            <span class="hljs-string">&quot;zxcvbnm&quot;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(String word: words) &#123;<br>            <span class="hljs-keyword">if</span>(judge(word.toLowerCase(), lines)) &#123;<br>                ans.add(word);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[ans.size()]);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(String word, String[] lines)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">find</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span>(String line: lines) &#123;<br>            <span class="hljs-keyword">if</span>(line.indexOf(word.charAt(<span class="hljs-number">0</span>)) &gt; -<span class="hljs-number">1</span>) &#123;<br>                find = line;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(find == <span class="hljs-literal">null</span>) &#123;<br>            ok = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> ok;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">ini</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; word.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(find.indexOf(word.charAt(i)) &lt; <span class="hljs-number">0</span>) &#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ok;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-猜数字"><a href="#5-猜数字" class="headerlink" title="5.猜数字"></a>5.猜数字</h3><p><a href="https://leetcode-cn.com/problems/guess-numbers/">猜数字</a>:<br>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？<br>输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</p><p>限制：</p><ul><li>guess的长度 = 3</li><li>answer的长度 = 3</li><li>guess的元素取值为 {1, 2, 3} 之一。</li><li>answer的元素取值为 {1, 2, 3} 之一。</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br><br>输入：guess = <span class="hljs-comment">[1,2,3]</span>, answer = <span class="hljs-comment">[1,2,3]</span><br>输出：3<br>解释：小A 每次都猜对了。<br> <br><br>示例 2：<br><br>输入：guess = <span class="hljs-comment">[2,2,3]</span>, answer = <span class="hljs-comment">[3,2,1]</span><br>输出：1<br>解释：小A 只猜对了第二次。<br><br></code></pre></td></tr></table></figure><h4 id="答案一-4"><a href="#答案一-4" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">guess</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">answer</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> game = <span class="hljs-keyword">function</span>(<span class="hljs-params">guess, answer</span>) &#123;<br>    <span class="hljs-keyword">return</span> guess.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">val, key</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> val === answer[key];<br>    &#125;).<span class="hljs-property">length</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="答案二-3"><a href="#答案二-3" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">game</span><span class="hljs-params">(<span class="hljs-type">int</span>[] guess, <span class="hljs-type">int</span>[] answer)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(guess[i] == answer[i]) &#123;<br>                counter++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-删列造序"><a href="#6-删列造序" class="headerlink" title="6.删列造序"></a>6.删列造序</h3><p><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted/">删列造序</a>:<br>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。</p><p>删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。</p><p>比如，有 A = [“abcdef”, “uvwxyz”]，<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/944_1.png"><br>要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/944_2.png"><br>你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。</p><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 100</li><li>1 &lt;= A[i].length &lt;= 1000</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs prolog">示例 <span class="hljs-number">1</span>：<br><br>输入：[<span class="hljs-string">&quot;cba&quot;</span>, <span class="hljs-string">&quot;daf&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>]<br>输出：<span class="hljs-number">1</span><br>解释：<br>当选择 <span class="hljs-symbol">D</span> = &#123;<span class="hljs-number">1</span>&#125;，删除后 <span class="hljs-symbol">A</span> 的列为：[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>] 和 [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>]，均为非降序排列。<br>若选择 <span class="hljs-symbol">D</span> = &#123;&#125;，那么 <span class="hljs-symbol">A</span> 的列 [<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>] 就不是非降序排列了。<br>示例 <span class="hljs-number">2</span>：<br><br>输入：[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-symbol">D</span> = &#123;&#125;<br>示例 <span class="hljs-number">3</span>：<br><br>输入：[<span class="hljs-string">&quot;zyx&quot;</span>, <span class="hljs-string">&quot;wvu&quot;</span>, <span class="hljs-string">&quot;tsr&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-symbol">D</span> = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="答案一-5"><a href="#答案一-5" class="headerlink" title="答案一"></a>答案一</h4><p>分析: 按照题意来说只要满足每一列的字母 b &gt; a 就需要将结果加一.这里使用<code>charCodeAt()</code>比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minDeletionSize = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> leng = A[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; leng; j++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123; <br>            <span class="hljs-keyword">let</span> prev = A[i].<span class="hljs-title function_">charCodeAt</span>(j);<br>            <span class="hljs-keyword">let</span> next = A[i+<span class="hljs-number">1</span>].<span class="hljs-title function_">charCodeAt</span>(j);<br>            <span class="hljs-keyword">if</span>(prev &gt; next) &#123;<br>                result++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-4"><a href="#答案二-4" class="headerlink" title="答案二"></a>答案二</h4><p>跟js解法是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDeletionSize</span><span class="hljs-params">(String[] A)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; c &lt; A[<span class="hljs-number">0</span>].length(); ++c)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; A.length - <span class="hljs-number">1</span>; ++r)<br>                <span class="hljs-keyword">if</span> (A[r].charAt(c) &gt; A[r+<span class="hljs-number">1</span>].charAt(c)) &#123;<br>                    ans++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="7-N叉树的最大深度"><a href="#7-N叉树的最大深度" class="headerlink" title="7.N叉树的最大深度"></a>7.N叉树的最大深度</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/"> N叉树的最大深度</a>:<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如,给定一个<code>3叉树</code> :<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png"></p><p>我们应返回最大深度,3.</p><p>说明:</p><ul><li>树的深度不会超过 1000。</li><li>树的节点总不会超过 5000。</li></ul><h4 id="答案一-6"><a href="#答案一-6" class="headerlink" title="答案一"></a>答案一</h4><p>因为java和JavaScript的解法一样这里我就算做一种.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">children</span> &amp;&amp; root.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = root.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i&lt; len; i++) &#123;<br>            max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">children</span>[i]), max)<br>        &#125;<br>        <span class="hljs-keyword">return</span> max + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDeepth</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; root.children.size(); i++) &#123;<br>            max = Math.max(maxDeepth(root.children.get(i)), max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-超过经理收入的员工"><a href="#8-超过经理收入的员工" class="headerlink" title="8. 超过经理收入的员工"></a>8. 超过经理收入的员工</h3><p><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">超过经理收入的员工</a>:<br>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>-------<span class="hljs-code">+--------+</span>-----------+<br><span class="hljs-section">| Id | Name  | Salary | ManagerId |</span><br><span class="hljs-section">+----+-------+--------+-----------+</span><br>| 1  | Joe   | 70000  | 3         |<br>| 2  | Henry | 80000  | 4         |<br>| 3  | Sam   | 60000  | NULL      |<br><span class="hljs-section">| 4  | Max   | 90000  | NULL      |</span><br><span class="hljs-section">+----+-------+--------+-----------+</span><br><br><br><span class="hljs-code">+----------+</span><br><span class="hljs-section">| Employee |</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">| Joe      |</span><br><span class="hljs-section">+----------+</span><br></code></pre></td></tr></table></figure><h4 id="答案一-7"><a href="#答案一-7" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>SELECT <br>    a.Name AS Employee<br>FROM Employee AS a,<br>     Employee AS b<br>WHERE <br>    a.ManagerId = b.Id<br>    AND a.Salary &gt; b.Salary<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>    a.Name AS Employee<br>FROM <br>    Employee AS a <br>JOIN <br>    Employee AS b<br>ON a.ManagerId = b.Id<br>    AND a.Salary &gt; b.Salary<br></code></pre></td></tr></table></figure><h3 id="9-最小差值-I"><a href="#9-最小差值-I" class="headerlink" title="9.最小差值 I"></a>9.最小差值 I</h3><p><a href="https://leetcode-cn.com/problems/smallest-range-i/">最小差值 I</a><br>给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K &lt;= x &lt;= K，并将 x 加到 A[i] 中。</p><p>在此过程之后，我们得到一些数组 B。</p><p>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。</p><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10000</li><li>0 &lt;= K &lt;= 10000</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br><br>输入：A = <span class="hljs-comment">[1]</span>, K = 0<br>输出：0<br>解释：B = <span class="hljs-comment">[1]</span><br><br>示例 2：<br><br>输入：A = <span class="hljs-comment">[0,10]</span>, K = 2<br>输出：6<br>解释：B = <span class="hljs-comment">[2,8]</span><br><br>示例 3：<br><br>输入：A = <span class="hljs-comment">[1,3,6]</span>, K = 3<br>输出：0<br>解释：B = <span class="hljs-comment">[3,3,3]</span> 或 B = <span class="hljs-comment">[4,4,4]</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-8"><a href="#答案一-8" class="headerlink" title="答案一"></a>答案一</h4><p>分析: 这道题目乍一看不容易理解, 其实是这样的我随机从-K到K之间取值保证数组A的最大和最小值的差值最小,也就是说取得最大的最小值和最小的最大值.<br>那么首先要进行排序从小到大进行排序,然后取出数组A的最小值和最大值,便利K进行求和,再找出其中差值的最小值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">K</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> smallestRangeI = <span class="hljs-keyword">function</span>(<span class="hljs-params">A, K</span>) &#123;    <br>    <span class="hljs-comment">// 从小到大排序</span><br>    A = A.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a - b));<br>    <span class="hljs-keyword">let</span> len = A.<span class="hljs-property">length</span>;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Af</span> = A[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Al</span> = A[len - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">let</span> M = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = -K; i &lt;= K; i++) &#123;<br>        M.<span class="hljs-title function_">push</span>([<br>            <span class="hljs-title class_">Af</span> + i,<br>            <span class="hljs-title class_">Al</span> + i<br>        ]);<br>        <br>    &#125;<br>    <span class="hljs-keyword">let</span> klen = K - (-K) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> delNum = M[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - M[klen-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> delNum &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : delNum;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>后来看了题解发现本题解的还是不够清晰,这里copy一下题解分析来得到答案二</p><h4 id="答案二-5"><a href="#答案二-5" class="headerlink" title="答案二"></a>答案二</h4><p>假设 A 是原始数组，B 是修改后的数组，我们需要最小化 max(B) - min(B)，也就是分别最小化 max(B) 和最大化 min(B)。</p><p>max(B) 最小可能为 max(A) - K，因为 max(A) 不可能再变得更小。同样，min(B) 最大可能为 min(A) + K。所以结果 max(B) - min(B) 至少为 ans = (max(A) - K) - (min(A) + K)。</p><p>我们可以用一下修改方式获得结果（如果 ans &gt;= 0）：</p><ul><li>如果 A[i]≤min(A)+K，那么 B[i]=min(A)+K</li><li>如果 A[i]≥max(A)−K，那么 B[i]=max(A)−K</li><li>否则 B[i]=A[i]。<br>如果 ans &lt; 0，最终结果会有 ans = 0，同样利用上面的修改方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestRangeI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">let</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> A[<span class="hljs-number">0</span>], max = A[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : A) &#123;<br>            min = Math.min(min, x);<br>            max = Math.max(max, x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">0</span>, max - min - <span class="hljs-number">2</span>*K);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-将有序数组转换为二叉搜索树未完成"><a href="#10-将有序数组转换为二叉搜索树未完成" class="headerlink" title="10.将有序数组转换为二叉搜索树未完成"></a>10.将有序数组转换为二叉搜索树<code>未完成</code></h3><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a>:<br>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">示例:<br><br>给定有序数组: [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9],<br><br>一个可能的答案是：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br><br>      0<br>     / \<br>   <span class="hljs-string">-3</span>   9<br>   /   /<br> <span class="hljs-string">-10</span>  5<br><br></code></pre></td></tr></table></figure><h4 id="答案一-9"><a href="#答案一-9" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> sortedArrayToBST(nums, <span class="hljs-number">0</span>, nums.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span>(start == end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = sortedArrayToBST(nums, start, mid);<br>        root.right = sortedArrayToBST(nums, mid + <span class="hljs-number">1</span>, end);<br><br>       <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结(简单版三)</title>
    <link href="/2019/09/05/2019-09-05-leetcode-three/"/>
    <url>/2019/09/05/2019-09-05-leetcode-three/</url>
    
    <content type="html"><![CDATA[<p>本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</p><h3 id="1-自除数"><a href="#1-自除数" class="headerlink" title="1.自除数"></a>1.自除数</h3><p><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">自除数</a>：<br>自除数 是指可以被它包含的每一位数除尽的数。<br>例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。<br>还有，自除数不允许包含 0 。<br>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p><p>注意：</p><ul><li>每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000。</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs coq">示例 <span class="hljs-number">1</span>：<br><br>输入： <br>上边界<span class="hljs-built_in">left</span> = <span class="hljs-number">1</span>, 下边界<span class="hljs-built_in">right</span> = <span class="hljs-number">22</span><br>输出： [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>]<br></code></pre></td></tr></table></figure><h4 id="答案一："><a href="#答案一：" class="headerlink" title="答案一："></a>答案一：</h4><p>分析： 关键点就是对数字进行拆分取整数和取余数,我自己的解法代码有点复杂冗余，下面是根据题解的优化方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">left</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">right</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> selfDividingNumbers = <span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = left; i &lt;= right; i++) &#123;<br>        <span class="hljs-keyword">let</span> n = i;<br>        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(n) &#123;<br>            <span class="hljs-keyword">if</span> (i % (n % <span class="hljs-number">10</span>) === <span class="hljs-number">0</span>) &#123;<br>                n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(n / <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            arr.<span class="hljs-title function_">push</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="2-二叉搜索树中的搜索"><a href="#2-二叉搜索树中的搜索" class="headerlink" title="2.二叉搜索树中的搜索"></a>2.二叉搜索树中的搜索</h3><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a>:<br>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。<br>例如，</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定二叉搜索树:<br><br>        4<br>       / \<br>     <span class="hljs-number"> 2 </span>  7<br>     / \<br>   <span class="hljs-number"> 1 </span>  3<br><br>和值: 2<br>你应该返回如下子树:<br><br>     <span class="hljs-number"> 2 </span>    <br>     / \   <br>   <span class="hljs-number"> 1 </span>  3<br>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。<br></code></pre></td></tr></table></figure><h4 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">val</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> searchBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) &#123;<br>    <span class="hljs-keyword">if</span>(root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span> &gt; val) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">left</span>, val);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span> === val) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">right</span>, val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(root.val == val) &#123;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; val) &#123;<br>                root = root.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案三"><a href="#答案三" class="headerlink" title="答案三"></a>答案三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按照逻辑递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-keyword">if</span>(root.val == val) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &lt; root.val) &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-N叉树的后序遍历"><a href="#3-N叉树的后序遍历" class="headerlink" title="3.N叉树的后序遍历"></a>3.N叉树的后序遍历</h3><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">N叉树的后序遍历</a>:给定一个 N 叉树，返回其节点值的后序遍历。</p><p>例如，给定一个 3叉树 :<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png"><br>返回其后序遍历: [5,6,3,2,4,1].</p><p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p><h4 id="答案一-1"><a href="#答案一-1" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一种方式：递归</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<br><br>    <span class="hljs-keyword">var</span> res = [];<br>    <span class="hljs-title function_">recusion</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">recusion</span>(<span class="hljs-params">root</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; root.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-title function_">recusion</span>(root.<span class="hljs-property">children</span>[i]);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="答案二-1"><a href="#答案二-1" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第二种方式：迭代</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> postorder2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<br>    <span class="hljs-keyword">var</span> res = [], arr = [root];<br>    <span class="hljs-keyword">while</span>(arr.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">var</span> current = arr.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; current.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            arr.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">children</span>[i]);<br>        &#125;<br>        res.<span class="hljs-title function_">unshift</span>(current.<span class="hljs-property">val</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="答案三-1"><a href="#答案三-1" class="headerlink" title="答案三"></a>答案三</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span>(Node cur: root.children) &#123;<br>            res.addAll(postorder(cur));<br>        &#125;<br>        res.add(root.val);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-N叉树的前序遍历"><a href="#4-N叉树的前序遍历" class="headerlink" title="4.N叉树的前序遍历"></a>4.N叉树的前序遍历</h3><p>例如，给定一个 3叉树 :<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png"><br>返回其前序遍历: [1,3,5,6,2,4]。<br>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p><h4 id="答案一-2"><a href="#答案一-2" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a Node.</span><br><span class="hljs-comment"> * function Node(val,children) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.children = children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<br>    <span class="hljs-keyword">var</span> res = [];<br>    <span class="hljs-title function_">recusion</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">recusion</span>(<span class="hljs-params">root</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; root.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-title function_">recusion</span>(root.<span class="hljs-property">children</span>[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-2"><a href="#答案二-2" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        res.add(root.val);<br>        <span class="hljs-keyword">for</span>(Node cur: root.children) &#123;<br>            res.addAll(preorder(cur));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案三-2"><a href="#答案三-2" class="headerlink" title="答案三"></a>答案三</h4><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    <br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            res.add(cur.val);<br><br>            List&lt;Node&gt; nodeList = cur.children;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nodeList.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                stack.push(nodeList.get(i));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Nim-游戏"><a href="#5-Nim-游戏" class="headerlink" title="5.Nim 游戏"></a>5.Nim 游戏</h3><p><a href="https://leetcode-cn.com/problems/nim-game/submissions/">Nim 游戏</a>:<br>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。<br>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">示例:</span><br><br><span class="hljs-section">输入: 4</span><br><span class="hljs-section">输出: false </span><br><span class="hljs-section">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br>     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。<br><br></code></pre></td></tr></table></figure><h4 id="答案一-3"><a href="#答案一-3" class="headerlink" title="答案一"></a>答案一</h4><p>分析:随机拿1-3块石头，这里的4是一个临界点，依次以，5，6，7，8举例计算，发现每次能被4整除时一定会返回false,其他返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canWinNim = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> ? <span class="hljs-attr">true</span>: <span class="hljs-literal">false</span>;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-山脉数组的峰顶索引"><a href="#6-山脉数组的峰顶索引" class="headerlink" title="6.山脉数组的峰顶索引"></a>6.山脉数组的峰顶索引</h3><p><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">山脉数组的峰顶索引</a>:<br>我们把符合下列属性的数组 A 称作山脉：</p><ul><li>A.length &gt;= 3</li><li>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</li></ul><p>给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</p><p>提示：</p><ul><li>3 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10^6</li><li>A 是如上定义的山脉</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-selector-attr">[0,1,0]</span><br>输出：<span class="hljs-number">1</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-selector-attr">[0,2,1,0]</span><br>输出：<span class="hljs-number">1</span><br> <br><br><br></code></pre></td></tr></table></figure><h4 id="答案一-4"><a href="#答案一-4" class="headerlink" title="答案一"></a>答案一</h4><p>分析：通过读题其实是返回数组中最大值的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> peakIndexInMountainArray = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">return</span> A.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val == <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...A));<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-3"><a href="#答案二-3" class="headerlink" title="答案二"></a>答案二</h4><p>后台的解题方法更多可以参考一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 打桩法，也叫单向扫描，代码如下：时间复杂度为O(n)，效率略低，但是此方法具有普适性，也就是说这个方法可适用于在一般数组中找最大值。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A,length &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; max) &#123;<br>                max = A[i];<br>                ans = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双指针，也叫双向扫描，左右两边同时向中间扫描，以找出最大值，这个算法其实是在打桩法之上的一个效率优化，</span><br><span class="hljs-comment">// 时间复杂度为O(n/2)---&gt;O(n)，效率较低，但比打桩法效率高，同时也具有普适性。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A,length &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> A.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span>(left &lt;= right &amp;&amp; A[left] &gt; max) &#123;<br>                max = A[left];<br>                ans = left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt;= right &amp;&amp; A[right] &gt; max) &#123;<br>                max = A[right];<br>                ans = right;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 分治法，二分查找，是适用于此题的最佳解法，时间复杂度为O(logn)，优点是效率高，缺点是不具有普适性。因为此题数组特殊，所以可用这种方法提高查找效率。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>         <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span> || A.length &lt; <span class="hljs-number">3</span>)  &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> A.length;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(A[center] &gt; A[center - <span class="hljs-number">1</span>] &amp;&amp; A[center] &gt; A[center + <span class="hljs-number">1</span>]) &#123;<br>                ans = center;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[center] &lt; A[center - <span class="hljs-number">1</span>]) &#123;<br>                right = center;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = center;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-除数博弈"><a href="#7-除数博弈" class="headerlink" title="7.除数博弈"></a>7.除数博弈</h3><p><a href="https://leetcode-cn.com/problems/divisor-game/">除数博弈</a>:<br>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。<br>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p><ul><li>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。</li><li>用 N - x 替换黑板上的数字 N 。</li></ul><p>如果玩家无法执行这些操作，就会输掉游戏。<br>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p><p>提示： 1 &lt;= N &lt;= 1000</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-number">2</span><br>输出：<span class="hljs-literal">true</span><br>解释：爱丽丝选择 <span class="hljs-number">1</span>，鲍勃无法进行操作。<br><br><br>示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-number">3</span><br>输出：<span class="hljs-literal">false</span><br>解释：爱丽丝选择 <span class="hljs-number">1</span>，鲍勃也选择 <span class="hljs-number">1</span>，然后爱丽丝无法进行操作。<br><br></code></pre></td></tr></table></figure><h4 id="答案一-5"><a href="#答案一-5" class="headerlink" title="答案一"></a>答案一</h4><p>分析：自己按照题解给出的答案。但是有更简单的解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">N</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> divisorGame = <span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) &#123;    <br>    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">finx</span>(N);<br>    <span class="hljs-keyword">let</span> oN = N;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x) &#123;<br>        oN = oN - x;<br>        x = <span class="hljs-title function_">finx</span>(oN);<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count&amp;<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">finx</span>(<span class="hljs-params">num</span>)&#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; num; i++) &#123;<br>            <span class="hljs-keyword">if</span>(num % i === <span class="hljs-number">0</span>) &#123;<br>                x = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>        <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-4"><a href="#答案二-4" class="headerlink" title="答案二"></a>答案二</h4><p>对于这种博弈类的题目，如果没有思路的话我们不妨多举几个例子，尝试着从中找寻规律。</p><ul><li>假设 N = 1，爱丽丝没得选择，直接失败，即 鲍勃获胜；</li><li>假设 N = 2，爱丽丝有选择，她可以选择 x = 1，鲍勃面对的就是 N = 2 - 1 = 1，无法操作，爱丽丝获胜；</li><li>假设 N = 3，爱丽丝只能选择 x = 1，因为选 x = 2 不满足 3 % 2 = 0，鲍勃面对的就是 N = 3 - 1 = 2，参考上面 N = 2 的情形，此时鲍勃为 N = 2 的先手，鲍勃获胜；</li><li>假设 N = 4，爱丽丝可以选择 x = 1 来使鲍勃遇到 N = 3 的情况，爱丽丝获胜；<br>貌似有个规律：N 为奇数时， 鲍勃获胜；N 为偶数时， 爱丽丝获胜。</li></ul><p>是这样吗？是的。</p><p>事实上，无论 N 为多大，最终都是在 N = 2 这个临界点结束的。谁最后面对的是 N = 2 的情形，谁就能获胜（这句话不太理解的话，仔细看看 N = 2、N = 3 这两种情形）。<br>接下来，我们得知道一个数学小知识：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。<br>千万不要忽略 1 也是因子！</p><p>爱丽丝是游戏开始时的先手。</p><p>当她面对的 N 为偶数时，她 一定可以 选到一个 N 的奇数因子 x（比如 1 ），将 N - x 这个奇数传给鲍勃；用 N - x 替换黑板上的数字 N ，鲍勃面对的就是奇数 N，只能选择 N 的奇数因子 x，奇数 - 奇数 = 偶数，此时传给爱丽丝的又是偶数。这样轮换下去爱丽丝会遇到 N = 2 的情形，然后获胜；<br>当爱丽丝遇到的 N 是奇数时，只能传给鲍勃偶数或无法操作 (N = 1) ，无法获胜。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">divisorGame</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-最近的请求次数-代码比题目易懂"><a href="#8-最近的请求次数-代码比题目易懂" class="headerlink" title="8.最近的请求次数(代码比题目易懂)"></a>8.最近的请求次数(代码比题目易懂)</h3><p><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">最近的请求次数</a>:<br>写一个 <code>RecentCounter</code> 类来计算最近的请求。<br>它只有一个方法：<code>ping(int t)</code>，其中 t 代表以毫秒为单位的某个时间。<br>返回从 <code>3000</code> 毫秒前到现在的 <code>ping</code> 数。<br>任何处于 <code>[t - 3000, t]</code> 时间范围之内的 <code>ping</code> 都将会被计算在内，包括当前（指 t 时刻）的 <code>ping</code>。<br>保证每次对 <code>ping</code> 的调用都使用比之前更大的 t 值。</p><p>提示：</p><ul><li>每个测试用例最多调用 10000 次 ping。</li><li>每个测试用例会使用严格递增的 t 值来调用 ping。</li><li>每次调用 ping 都有 1 &lt;= t &lt;= 10^9。</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">示例：<br><br>输入：inputs = [<span class="hljs-string">&quot;RecentCounter&quot;</span>,<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-string">&quot;ping&quot;</span>], inputs = [[],[<span class="hljs-number">1</span>],[<span class="hljs-number">100</span>],[<span class="hljs-number">3001</span>],[<span class="hljs-number">3002</span>]]<br>输出：[null,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br><br></code></pre></td></tr></table></figure><p> </p><h4 id="答案一-6"><a href="#答案一-6" class="headerlink" title="答案一"></a>答案一</h4><p>分析：说实话这道题目不容易理解，配上示例也完全不知道在说啥，先看一下题解进行一下分析，题目其实是这样的<br>示例解读：分别在1,100,3001,3002ms发出了请求（ping）</p><p>1ms时计算1ms以及1ms之前3000ms的请求数为‘1’(1ms时的ping)</p><p>100ms时计算100ms以及100ms之前3000s的请求数为‘2’（1ms时的ping和100ms时的ping）</p><p>3001ms时计算3001ms以及3001ms之前3000s的请求数为‘3’(1ms时的ping、100ms时的ping和3001ms时的ping)</p><p>3002ms时计算3002ms以及3002ms之前3000s的请求数为‘3’(100ms时的ping、3001ms时的ping和3002ms时的ping)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">RecentCounter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = [];<br>&#125;;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">t</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">RecentCounter</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">ping</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>.<span class="hljs-title function_">push</span>(t);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>[<span class="hljs-number">0</span>] &lt; (t - <span class="hljs-number">3000</span>)) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>.<span class="hljs-title function_">shift</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>.<span class="hljs-property">length</span>;<br>&#125;;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Your RecentCounter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new RecentCounter()</span><br><span class="hljs-comment"> * var param_1 = obj.ping(t)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="答案二-5"><a href="#答案二-5" class="headerlink" title="答案二"></a>答案二</h4><p>官方题解：我们只会考虑最近 3000 毫秒到现在的 ping 数，因此我们可以使用队列存储这些 ping 的记录。当收到一个时间 t 的 ping 时，我们将它加入队列，并且将所有在时间 t - 3000 之前的 ping 移出队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecentCounter</span> &#123;<br>    Queue&lt;Integer&gt; q;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecentCounter</span><span class="hljs-params">()</span> &#123;<br>        q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ping</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> &#123;<br>        q.add(t);<br>        <span class="hljs-keyword">while</span>(q.peek() &lt; t - <span class="hljs-number">3000</span>) &#123;<br>            q.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-数字的补数"><a href="#9-数字的补数" class="headerlink" title="9.数字的补数"></a>9.数字的补数</h3><p><a href="https://leetcode-cn.com/problems/number-complement/">数字的补数</a>:<br>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p><p>注意:</p><ul><li>给定的整数保证在32位带符号整数的范围内。</li><li>你可以假定二进制数不包含前导零位。</li></ul><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</span><br><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-7"><a href="#答案一-7" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">num</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findComplement = <span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">let</span> b = num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-property">length</span>; i++) &#123;<br>      res += (<span class="hljs-title class_">Number</span>(b.<span class="hljs-title function_">charAt</span>(i))^<span class="hljs-number">1</span> + <span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(res, <span class="hljs-number">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-按奇偶排序数组"><a href="#10-按奇偶排序数组" class="headerlink" title="10.按奇偶排序数组"></a>10.按奇偶排序数组</h3><p><a href="https://leetcode-cn.com/problems/sort-array-by-parity/submissions/">按奇偶排序数组</a>:<br>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。<br>你可以返回满足此条件的任何数组作为答案。</p><p>提示：</p><ul><li><code>1 <= A.length <= 5000</code></li><li><code>0 <= A[i] <= 5000</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">示例：<br><br>输入：<span class="hljs-selector-attr">[3,1,2,4]</span><br>输出：<span class="hljs-selector-attr">[2,4,3,1]</span><br>输出 <span class="hljs-selector-attr">[4,2,3,1]</span>，<span class="hljs-selector-attr">[2,4,1,3]</span> 和 <span class="hljs-selector-attr">[4,2,1,3]</span> 也会被接受。<br></code></pre></td></tr></table></figure><h4 id="答案一-8"><a href="#答案一-8" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortArrayByParity = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>  <br>  <span class="hljs-keyword">return</span> A.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).<span class="hljs-title function_">concat</span>(A.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>))<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-6"><a href="#答案二-6" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArrayByParity(<span class="hljs-type">int</span>[] A) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = A.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : A) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                res[min++] = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[max--] = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结(简单版二)</title>
    <link href="/2019/09/04/2019-09-04-leetcode-two/"/>
    <url>/2019/09/04/2019-09-04-leetcode-two/</url>
    
    <content type="html"><![CDATA[<p>本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</p><h3 id="1-有趣的电影"><a href="#1-有趣的电影" class="headerlink" title="1.有趣的电影"></a>1.有趣的电影</h3><p><a href="https://leetcode-cn.com/problems/not-boring-movies/">有趣的电影</a>：<br>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。<br>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs gherkin">例如，下表 cinema:<br><br>+---------+-----------+--------------+-----------+<br>|<span class="hljs-string">   id    </span>|<span class="hljs-string"> movie     </span>|<span class="hljs-string">  description </span>|<span class="hljs-string">  rating   </span>|<br>+---------+-----------+--------------+-----------+<br>|<span class="hljs-string">   1     </span>|<span class="hljs-string"> War       </span>|<span class="hljs-string">   great 3D   </span>|<span class="hljs-string">   8.9     </span>|<br>|<span class="hljs-string">   2     </span>|<span class="hljs-string"> Science   </span>|<span class="hljs-string">   fiction    </span>|<span class="hljs-string">   8.5     </span>|<br>|<span class="hljs-string">   3     </span>|<span class="hljs-string"> irish     </span>|<span class="hljs-string">   boring     </span>|<span class="hljs-string">   6.2     </span>|<br>|<span class="hljs-string">   4     </span>|<span class="hljs-string"> Ice song  </span>|<span class="hljs-string">   Fantacy    </span>|<span class="hljs-string">   8.6     </span>|<br>|<span class="hljs-string">   5     </span>|<span class="hljs-string"> House card</span>|<span class="hljs-string">   Interesting</span>|<span class="hljs-string">   9.1     </span>|<br>+---------+-----------+--------------+-----------+<br>对于上面的例子，则正确的输出是为：<br><br>+---------+-----------+--------------+-----------+<br>|<span class="hljs-string">   id    </span>|<span class="hljs-string"> movie     </span>|<span class="hljs-string">  description </span>|<span class="hljs-string">  rating   </span>|<br>+---------+-----------+--------------+-----------+<br>|<span class="hljs-string">   5     </span>|<span class="hljs-string"> House card</span>|<span class="hljs-string">   Interesting</span>|<span class="hljs-string">   9.1     </span>|<br>|<span class="hljs-string">   1     </span>|<span class="hljs-string"> War       </span>|<span class="hljs-string">   great 3D   </span>|<span class="hljs-string">   8.9     </span>|<br>+---------+-----------+--------------+-----------+<br><br></code></pre></td></tr></table></figure><h4 id="答案一："><a href="#答案一：" class="headerlink" title="答案一："></a>答案一：</h4><p>我们可以使用 mod(id,2)=1 来确定奇数 id，然后添加 description != ‘boring’ 来解决问题。<br>官方题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * <br>from cinema<br>where mod(id,2) != 0 and description != &#x27;boring&#x27;<br>order by rating desc<br>;<br></code></pre></td></tr></table></figure><h4 id="答案二："><a href="#答案二：" class="headerlink" title="答案二："></a>答案二：</h4><p>如何确定奇数除了使用mod函数还有一个比较巧妙的方法， id&amp;1按位与,该操作会将数字转为32位的二进制进行比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//id=1</span><br><span class="hljs-number">0001</span><br><span class="hljs-number">0001</span><br><br><span class="hljs-number">0001</span> 结果为<span class="hljs-number">1</span><br><br><span class="hljs-comment">//id=2</span><br><span class="hljs-number">0010</span><br><span class="hljs-number">0001</span> <br><br><span class="hljs-number">0000</span> 结果为<span class="hljs-number">0</span><br><br><span class="hljs-comment">//id=3</span><br><span class="hljs-number">0011</span><br><span class="hljs-number">0001</span><br><br><span class="hljs-number">0001</span> 结果为<span class="hljs-number">1</span><br><br><span class="hljs-comment">//id=4</span><br><span class="hljs-number">0010</span><br><span class="hljs-number">0001</span><br><br><span class="hljs-number">0000</span> 结果为<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>因为1的前31位都是0，跟0进行与操作肯定是0，主要在于最后一位如果是奇数肯定能得到1，如果是0肯定是0<br>所以答案也可以写成这样</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <br><span class="hljs-keyword">from</span> cinema <br><span class="hljs-keyword">where</span> description&lt;&gt;<span class="hljs-string">&#x27;boring&#x27;</span> and id&amp;<span class="hljs-number">1</span> <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">desc</span><br>;<br></code></pre></td></tr></table></figure><h3 id="2-汉明距离"><a href="#2-汉明距离" class="headerlink" title="2.汉明距离"></a>2.汉明距离</h3><p><a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a>:<br>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。<br>给出两个整数 x 和 y，计算它们之间的汉明距离。<br>注意：<br>0 ≤ x, y &lt; 231.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">示例:</span><br><br><span class="hljs-section">输入: x = 1, y = 4</span><br><br><span class="hljs-section">输出: 2</span><br><br><span class="hljs-section">解释:</span><br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑<br><br>上面的箭头指出了对应二进制位不同的位置。<br></code></pre></td></tr></table></figure><h4 id="答案一：-1"><a href="#答案一：-1" class="headerlink" title="答案一："></a>答案一：</h4><p>分析其实本题的意图就是将x，y转为二进制后，记录对应位置值不相同的位置数量， 所以我们就想到了按位异或。x^y后得到一个数值，需要将这个值转为二进制再去统计数量。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; y</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hammingDistance = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> z = x^y;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> bin = z.toString(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bin.length; i++) &#123;<br>      <span class="hljs-keyword">if</span>(bin.charAt(i) === <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>          num++;<br>      &#125;<br>  &#125;<br>    <br>    <span class="hljs-keyword">return</span> num;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="3-翻转二叉树"><a href="#3-翻转二叉树" class="headerlink" title="3.翻转二叉树"></a>3.翻转二叉树</h3><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a>:<br>翻转一棵二叉树。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs livescript">示例：<br><br>输入：<br><br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br>输出：<br><br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> invertTree(root.right);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>        <br>        root.left = right;<br>        root.right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(root !== <span class="hljs-literal">null</span>) &#123;<br>        [root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>] = [<span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>), <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>)]<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="4-机器人能否返回原点"><a href="#4-机器人能否返回原点" class="headerlink" title="4.机器人能否返回原点"></a>4.机器人能否返回原点</h3><p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">机器人能否返回原点</a>：<br>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。<br>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">示例 <span class="hljs-number">1</span>:<br><br>输入: <span class="hljs-string">&quot;UD&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 <span class="hljs-literal">true</span>。<br>示例 <span class="hljs-number">2</span>:<br><br>输入: <span class="hljs-string">&quot;LL&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 <span class="hljs-literal">false</span>，因为它在移动结束时没有返回原点。<br></code></pre></td></tr></table></figure><h4 id="答案一-1"><a href="#答案一-1" class="headerlink" title="答案一"></a>答案一</h4><p>分析：是否回到原点，取决于上下移动的步数相等，左右移动的步数相等。<br>所以最简单的方法就是去计数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">moves</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> judgeCircle = <span class="hljs-keyword">function</span>(<span class="hljs-params">moves</span>) &#123;<br>     <span class="hljs-keyword">let</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> movesArr = moves.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <br>        movesArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) &#123;<br>            <span class="hljs-keyword">if</span>(val === <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>                u++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(val === <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>                d++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(val === <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(val === <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                r++;<br>            &#125;<br>            <br>        &#125;);<br>        <span class="hljs-keyword">return</span> u === d &amp;&amp; r === l;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-1"><a href="#答案二-1" class="headerlink" title="答案二"></a>答案二</h4><p>比第一个方法要巧妙一些，不去计数了但是还是要判断步数相等，通过切割关键点来得到数组，如果关键点数量一样数组的长度相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">moves</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> judgeCircle = <span class="hljs-keyword">function</span>(<span class="hljs-params">moves</span>) &#123;<br>  <span class="hljs-keyword">return</span> moves.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;L&#x27;</span>).<span class="hljs-property">length</span> === moves.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;R&#x27;</span>).<span class="hljs-property">length</span> &amp;&amp; moves.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;U&#x27;</span>).<span class="hljs-property">length</span> === moves.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;D&#x27;</span>).<span class="hljs-property">length</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-高度检查器"><a href="#5-高度检查器" class="headerlink" title="5.高度检查器"></a>5.高度检查器</h3><p><a href="https://leetcode-cn.com/problems/height-checker/">高度检查器</a>:<br>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。<br>请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。</p><p>提示：</p><ul><li>1 &lt;= heights.length &lt;= 100</li><li>1 &lt;= heights[i] &lt;= 100</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">示例：<br><br>输入：<span class="hljs-string">[1,1,4,2,1,3]</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>高度为 <span class="hljs-number">4</span>、<span class="hljs-number">3</span> 和最后一个 <span class="hljs-number">1</span> 的学生，没有站在正确的位置。<br></code></pre></td></tr></table></figure><h4 id="答案一-2"><a href="#答案一-2" class="headerlink" title="答案一"></a>答案一</h4><p>分析：将数组重新排序后得到新的数组去判断同一个位置的值是否相等，不想等计数+1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">heights</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> heightChecker = <span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) &#123;    <br>    <span class="hljs-keyword">var</span> temp = heights.<span class="hljs-title function_">concat</span>().<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a - b) );<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(heights[i] != temp[i]) &#123;<br>            count++;   <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6.二叉树的最大深度"></a>6.二叉树的最大深度</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>:<br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">示例：<br>给定二叉树 [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]，<br><br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>返回它的最大深度 <span class="hljs-number">3</span> 。<br><br></code></pre></td></tr></table></figure><h4 id="答案一-3"><a href="#答案一-3" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-keyword">let</span> right = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-交换工资"><a href="#7-交换工资" class="headerlink" title="7.交换工资"></a>7.交换工资</h3><p><a href="https://leetcode-cn.com/problems/swap-salary/">交换工资</a><br>给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。<br>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br><br>例如：<br><br>|<span class="hljs-string"> id </span>|<span class="hljs-string"> name </span>|<span class="hljs-string"> sex </span>|<span class="hljs-string"> salary </span>|<br>|<span class="hljs-string">----</span>|<span class="hljs-string">------</span>|<span class="hljs-string">-----</span>|<span class="hljs-string">--------</span>|<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> A    </span>|<span class="hljs-string"> m   </span>|<span class="hljs-string"> 2500   </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> B    </span>|<span class="hljs-string"> f   </span>|<span class="hljs-string"> 1500   </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> C    </span>|<span class="hljs-string"> m   </span>|<span class="hljs-string"> 5500   </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> D    </span>|<span class="hljs-string"> f   </span>|<span class="hljs-string"> 500    </span>|<br>运行你所编写的更新语句之后，将会得到以下表:<br><br>|<span class="hljs-string"> id </span>|<span class="hljs-string"> name </span>|<span class="hljs-string"> sex </span>|<span class="hljs-string"> salary </span>|<br>|<span class="hljs-string">----</span>|<span class="hljs-string">------</span>|<span class="hljs-string">-----</span>|<span class="hljs-string">--------</span>|<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> A    </span>|<span class="hljs-string"> f   </span>|<span class="hljs-string"> 2500   </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> B    </span>|<span class="hljs-string"> m   </span>|<span class="hljs-string"> 1500   </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> C    </span>|<span class="hljs-string"> f   </span>|<span class="hljs-string"> 5500   </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> D    </span>|<span class="hljs-string"> m   </span>|<span class="hljs-string"> 500    </span>|<br><br></code></pre></td></tr></table></figure><h4 id="答案一-4"><a href="#答案一-4" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE salary <br>SET sex = CASE sex<br>        WHEN &#x27;m&#x27; THEN &#x27;f&#x27;<br>        ELSE &#x27;m&#x27;<br>    END;<br><br></code></pre></td></tr></table></figure><h3 id="8-有序数组的平方"><a href="#8-有序数组的平方" class="headerlink" title="8.有序数组的平方"></a>8.有序数组的平方</h3><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">有序数组的平方</a>:<br>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>-10000 &lt;= A[i] &lt;= 10000</li><li>A 已按非递减顺序排序。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-selector-attr">[-4,-1,0,3,10]</span><br>输出：<span class="hljs-selector-attr">[0,1,9,16,100]</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-selector-attr">[-7,-3,2,3,11]</span><br>输出：<span class="hljs-selector-attr">[4,9,9,49,121]</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-5"><a href="#答案一-5" class="headerlink" title="答案一"></a>答案一</h4><p>分析：因为是从小打大，其中可以包含负数，所以取平方后两头应该最大。之所以使用<code>unshift</code>是因为双向指针来获取，拿到的一开始的值肯定是最大的后面越来越小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedSquares = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> j = count -<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>        <span class="hljs-keyword">let</span> left = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(A[i], <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">let</span> right = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(A[j], <span class="hljs-number">2</span>);<br>        <br>        <span class="hljs-keyword">if</span>(left &gt; right) &#123;<br>            result.<span class="hljs-title function_">unshift</span>(left);<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">unshift</span>(right);<br>            j--;<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>    <br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="9-增减字符串匹配"><a href="#9-增减字符串匹配" class="headerlink" title="9.增减字符串匹配"></a>9.增减字符串匹配</h3><p><a href="https://leetcode-cn.com/problems/di-string-match/">增减字符串匹配</a>:<br>给定只含 “I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。<br>返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有：<br>如果 S[i] == “I”，那么 A[i] &lt; A[i+1]<br>如果 S[i] == “D”，那么 A[i] &gt; A[i+1]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">示例 <span class="hljs-number">1</span>：<br><br>输出：<span class="hljs-string">&quot;IDID&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>示例 <span class="hljs-number">2</span>：<br><br>输出：<span class="hljs-string">&quot;III&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>示例 <span class="hljs-number">3</span>：<br><br>输出：<span class="hljs-string">&quot;DDI&quot;</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><h4 id="答案一-6"><a href="#答案一-6" class="headerlink" title="答案一"></a>答案一</h4><p>分析：根据结果的分析是所有的I从0开始依次递增，所有D从N开始依次递减</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">S</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> diStringMatch = <span class="hljs-keyword">function</span>(<span class="hljs-params">S</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = S.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> imin = <span class="hljs-number">0</span>, dmax = len;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(S.<span class="hljs-title function_">charAt</span>(i) === <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>            result[i] = imin;<br>            imin++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[i] = dmax;<br>            dmax--;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-2"><a href="#答案二-2" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">分析：乍一看这个一行的解法不是特别明白，但是分析示例答案可以看出无论给出的字符串是什么样的最后都可以补充一位，可以补I也可以补D,对于结果是没有影响的<br>所以先不补位置。然后逢I加一 逢D减一。<br><span class="hljs-keyword">var</span> diStringMatch = <span class="hljs-keyword">function</span>(<span class="hljs-params">S</span>) &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>,b = S.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">return</span> (S+S[S.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x==<span class="hljs-string">&#x27;I&#x27;</span>?a++:b--)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-组合两个表"><a href="#10-组合两个表" class="headerlink" title="10.组合两个表"></a>10.组合两个表</h3><p><a href="https://leetcode-cn.com/problems/combine-two-tables/">组合两个表</a></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">表1: Person<br><br><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| 列名         | 类型     |</span><br><span class="hljs-section">+-------------+---------+</span><br>| PersonId    | int     |<br>| FirstName   | varchar |<br><span class="hljs-section">| LastName    | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br>PersonId 是上表主键<br><br><br>表2: Address<br><br><span class="hljs-code">+-------------+</span>---------+<br><span class="hljs-section">| 列名         | 类型    |</span><br><span class="hljs-section">+-------------+---------+</span><br>| AddressId   | int     |<br>| PersonId    | int     |<br>| City        | varchar |<br><span class="hljs-section">| State       | varchar |</span><br><span class="hljs-section">+-------------+---------+</span><br>AddressId 是上表主键<br><br><br>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：<br>FirstName, LastName, City, State<br></code></pre></td></tr></table></figure><h4 id="答案一-7"><a href="#答案一-7" class="headerlink" title="答案一"></a>答案一</h4><p>因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。<br>考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> FirstName, LastName, City, State<br><span class="hljs-keyword">from</span> Person <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Address<br><span class="hljs-keyword">on</span> Person.PersonId = Address.PersonId<br>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题总结(简单版一)</title>
    <link href="/2019/09/03/2019-09-03-leetcode-one/"/>
    <url>/2019/09/03/2019-09-03-leetcode-one/</url>
    
    <content type="html"><![CDATA[<p>本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</p><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a>：<br>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>你可以按任意顺序返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">示例1:<br>输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br><br>示例2:<br>输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br><br>示例3:<br>输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h4 id="答案一："><a href="#答案一：" class="headerlink" title="答案一："></a>答案一：</h4><p>我的方法:for循环获取减法并且判断数组是否存在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> arrayIndex = []<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;= nums.<span class="hljs-property">length</span>;i++) &#123;<br>        <span class="hljs-keyword">let</span> newData = target -  nums[i];<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-title function_">indexOf</span>(target -  nums[i]) &gt; -<span class="hljs-number">1</span> &amp;&amp; nums.<span class="hljs-title function_">lastIndexOf</span>(newData) !== i) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nums.<span class="hljs-title function_">lastIndexOf</span>(newData))<br>            arrayIndex = [i,nums.<span class="hljs-title function_">lastIndexOf</span>(newData)]<br>            <span class="hljs-keyword">return</span> arrayIndex<br>        &#125;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2.整数反转"></a>2.整数反转</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a>：<br>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs llvm">示例<span class="hljs-number">1</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br>输出：<span class="hljs-number">321</span><br><br>示例<span class="hljs-number">2</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">-123</span><br>输出：<span class="hljs-number">-321</span><br><br>示例<span class="hljs-number">3</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">120</span><br>输出：<span class="hljs-number">21</span><br><br>示例<span class="hljs-number">4</span>:<br>输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h4><p>我的方法：转换成字符串然后声生成数组，reverse，然后正则去掉’,’；比较繁琐与麻烦<br>Math.pow():用来写次方的方法 2的31次方===Math.pow(2,31)</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param &#123;number&#125; x</span><br><span class="hljs-comment"> * @return &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">reverse</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    let newX;<br>    let flag = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(x) &gt;= <span class="hljs-number">0</span>) &#123;<br>        newX = x.toString().<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-built_in">reverse</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        flag = <span class="hljs-number">-1</span><br>        newX = Math.<span class="hljs-built_in">abs</span>(x).toString().<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-built_in">reverse</span>()  <br>    &#125;<br>    let newNumber = <span class="hljs-built_in">Number</span>(newX.toString().<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/,/g</span>,<span class="hljs-string">&#x27;&#x27;</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">-2</span>,<span class="hljs-number">31</span>)) &lt;= newNumber &amp;&amp;  newNumber &lt;=<span class="hljs-built_in">Number</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>))) &#123;<br>        <span class="hljs-keyword">return</span> flag*newNumber<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h3><p>这个答案相当简洁，运用了Math的用法，以及字符串简单转换</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">Math.<span class="hljs-keyword">sign</span>():获取传入的值判断是正负，正值是<span class="hljs-number">1</span>，负值是-<span class="hljs-number">1</span>；<br>Math.<span class="hljs-built_in">abs</span>():将数字取绝对值<br>var <span class="hljs-built_in">reverse</span> = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">x</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">sign</span> = Math.<span class="hljs-keyword">sign</span>(<span class="hljs-keyword">x</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">res</span> = (Math.<span class="hljs-built_in">abs</span>(<span class="hljs-keyword">x</span>) + <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) * <span class="hljs-keyword">sign</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">res</span> &gt; Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span> || <span class="hljs-keyword">res</span> &lt; Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) * -<span class="hljs-number">1</span>) <span class="hljs-keyword">res</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-删除链表中的节点"><a href="#3-删除链表中的节点" class="headerlink" title="3.删除链表中的节点"></a>3.删除链表中的节点</h3><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">删除链表中的节点</a>:<br>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<br>现有一个链表 – head = [4,5,1,9]，它可以表示为:<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/237_example.png"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">示例<span class="hljs-number">1</span><br>输入: head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 5</span><br>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]<br>解释: 给定你链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9</span>.<br><br>示例<span class="hljs-number">2</span><br>输入: head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 1</span><br>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]<br>解释: 给定你链表中值为 <span class="hljs-number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">9</span>.<br><br></code></pre></td></tr></table></figure><p>说明:</p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><h4 id="答案一-1"><a href="#答案一-1" class="headerlink" title="答案一"></a>答案一</h4><p>分析：说实话这道题目对于前端的同学来说其实很难理解。但是对于后台同学这个就太简单了，首先要理解<a href="https://blog.csdn.net/jianyuerensheng/article/details/51200274">单向链表的概念</a>。对于本题只需要将删除后的节点指向新节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode node)</span> &#123;<br>    node.val = node.next.val;<br>    node.next = node.next.next;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案二-1"><a href="#答案二-1" class="headerlink" title="答案二"></a>答案二</h4><p>对于使用javascript的版本需要首先定义一个单向链表</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xquery">/**<br> * Definition <span class="hljs-keyword">for</span> singly-linked list.<br> * <span class="hljs-keyword">function</span> ListNode(val) &#123;<br> *     this.val = val;<br> *     this.<span class="hljs-keyword">next</span> = null;<br> * &#125;<br> */<br>/**<br> * @param &#123;ListNode&#125; <span class="hljs-type">node</span><br> * @<span class="hljs-keyword">return</span> &#123;void&#125; Do<span class="hljs-built_in"> not</span> <span class="hljs-keyword">return</span> anything, <span class="hljs-keyword">modify</span> <span class="hljs-type">node</span> in-place instead.<br> */<br>var deleteNode = <span class="hljs-keyword">function</span>(<span class="hljs-type">node</span>) &#123;<br>  <span class="hljs-type">node</span>.val = <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>.val;<br>  <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>&#125;;<br><br>var deleteNode = <span class="hljs-keyword">function</span>(<span class="hljs-type">node</span>) &#123;<br>  <span class="hljs-type">node</span> = Object.assign(<span class="hljs-type">node</span>, <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>)<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="4-查找重复的电子邮箱"><a href="#4-查找重复的电子邮箱" class="headerlink" title="4.查找重复的电子邮箱"></a>4.查找重复的电子邮箱</h3><p><a href="https://leetcode-cn.com/problems/duplicate-emails/">查找重复的电子邮箱</a>: 编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">示例：</span><br><span class="hljs-section">+----+---------+</span><br><span class="hljs-section">| Id | Email   |</span><br><span class="hljs-section">+----+---------+</span><br>| 1  | a@b.com |<br>| 2  | c@d.com |<br><span class="hljs-section">| 3  | a@b.com |</span><br><span class="hljs-section">+----+---------+</span><br><br><span class="hljs-section">返回结果：</span><br><span class="hljs-section">+---------+</span><br><span class="hljs-section">| Email   |</span><br><span class="hljs-section">+---------+</span><br><span class="hljs-section">| a@b.com |</span><br><span class="hljs-section">+---------+</span><br></code></pre></td></tr></table></figure><h4 id="答案一-2"><a href="#答案一-2" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> Email<br><span class="hljs-keyword">from</span> Person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Email<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(Email) &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="答案二-2"><a href="#答案二-2" class="headerlink" title="答案二"></a>答案二</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> Email <span class="hljs-keyword">from</span><br>(<br>    <span class="hljs-keyword">select</span> Email, <span class="hljs-keyword">count</span>(Email) <span class="hljs-keyword">as</span> num<br>    <span class="hljs-keyword">from</span> Person<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Email<br>) <span class="hljs-keyword">as</span> statistic<br><span class="hljs-keyword">where</span> num &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="5-大的国家"><a href="#5-大的国家" class="headerlink" title="5.大的国家"></a>5.大的国家</h3><p><a href="https://leetcode-cn.com/problems/big-countries/">大的国家</a>:这里有张 World 表</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-----------------+------------+------------+--------------+---------------+<br>|<span class="hljs-string"> name            </span>|<span class="hljs-string"> continent  </span>|<span class="hljs-string"> area       </span>|<span class="hljs-string"> population   </span>|<span class="hljs-string"> gdp           </span>|<br>+-----------------+------------+------------+--------------+---------------+<br>|<span class="hljs-string"> Afghanistan     </span>|<span class="hljs-string"> Asia       </span>|<span class="hljs-string"> 652230     </span>|<span class="hljs-string"> 25500100     </span>|<span class="hljs-string"> 20343000      </span>|<br>|<span class="hljs-string"> Albania         </span>|<span class="hljs-string"> Europe     </span>|<span class="hljs-string"> 28748      </span>|<span class="hljs-string"> 2831741      </span>|<span class="hljs-string"> 12960000      </span>|<br>|<span class="hljs-string"> Algeria         </span>|<span class="hljs-string"> Africa     </span>|<span class="hljs-string"> 2381741    </span>|<span class="hljs-string"> 37100000     </span>|<span class="hljs-string"> 188681000     </span>|<br>|<span class="hljs-string"> Andorra         </span>|<span class="hljs-string"> Europe     </span>|<span class="hljs-string"> 468        </span>|<span class="hljs-string"> 78115        </span>|<span class="hljs-string"> 3712000       </span>|<br>|<span class="hljs-string"> Angola          </span>|<span class="hljs-string"> Africa     </span>|<span class="hljs-string"> 1246700    </span>|<span class="hljs-string"> 20609294     </span>|<span class="hljs-string"> 100990000     </span>|<br>+-----------------+------------+------------+--------------+---------------+<br></code></pre></td></tr></table></figure><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------------+</span>-------------<span class="hljs-code">+--------------+</span><br><span class="hljs-section">| name         | population  | area         |</span><br><span class="hljs-section">+--------------+-------------+--------------+</span><br>| Afghanistan  | 25500100    | 652230       |<br><span class="hljs-section">| Algeria      | 37100000    | 2381741      |</span><br><span class="hljs-section">+--------------+-------------+--------------+</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-3"><a href="#答案一-3" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name, population, area <br>FROM world <br>WHERE area &gt; 3000000<br>UNION<br>SELECT name, population, area <br>FROM world <br>WHERE population &gt; 25000000<br><br><br>SELECT name, population, area <br>FROM world <br>WHERE area &gt; 3000000 OR population &gt; 25000000<br></code></pre></td></tr></table></figure><h3 id="6-二叉搜索树的范围和"><a href="#6-二叉搜索树的范围和" class="headerlink" title="6.二叉搜索树的范围和"></a>6.二叉搜索树的范围和</h3><p><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">二叉搜索树的范围和</a>: 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。<br>二叉搜索树保证具有唯一的值。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">示例<span class="hljs-number">1</span>:<br>输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">18</span>], <span class="hljs-attr">L</span> = <span class="hljs-number">7</span>, <span class="hljs-attr">R</span> = <span class="hljs-number">15</span><br>输出：<span class="hljs-number">32</span><br><br>示例<span class="hljs-number">2</span>:<br>输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>], <span class="hljs-attr">L</span> = <span class="hljs-number">6</span>, <span class="hljs-attr">R</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p>提示</p><ul><li>树中的结点数量最多为 10000 个。</li><li>最终的答案保证小于 2^31。</li></ul><h4 id="答案一-4"><a href="#答案一-4" class="headerlink" title="答案一"></a>答案一</h4><p><code>Java官方解法</code><br>要理解这道题首先要知道一个概念<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉查找树</a>, 也称为二叉搜索树、有序二叉树、排序二叉树，指一棵空树或具有以下性质的二叉树：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><p>深度优先搜索我们对树进行深度优先搜索，对于当前节点 node，如果 node.val 小于等于 L，那么只需要继续搜索它的右子树；如果 node.val 大于等于 R，那么只需要继续搜索它的左子树；如果 node.val 在区间 (L, R) 中，则需要搜索它的所有子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rangeSumBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        ans = <span class="hljs-number">0</span>;<br>        dfs(root, L, R);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (L &lt;= node.val &amp;&amp; node.val &lt;= R)<br>                ans += node.val;<br>            <span class="hljs-keyword">if</span> (L &lt; node.val)<br>                dfs(node.left, L, R);<br>            <span class="hljs-keyword">if</span> (node.val &lt; R)<br>                dfs(node.right, L, R);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代实现深度优先搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rangeSumBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span>(L &lt;= node.val &amp;&amp; node.val &lt;= R)<br>                    ans += node.val;<br><br>                <span class="hljs-keyword">if</span>(L &lt; node.val)<br>                    stack.push(node.left);<br>                <br>                <span class="hljs-keyword">if</span>(node.val &lt; R)<br>                    stack.push(node.right);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="答案二-3"><a href="#答案二-3" class="headerlink" title="答案二"></a>答案二</h4><p><code>JavaScript</code>画图解题<br><img src="https://cdn.darknights.cn/assets/images/in-post/leetcode/tree.jpeg"><br>假设L= 7，R=15 </p><ul><li>如果node.val &gt;= 7 &amp;&amp; node.val &lt;= 15 则直接求和</li><li>如果node.val &gt; 7,则node.right的值都大于7，右侧没有搜索必要，去查找left的值</li><li>如果node.val &lt; 15,则node.left的值都小于15，左侧没有搜索必要，去查找right的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">L</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">R</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rangeSumBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, L, R</span>) &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>        <br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dealBinTree</span> = node =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(node !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(L &lt; node.<span class="hljs-property">val</span>) &#123;<br>                    <span class="hljs-title function_">dealBinTree</span>(node.<span class="hljs-property">left</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">val</span> &gt;= L &amp;&amp; node.<span class="hljs-property">val</span> &lt;= R) &#123;<br>                sum += node.<span class="hljs-property">val</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(R &gt; node.<span class="hljs-property">val</span>) &#123;<br>                    <span class="hljs-title function_">dealBinTree</span>(node.<span class="hljs-property">right</span>);<br>            &#125;<br>            <br>        &#125;<br>    <br>    &#125;<br>    <br>    <span class="hljs-title function_">dealBinTree</span>(root);<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-转换成小写字母"><a href="#7-转换成小写字母" class="headerlink" title="7.转换成小写字母"></a>7.转换成小写字母</h3><p><a href="https://leetcode-cn.com/problems/to-lower-case/">转换成小写字母</a>:实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 1c">示例 <span class="hljs-number">1</span>：<br><br>输入: <span class="hljs-string">&quot;Hello&quot;</span><br>输出: <span class="hljs-string">&quot;hello&quot;</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入: <span class="hljs-string">&quot;here&quot;</span><br>输出: <span class="hljs-string">&quot;here&quot;</span><br>示例 <span class="hljs-number">3</span>：<br><br>输入: <span class="hljs-string">&quot;LOVELY&quot;</span><br>输出: <span class="hljs-string">&quot;lovely&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-5"><a href="#答案一-5" class="headerlink" title="答案一"></a>答案一</h4><p>分析通过字符串的 <code>charCodeAt</code>和<code>String.fromCharCode</code>这两个方法来得到答案</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;string&#125; str</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;string&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-variable">toLowerCase</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> &#x27;&#x27;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-variable">str</span>.<span class="hljs-property">length</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">len</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>        <span class="hljs-keyword">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-variable">str</span>.<span class="hljs-property">charCodeAt</span>(<span class="hljs-variable">i</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">c</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">65</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-variable">c</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">90</span>) &#123;<br>           <span class="hljs-variable">s</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-title class_">String</span>.<span class="hljs-property">fromCharCode</span>(<span class="hljs-variable">c</span><span class="hljs-operator">+</span><span class="hljs-number">32</span>); <br>        &#125;  <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-variable">s</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">str</span>.<span class="hljs-property">charAt</span>(<span class="hljs-variable">i</span>);    <br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">s</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-唯一摩尔斯密码词"><a href="#8-唯一摩尔斯密码词" class="headerlink" title="8.唯一摩尔斯密码词"></a>8.唯一摩尔斯密码词</h3><p><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">唯一摩尔斯密码词</a><br>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。<br>为了方便，所有26个英文字母对应摩尔斯密码表如下：</p><p>[“.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—“,”-.-“,”.-..”,”–”,”-.”,”—“,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”]</p><p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…”，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。</p><p>返回我们可以获得所有词不同单词翻译的数量。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean">例如:<br>输入: words = [<span class="hljs-string">&quot;gin&quot;</span>, <span class="hljs-string">&quot;zen&quot;</span>, <span class="hljs-string">&quot;gig&quot;</span>, <span class="hljs-string">&quot;msg&quot;</span>]<br>输出: <span class="hljs-number">2</span><br>解释: <br>各单词翻译如下:<br><span class="hljs-string">&quot;gin&quot;</span> -&gt; <span class="hljs-string">&quot;--...-.&quot;</span><br><span class="hljs-string">&quot;zen&quot;</span> -&gt; <span class="hljs-string">&quot;--...-.&quot;</span><br><span class="hljs-string">&quot;gig&quot;</span> -&gt; <span class="hljs-string">&quot;--...--.&quot;</span><br><span class="hljs-string">&quot;msg&quot;</span> -&gt; <span class="hljs-string">&quot;--...--.&quot;</span><br><br>共有 <span class="hljs-number">2</span> 种不同翻译, <span class="hljs-string">&quot;--...-.&quot;</span> 和 <span class="hljs-string">&quot;--...--.&quot;</span>.<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>单词列表words 的长度不会超过 100。</li><li>每个单词 words[i]的长度范围为 [1, 12]。</li><li>每个单词 words[i]只包含小写字母。</li></ul><h4 id="答案一-6"><a href="#答案一-6" class="headerlink" title="答案一"></a>答案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">words</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniqueMorseRepresentations = <span class="hljs-keyword">function</span>(<span class="hljs-params">words</span>) &#123;<br>    <span class="hljs-keyword">var</span> map = [<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>];<br>    <br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = words.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <br>        <span class="hljs-keyword">let</span> m = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, jen = words[i].<span class="hljs-property">length</span>; j &lt; jen; j++) &#123;<br>             m += map[words[i].<span class="hljs-title function_">charCodeAt</span>(j) - <span class="hljs-number">97</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(m)) &#123;<br>            obj[m] = obj[m] + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj[m] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>    &#125;<br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-4"><a href="#答案二-4" class="headerlink" title="答案二"></a>答案二</h4><p><code>Java</code>利用Set自动去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniqueMorseRepresentations</span><span class="hljs-params">(String[] words)</span> &#123;<br>        String[] s=&#123;<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>&#125;;<br><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> index;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; words[i].length(); j++) &#123;<br>                index = (<span class="hljs-type">int</span>)words[i].charAt(j) - <span class="hljs-number">65</span> - <span class="hljs-number">32</span>;<br>                temp = temp.concat(s[index]);<br>            &#125;<br>            set.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-合并二叉树"><a href="#9-合并二叉树" class="headerlink" title="9.合并二叉树"></a>9.合并二叉树</h3><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a>:给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">示例 1:<br><br>输入: <br>Tree<span class="hljs-number"> 1 </span>                    Tree<span class="hljs-number"> 2 </span>                 <br>         <span class="hljs-number"> 1 </span>                       <span class="hljs-number"> 2 </span>                            <br>         / \                       / \                            <br>       <span class="hljs-number"> 3 </span> <span class="hljs-number"> 2 </span>                   <span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>                       <br>       /                           \   \                      <br>     <span class="hljs-number"> 5 </span>                           <span class="hljs-number"> 4 </span> <span class="hljs-number"> 7 </span>                 <br>输出: <br>合并后的树:<br>     3<br>    / \<br>  <span class="hljs-number"> 4 </span>  5<br>  / \   \ <br><span class="hljs-number"> 5 </span> <span class="hljs-number"> 4 </span>  7<br>注意: 合并必须从两个树的根节点开始。<br></code></pre></td></tr></table></figure><h4 id="答案一-7"><a href="#答案一-7" class="headerlink" title="答案一"></a>答案一</h4><p><code>Java</code>解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">meregeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(t1.val + t2.val);<br>        result.left = mergeTrees(t1.left, t2.left);<br>        result.right = mergeTrees(t1.right, t2.right);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案二-5"><a href="#答案二-5" class="headerlink" title="答案二"></a>答案二</h4><p><code>JavaScript</code>解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">t1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">t2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">t1, t2</span>) &#123;<br>    <span class="hljs-keyword">if</span>(t1 === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> t2;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t2 === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>    <br>    t1.<span class="hljs-property">val</span> = t1.<span class="hljs-property">val</span> + t2.<span class="hljs-property">val</span>;<br>    t1.<span class="hljs-property">left</span> = <span class="hljs-title function_">mergeTrees</span>(t1.<span class="hljs-property">left</span>, t2.<span class="hljs-property">left</span>);<br>    t1.<span class="hljs-property">right</span> = <span class="hljs-title function_">mergeTrees</span>(t1.<span class="hljs-property">right</span>, t2.<span class="hljs-property">right</span>);<br>    <br>    <span class="hljs-keyword">return</span> t1;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-翻转图像"><a href="#10-翻转图像" class="headerlink" title="10.翻转图像"></a>10.翻转图像</h3><p><a href="https://leetcode-cn.com/problems/flipping-an-image/">翻转图像</a>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。<br>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。<br>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">示例 <span class="hljs-number">1</span>:<br><br>输入: <span class="hljs-string">[[1,1,0],[1,0,1],[0,0,0]]</span><br>输出: <span class="hljs-string">[[1,0,0],[0,1,0],[1,1,1]]</span><br>解释: 首先翻转每一行: <span class="hljs-string">[[0,1,1],[1,0,1],[0,0,0]]</span>；<br>     然后反转图片: <span class="hljs-string">[[1,0,0],[0,1,0],[1,1,1]]</span><br>示例 <span class="hljs-number">2</span>:<br><br>输入: <span class="hljs-string">[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br>输出: <span class="hljs-string">[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br>解释: 首先翻转每一行: <span class="hljs-string">[[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]</span>；<br>     然后反转图片: <span class="hljs-string">[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br>说明:<br><br><span class="hljs-number">1</span> &lt;= A.length = A[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">20</span><br><span class="hljs-number">0</span> &lt;= A[i][j] &lt;= <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h4 id="答案一-8"><a href="#答案一-8" class="headerlink" title="答案一"></a>答案一</h4><p>分析：最简单的方法就是按部就班来实现，先进行水平再进行图片反转。<br>对于1和0的翻转有两种方式</p><ul><li>1 - 当前值 得到的是1和0的翻转</li><li>1 ^ 当前值 得到的也是0和1的反转。这个符号是异或，相同为0，相异为1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flipAndInvertImage = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = A.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> re = A[i].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">let</span> im = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; re.<span class="hljs-property">length</span>; j++) &#123;<br>               im += <span class="hljs-title class_">Number</span>(re[j]) === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        A[i] = im.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>();<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="答案二-6"><a href="#答案二-6" class="headerlink" title="答案二"></a>答案二</h4><p>数组api一行解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flipAndInvertImage = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">return</span> A.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> (<span class="hljs-number">1</span> - v)))<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="答案三"><a href="#答案三" class="headerlink" title="答案三"></a>答案三</h4><p>双向指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flipAndInvertImage = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Alen</span> = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> len = A[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Alen</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> right = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-keyword">let</span> temp = A[i][left];<br>            A[i][left] = A[i][right] ^ <span class="hljs-number">1</span>;<br>            A[i][right] = temp ^ <span class="hljs-number">1</span>;<br>            <br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建门户网站技术选型</title>
    <link href="/2018/10/21/2018-11-21-scaffold-front-www/"/>
    <url>/2018/10/21/2018-11-21-scaffold-front-www/</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>工作多年，项目越来越多，总是要做一些重复性的工作开进行开发，每次东配置西配置一大堆，效率很低无法直接投入生产。<br>通过这篇文章梳理一下自己的知识点，将一些常用技术做一些总结归纳和复习。并且基于此开发一套模版，用于以后网站开发直接套用，不做重复性的工作（这里的网站主要针对pc）。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>从前端的角度来说，如何从零开始开发一个门户网站呢？ 首先是要有一些基础知识包括<code>JavaScript</code>, <code>css</code>, <code>html</code>。</p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>关于<code>html</code>需要了解的是，语义化的标签，还有html模版。一个html应该有什么呢，我们通过一个html模版来看下<a href="https://github.com/h5bp/html5-boilerplate">html5-boilerplate</a>, 这是一个专业的前端模版html。 由于篇幅问题就不再这里展开大家可以去github仓库中的dist文件夹查看index.html。<br>我们简单介绍下其中用到的东西</p><p>首先是通用的html5的头<code><!doctype html></code></p><p>在HTML中，doctype是所有文档顶部所需的“ 序言“。其唯一目的是防止浏览器在呈现文档时转换成所谓的“怪异”模式; 也就是说，doctype确保浏览器尽力尝试遵循相关规范，而不是使用与某些规范不兼容的不同渲染模式。DOCTYPE用来告知 Web 浏览器页面使用了哪种 HTML 版本,只有确定了一个正确的文档类型，HTML或XHTML中的标签和层叠样式表才能生效，甚至对JavaScript脚本都会有所影响。</p><p> 还有这个Meta标签，如果您需要支持IE9或IE8，那么建议使用该标签， 如果支持最新的IE11或Edge则考虑删除此标签<br> <figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;x-ua-compatible&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;<br></code></pre></td></tr></table></figure><br> 这个X-UA标记允许web作者选择呈现页面的Internet Explore版本，具体解释请看<a href="https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do">这篇文章</a></p><p>然后这里还用到了<a href="https://necolas.github.io/normalize.css/">normalize.css</a>,来消除不通浏览器之间的样式差异。<br>还使用了<a href="https://modernizr.com/">modernizr</a>，来进行浏览器功能检查。<br>以及大家最熟悉的jQuery(如果只兼容IE9+则可以放心使用最新版本，如果需要支持IE8则需要使用2.0以下的版本)</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>css我们先前在模版中已经引入了<a href="https://necolas.github.io/normalize.css/">normalize.css</a>, 其余css基础知识的获取就需要大家自行补充了，建议读一下《css权威指南》，算是css内功方面的书籍了，再就是了解css的布局包括栅格布局，flex布局， 还有更早期的双飞翼布局，圣杯布局等等。</p><p>除了这些基础实战中我们通常会用到css预处理器，<a href="https://sass-lang.com/">Sass</a>、<a href="http://lesscss.org/">Less</a>和<a href="http://stylus-lang.com/">Stylus</a>. 最开始我使用的是sass，但是这个的npm包经常会被墙下载不下来，相关依赖感觉也比较重。至于选哪种看大家喜好了，我推荐使用stylus，语法自由度很高，代码非常简洁。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>什么是最轻量的JavaScript框架,那就是<a href="http://vanilla-js.com/">vanilla-js</a> 来自<a href="https://segmentfault.com/a/1190000000355277"> Vanilla JS——世界上最轻量的JavaScript框架（没有之一）</a>,这里是个玩笑，因为这里说的框架其实就是原生Js。<br>大型网站的开发还是需要依赖各种js的库或者框架。这里简单列几种，</p><ul><li>jQuery，虽然有些人抵触，但是为了保证代码兼容性，我还是愿意引入jQuery的</li><li>Backbone， 一款轻量级的框架，不过需要配合underscore或者lodash使用</li><li><a href="https://github.com/wycats/handlebars.js">Handlebars</a>, js模版用来处理html代码片段</li></ul><p>具体代码可以考虑使用ES5如果这样的话需要引入<a href="https://babeljs.io/">babeljs</a>,做转换这样就可以愉快的使用新语法了，除此之外我们的选择还有<a href="https://coffeescript.org/">CoffeeScript</a>, 和<a href="https://www.typescriptlang.org/">TypeScript</a>. </p><p>代码规范可以可以参考<a href="https://codeburst.io/5-javascript-style-guides-including-airbnb-github-google-88cbc6b2b7aa">这篇文章</a><br>我推荐使用其中更为广泛的<a href="https://github.com/airbnb/javascript">Airbnb Standard</a> 比<a href="https://github.com/standard/standard">JavaScript Standard Style</a> 更多的star。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>好了前期准备工作已经完成现在我们开始正式开始</p>]]></content>
    
    
    <categories>
      
      <category>脚手架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓和IOS前端页面调试</title>
    <link href="/2018/10/20/2018-11-20-debug-webview/"/>
    <url>/2018/10/20/2018-11-20-debug-webview/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们通常会有这样的开发场景， 开发了一些前端页面，可能在手机浏览器打开，也可能在客户端的webview打开，对应不同的场景我们可能需要不通的手段来进行调试。<br>对于简单的页面我们一般可以通过chrome的开发工具来调试或者通过safari来直接对手机打开的页面直接进行调试。 但是对于复杂webview我们可能需要一些特殊手段来进行debug.</p><p>在本文将总结一部分调试技巧</p><table><thead><tr><th>方法分类</th><th align="right">难度</th><th align="center">调试目标</th><th align="center">调试效果</th><th align="center">优先级</th></tr></thead><tbody><tr><td>Chrome自带模拟器</td><td align="right">简单</td><td align="center">所有</td><td align="center">模拟效果，基本能调试 UI 及标准 JS 所有问题</td><td align="center">极高</td></tr><tr><td>chrome://inspect</td><td align="right">简单</td><td align="center">安卓的自带浏览器+webview</td><td align="center">真机调试效果显著</td><td align="center">高</td></tr><tr><td>spy-debugger</td><td align="right">一般</td><td align="center">所有页面不管是否是webview</td><td align="center">效果可以</td><td align="center">高</td></tr><tr><td>safari开发模式</td><td align="right">简单</td><td align="center">手机safari的所有页面</td><td align="center">真机调试效果显著</td><td align="center">高</td></tr><tr><td>xcode的iPhone模拟器</td><td align="right">较难</td><td align="center">webview和手机浏览器</td><td align="center">调试效果显著</td><td align="center">中等</td></tr><tr><td>weinre</td><td align="right">一般</td><td align="center">所有页面不管是否是webview</td><td align="center">需要注入代码效果一般</td><td align="center">低</td></tr><tr><td>微信开发者工具</td><td align="right">一般</td><td align="center">模拟手机</td><td align="center"></td><td align="center">低</td></tr><tr><td>TBS Studio</td><td align="right">一般</td><td align="center">模拟手机</td><td align="center"></td><td align="center">未测试</td></tr><tr><td>Browsersync</td><td align="right">一般</td><td align="center">模拟手机</td><td align="center"></td><td align="center">未测试</td></tr></tbody></table><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>对于抓包有很多工具比如 mac上面有 charles，wireShark， windows上面有fiddler 等等。<br>我常用的一个抓包工具叫 <a href="https://mitmproxy.org/">mitmproxy</a>, 在github已经一万多star了，使用起来比较简单。 一条命令 <code>mitmproxy -p 4000 --set console_mouse=false</code>, 启动后 手机手动代理到 ip+端口就可以开始抓包了，对于https可能需要<a href="http://mitm.it/">安装证书</a>.至于安装过程就不重复了，官网已有<a href="https://docs.mitmproxy.org/stable/">教程</a>。</p><p>charles抓包请查看<a href="https://www.jianshu.com/p/fdd7c681929c">这篇教程</a></p><h2 id="安卓的webview页面"><a href="#安卓的webview页面" class="headerlink" title="安卓的webview页面"></a>安卓的webview页面</h2><p>现在的安卓应用内的页面进行调试是真的方便。</p><ul><li>首先打开手机的usb调试，连接到电脑。</li><li>第二在chrome输入 <code>chrome://inspect/#devices</code> （开发环境安卓桌面版Chrome32+ 并且 Android 系统高于 4.4）</li><li>第三 选择app中的页面进行调试即可</li></ul><h2 id="safari调试iPhone页面"><a href="#safari调试iPhone页面" class="headerlink" title="safari调试iPhone页面"></a>safari调试iPhone页面</h2><p>这种方式适合手机上面的浏览器页面<br>需要几步配置</p><ul><li><p>首先打开电脑的safari<br><img src="https://cdn.darknights.cn/assets/images/in-post/debug-webview/Safari%E8%AE%BE%E7%BD%AE.png"></p></li><li><p>然后打开iPhone进行设置<br><img src="https://cdn.darknights.cn/assets/images/in-post/debug-webview/iPhone%E8%AE%BE%E7%BD%AE.png"></p></li><li><p>最后通过电脑的safari打开进行调试<br><img src="https://cdn.darknights.cn/assets/images/in-post/debug-webview/%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95.png"></p></li></ul><h2 id="调试iPhone的webview"><a href="#调试iPhone的webview" class="headerlink" title="调试iPhone的webview"></a>调试iPhone的webview</h2><p>iPhone的webview可行的方法就是下载xcode，然后跟客户端开发借来一个xxx.app然后用模拟器打开，这样调试页面的时候可以调试各种情况下的页面，包括safari和应用内的页面。<br>这是目前唯一靠谱的调试方案。 还有一些 <a href="https://github.com/google/ios-webkit-debug-proxy">ios-webkit-debug-proxy</a> 和 <a href="https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter">remotedebug-ios-webkit-adapter</a> 类似方案， 这些方案只能够调试手机的safari 对于app中的webview就无能为力了，而且经过本人实践效果并不理想，如果只是为了调试safari那还不如直接usb连接方便快捷，而且安装过程会有很多坑，因此不推荐使用。</p><p>简化方案</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>打开首页<br>xcrun simctl openurl booted taobao:<span class="hljs-regexp">//</span>h5.m.taobao.com<span class="hljs-regexp">/guang/i</span>ndex.html<br><span class="hljs-regexp">//</span> 打开模拟器<br>open -a <span class="hljs-string">&quot;Simulator.app&quot;</span> --args -CurrentDeviceUDID <span class="hljs-string">&quot;FCE2CFE8-64C3-4DBE-906B-B9BF4180DE49&quot;</span><br><br></code></pre></td></tr></table></figure><p>前提是安装了xcode， 本地需要一个sdk与测试网站进行交互方便获取app和执行本地shell命令<br>根据<a href="http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/">此文章</a>, 后期开发一个测试环境用的本地调试网站。</p><p><a href="http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/">http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/</a></p><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p>Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。</p><ul><li><p>安装 Weinre</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo npm -g <span class="hljs-keyword">install</span> weinre<br></code></pre></td></tr></table></figure></li><li><p>启动Weinre监听服务</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">$ weinre</span> <span class="hljs-literal">--</span><span class="hljs-comment">boundHost 10</span><span class="hljs-string">.</span><span class="hljs-comment">10</span><span class="hljs-string">.</span><span class="hljs-comment">2</span><span class="hljs-string">.</span><span class="hljs-comment">144</span> <span class="hljs-literal">--</span><span class="hljs-comment">httpPort 8090</span> <br></code></pre></td></tr></table></figure></li><li><p>使用chrome访问<br><a href="http://10.10.2.144:8090/">http://10.10.2.144:8090</a>, 然后将一段 JS 脚本 <script src="http://10.10.2.144:8090/target/target-script-min.js#anonymous"></script> 插入到需要调试的页面中，插入代码后手机访问调试页面。<br><img src="https://cdn.darknights.cn/assets/images/in-post/debug-webview/weinre.png"></p></li></ul><p>到这里还不算完，因为手动插入js不够优雅，所以这里采用js脚本注入<br>Tools –&gt; Rewrite 选中Enable Rewrite<br>这里我们需要使用到的是 Body，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 </body> 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。<br><img src="https://cdn.darknights.cn/assets/images/in-post/debug-webview/Charles_Rewrite.jpg"></p><p><img src="https://cdn.darknights.cn/assets/images/in-post/debug-webview/Charles_Rewrite_Rule.jpg"></p><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger">spy-debugger</a>跟微信开发这工具都在weinre的基础上简化了给页面添加js的步骤，它还对HTTPS的支持</p><p>安装spy-debugger<br>spy-debugger内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html">weinre</a>、<a href="https://github.com/wuchangming/node-mitmproxy">node-mitmproxy</a>、<a href="https://github.com/alibaba/anyproxy">AnyProxy</a></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$  sudo <span class="hljs-built_in">npm</span> install spy-<span class="hljs-keyword">debugger</span> -g<br></code></pre></td></tr></table></figure><p>安装https证书包括手机和PC。<br>执行启动特别酸爽</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ spy-<span class="hljs-keyword">debugger</span> -p <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><h2 id="TBS-Studio"><a href="#TBS-Studio" class="headerlink" title="TBS Studio"></a>TBS Studio</h2><p><a href="https://x5.tencent.com/guide/debug.html">TBS Studio</a></p><h2 id="微信-WebView-调试"><a href="#微信-WebView-调试" class="headerlink" title="微信 WebView 调试"></a>微信 WebView 调试</h2><p><a href="https://x5.tencent.com/tbs/guide/debug/season1.html">https://x5.tencent.com/tbs/guide/debug/season1.html</a></p><h2 id="browserSync"><a href="#browserSync" class="headerlink" title="browserSync"></a>browserSync</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://75team.com/post/webview-debug.html">前端 WebView 指南之调试篇</a></li><li><a href="http://elevenbeans.github.io/2017/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/">移动端浏览器调试方法汇总</a></li><li><a href="https://aotu.io/notes/2017/02/24/Mobile-debug/index.html">移动端真机调试指南</a></li><li><a href="https://github.com/riskers/blog/issues/11">打造最舒适的webview调试环境</a></li><li><a href="http://yujiangshui.com/multidevice-frontend-debug/">移动端前端开发调试</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript中卷(一)</title>
    <link href="/2018/10/18/2018-10-18-read-book-you-known-middle-one/"/>
    <url>/2018/10/18/2018-10-18-read-book-you-known-middle-one/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;foo&quot;</span>;<br>b = [<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>];<br><br><span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>.<span class="hljs-title function_">call</span>(a, <span class="hljs-string">&quot;-&quot;</span>);<br><br><span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">call</span>(a, <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) &#123;<br><span class="hljs-keyword">return</span> v.<span class="hljs-title function_">toUpperCase</span>() + <span class="hljs-string">&quot;.&quot;</span><br>&#125;).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br><br>c; <span class="hljs-comment">// &quot;f-o-o&quot;</span><br><br>d; <span class="hljs-comment">// &quot;F.O.O.&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = <span class="hljs-number">5</span>E10;<br><br>a; <span class="hljs-regexp">//</span> <span class="hljs-number">50000000000</span><br><br>a.toExponential(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5e+10&quot;</span><br><br><br><span class="hljs-regexp">//</span> toFixed 用来显示小数部分的显示位数<br>var a = <span class="hljs-number">42.59</span>;<br><br>a.toFixed(<span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;43&quot;</span><br><br>a.toFixed(<span class="hljs-number">1</span>);  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.6&quot;</span><br><br>a.toFixed(<span class="hljs-number">2</span>);  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.59&quot;</span><br><br><br><span class="hljs-number">42</span>.toFixed(<span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> SyntaxError 报错 <span class="hljs-number">42</span>. 被视为一个整体 所以没有访问toFixed<br><br>以下访问方式都没有问题<br><br>(<span class="hljs-number">42</span>).toFixed(<span class="hljs-number">3</span>);  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.000&quot;</span><br><span class="hljs-number">0.42</span>.toFixed(<span class="hljs-number">3</span>);  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;0.420&quot;</span><br><span class="hljs-number">42</span>..toFixed(<span class="hljs-number">3</span>);   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.000&quot;</span><br><br><br><span class="hljs-regexp">//</span> toPrecision 方法用来制定有效数位的显示位数<br><br>var a = <span class="hljs-number">42.59</span>;<br><br>a.toPrecision(<span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;4e+1&quot;</span><br>a.toPrecision(<span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;43&quot;</span><br>a.toPrecision(<span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.6&quot;</span><br>a.toPrecision(<span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.59&quot;</span><br>a.toPrecision(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42.590&quot;</span><br><br><br><br></code></pre></td></tr></table></figure><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span>; <span class="hljs-regexp">//</span> false<br><br>由于浮点数的精读问题导致<br><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>; <span class="hljs-regexp">//</span> <span class="hljs-number">0.3000000000000004</span>;<br><br></code></pre></td></tr></table></figure><p>那么如果判断0.1 + 0.2 和 0.3 是否相等呢， 最常见的做法是设置一个误差范围值， 通常称为”机器精度”， 对于JavaScript来说这个值通常是2^-52;<br>ES6开始，该值定义在<code>Number.EPSILON</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Number</span>.EPSILON) &#123;<br><span class="hljs-built_in">Number</span>.EPSILON = Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">-52</span>);<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">numbersCloseEnoughToEqual</span>(<span class="hljs-params">n1, n2</span>) &#123;<br><span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">abs</span>(n1 - n2) &lt; <span class="hljs-built_in">Number</span>.EPSILON;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">0.3</span>;<br><br>numbersCloseEnoughToEqual(a, b);  <span class="hljs-comment">// true;</span><br><br>numbersCloseEnoughToEqual(<span class="hljs-number">0.0000001</span>, <span class="hljs-number">0.0000002</span>); <span class="hljs-comment">// false;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="整数检测"><a href="#整数检测" class="headerlink" title="整数检测"></a>整数检测</h2><p>要检测一个值是否是整数，可以使用ES6种的Number.isInteger方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">Integer(42)</span>;     <span class="hljs-comment">// true</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">Integer(42.00)</span>;  <span class="hljs-comment">// true</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">Integer(45.3)</span>;   <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// ES6 之前的polyfill Number.isInteger</span><br><br><span class="hljs-keyword">if</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>isInteger) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>isInteger = <span class="hljs-keyword">function</span>(num) &#123;<br>return typeof num<span class="hljs-operator"> == </span>&#x27;number&#x27;<span class="hljs-operator"> &amp;&amp; </span>num % <span class="hljs-number">1</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 最大安全数</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbe</span>.</span></span>is<span class="hljs-constructor">SafeInteger(Number.MAX_SAFE_INTEGER)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbe</span>.</span></span>is<span class="hljs-constructor">SafeInteger(Math.<span class="hljs-params">pow</span>(2, 53)</span>); <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Numbe</span>.</span></span>is<span class="hljs-constructor">SafeInteger(Math.<span class="hljs-params">pow</span>(2, 53)</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// ES6 之前的polyfill Number.isSafeInteger</span><br><br><span class="hljs-keyword">if</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>isSafeInteger) &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>isSafeInteger = <span class="hljs-keyword">function</span>(num) &#123;<br>return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Number</span>.</span></span>is<span class="hljs-constructor">Integer(<span class="hljs-params">num</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(num) &lt;= Number.MAX_SAFE_INTEGER;<br>&#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>JavaScript有一个常规的0(+0), 和一个-0<br>-0， 除了可以作为常量以外，也可以是某些数学运算的返回值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>var a = <span class="hljs-number">0</span><span class="hljs-operator"> / </span>-<span class="hljs-number">3</span>; <span class="hljs-comment">// -0</span><br><br>var b = <span class="hljs-number">0</span><span class="hljs-operator"> * </span>-<span class="hljs-number">3</span>; <span class="hljs-comment">// -0</span><br><br>加法和减法运算不会得到负零<br><br><br>根据规范对于负零进行字符串化操作会返回<span class="hljs-string">&quot;0&quot;</span><br>var a = -<span class="hljs-number">0</span>;<br><br>a.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>a + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-constructor">String(<span class="hljs-params">a</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>stringify(a)<br><br>以上都会返回 <span class="hljs-string">&quot;0&quot;</span>, 但是返回来将其从字符串转换为数字，得到的结果是准确的<br><br>+<span class="hljs-string">&quot;-0&quot;</span>;            <span class="hljs-comment">// -0</span><br><span class="hljs-constructor">Number(<span class="hljs-string">&quot;-0&quot;</span>)</span>;     <span class="hljs-comment">// -0</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(<span class="hljs-string">&quot;-0&quot;</span>); <span class="hljs-comment">// -0</span><br><br><br><span class="hljs-number">0</span><span class="hljs-operator"> === </span>-<span class="hljs-number">0</span>; <span class="hljs-comment">// true</span><br><br><span class="hljs-number">0</span><span class="hljs-operator"> == </span>-<span class="hljs-number">0</span>;  <span class="hljs-comment">// true</span><br><br><span class="hljs-number">0</span> &gt; -<span class="hljs-number">0</span>;    <span class="hljs-comment">// false</span><br><br>判断是否是 -<span class="hljs-number">0</span><br><br><span class="hljs-keyword">function</span> is<span class="hljs-constructor">NegZero(<span class="hljs-params">n</span>)</span> &#123;<br>n = <span class="hljs-constructor">Number(<span class="hljs-params">n</span>)</span>;<br><br>return (n<span class="hljs-operator"> === </span><span class="hljs-number">0</span>)<span class="hljs-operator"> &amp;&amp; </span>(<span class="hljs-number">1</span><span class="hljs-operator"> / </span>n<span class="hljs-operator"> === </span>-Infinity);<br>&#125;<br><br><br>is<span class="hljs-constructor">NegZero(-0)</span>;      <span class="hljs-comment">// true</span><br>is<span class="hljs-constructor">NegZero(0 <span class="hljs-operator">/</span> -3)</span>;  <span class="hljs-comment">// true</span><br>is<span class="hljs-constructor">NegZero(0)</span>;       <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p>我们为什么需要-0呢，有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度), 数字的符号为sign用来代表其他信息(比如移动方向),此时如果一个值为0的变量失去了它的符号位，它的方向信息就回丢失。所以保留0值的符号为可以防止这类情况发生。</p><h2 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h2><p>如前所述，NaN和0在相等比较时表现有些特别，由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN或者polyfill, 而 +0 和 -0 的比较我们也需要借助于 isNegZero这样的工具函数。</p><p>ES6引入了一个工具方法Object.is(…)来判断两个值是否绝对相等用来处理上面特殊情况</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-keyword">var</span> b = <span class="hljs-number">-3</span> * <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>(a, NaN); <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>(b, <span class="hljs-number">-0</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>(b, <span class="hljs-number">0</span>);   <span class="hljs-comment">// false</span><br><br><br>ES6之前的polyfill<br><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>) &#123;<br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> = function(v1, v2) &#123;<br><span class="hljs-comment">//判断是否是-0</span><br><span class="hljs-keyword">if</span>(v1 === <span class="hljs-number">0</span> &amp;&amp; v2 === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / v1 === <span class="hljs-number">1</span> / v2;<br>&#125;<br><br><span class="hljs-comment">// 判断是否是NaN</span><br><span class="hljs-keyword">if</span>(v1 !== v1) &#123;<br><span class="hljs-keyword">return</span> v2 !== v2;<br>&#125;<br><br><span class="hljs-keyword">return</span> v1 === v2;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="JSON字符串化"><a href="#JSON字符串化" class="headerlink" title="JSON字符串化"></a>JSON字符串化</h2><p>对于大多数简单值来说JSON字符串化和toString效果基本相同，只不过序列化的结构总是字符串<br>所有安全的JSON值都呈现为有效的JSON格式的值</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">JSON.stringify(<span class="hljs-number">42</span>);  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;42&quot;</span><br>JSON.stringify(<span class="hljs-string">&quot;42&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-number">42</span><span class="hljs-string">&quot;&quot;</span><br>JSON.stringify(null) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;null&quot;</span><br>JSON.stringify(true) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;true&quot;</span><br><br><br></code></pre></td></tr></table></figure><p>相对而言不安全的JSON值包括 undefined, function , symbol和包含循环引用的对象都不符合JSON的标准结构，其他支持JSON的语言无法处理它们。</p><p>JSON.toStringify(…)在处理对象中遇到undefined,function,Symbol是会自动将其忽略，在数组中则返回null，以保证单于位置不变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// undefined</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;)     <span class="hljs-comment">// undefined</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-number">4</span>] <span class="hljs-comment">// &quot;[1, null, null, 4]&quot;</span><br>)<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<br>&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">b</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;&#125;         <span class="hljs-comment">// &quot;&#123;&quot;a&quot;: 2&#125;&quot;</span><br>) <br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure><p>如果对象定义了toJSON方法，JSON字符串化会首先调用该方法然后用它的返回值来进行序列化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;&#125;;<br><span class="hljs-keyword">var</span> a = &#123;<br><span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,<br><span class="hljs-attr">c</span>: o,<br><span class="hljs-attr">d</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br>o.<span class="hljs-property">e</span> = a;<br><br><span class="hljs-comment">//循环引用会报错</span><br><span class="hljs-comment">// JSON.stringify(a);</span><br><br><span class="hljs-comment">//自定义的JSON序列化</span><br>a.<span class="hljs-property">toJSON</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">b</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>&#125;;<br>&#125;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a); <span class="hljs-comment">// &quot;&#123;b: 42&#125;&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h2><p>几个不为人知的知识点,该方法可以传入一个replacer，它可以是数组或者函数，用来制定对象序列化过程中那些应该被处理，哪些应该被排除，如果replacer是一个数组，那么它必须是一个字符串数组，其中高喊序列化要处理的对象的属性名称。除此之外的其他属性被忽略。如果replacer是一个函数，它会对对象本身调用一次然后对对象中的每个属性各调用一次，每次传递两个参数key和value，如果要忽略某个key就返回undefined，否则返回指定值</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = &#123;<br>b: <span class="hljs-number">42</span>,<br>c: <span class="hljs-string">&quot;42&quot;</span>,<br>d: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><br>JSON.stringify(a, [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&#123;&quot;</span><span class="hljs-string">b&quot;: 42, &quot;</span>c<span class="hljs-string">&quot;: &quot;</span><span class="hljs-number">42</span><span class="hljs-string">&quot;&#125;&quot;</span><br><br>JSON.stringify(a, <span class="hljs-keyword">function</span>(k, v) &#123;<br><span class="hljs-keyword">if</span>(k !== <span class="hljs-string">&quot;c&quot;</span>) return v;<br>&#125;);<br><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&#123;&quot;</span><span class="hljs-string">b&quot;: 42, &quot;</span>d<span class="hljs-string">&quot;: [1,2,3]&#125;&quot;</span><br><br><br></code></pre></td></tr></table></figure><p>JSON.stringify还有一个可选参数space用来指定输出的缩进格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br><span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,<br><span class="hljs-attr">c</span>: <span class="hljs-string">&quot;42&quot;</span>,<br><span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;---------&#x27;</span>);<br><br><br></code></pre></td></tr></table></figure><h2 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h2><p>true转换为1，false转换为0，undefined转换为NaN，null转为0</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">Number</span>(&quot;&quot;);  <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Number</span>([]);  <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Number</span>([&quot;abc&quot;]);  <span class="hljs-comment">// NaN</span><br><br></code></pre></td></tr></table></figure><h2 id="奇特的～运算符"><a href="#奇特的～运算符" class="headerlink" title="奇特的～运算符"></a>奇特的～运算符</h2><p>字位运算只适用于32位整数，运算符将会强制操作数使用32位格式。 ToInt32首先执行ToNumber 然后执行ToInt32，虽然严格来说并非强制类型转换，但是字位运算符和一些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字<br>例如<code>|</code>的空操作,会将后面转为数字</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>| -<span class="hljs-number">0</span>;        // <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>| NaN;       // <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>| Infinity;  //<span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>| -Infinity; //<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>简单来说～ 可以理解为<code>-(x+1)</code>， </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">～<span class="hljs-number">42</span>; <span class="hljs-regexp">//</span> -<span class="hljs-number">43</span><br><br>~-<span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><br>var a = <span class="hljs-string">&quot;Hello world&quot;</span>;<br><br>~a.indexOf(<span class="hljs-string">&quot;lo&quot;</span>);  <span class="hljs-regexp">//</span> -<span class="hljs-number">4</span><br><br>~a.indexOf(<span class="hljs-string">&quot;ol&quot;</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span>(!~a.indexOf(<span class="hljs-string">&quot;ol&quot;</span>)) &#123;<br><span class="hljs-regexp">//</span> 无匹配<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="字位截取"><a href="#字位截取" class="headerlink" title="~~字位截取"></a>~~字位截取</h2><p>有些开发人员使用<code>~~</code>来借去数字值的消暑部分，以为这和Math.floor的效果一样，实际上并非如此<br>~~它首先只适用于32位数字，更重要的是它对负数的处理和Math.floor不同。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Math.floor(-<span class="hljs-number">49.6</span>); <span class="hljs-regexp">//</span> -<span class="hljs-number">50</span>  <br>~~-<span class="hljs-number">49.6</span>;      <span class="hljs-regexp">//</span> -<span class="hljs-number">49</span> 该方法会舍弃<br><br></code></pre></td></tr></table></figure><h2 id="显示解析数字字符串"><a href="#显示解析数字字符串" class="headerlink" title="显示解析数字字符串"></a>显示解析数字字符串</h2><p>parseInt是解析，允许字符串中出现非数字字符，解析从左到右遇到非数字字符就停止。而转换Number不允许出现非数字字符，否则会失败并返回NaN</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var a = <span class="hljs-string">&quot;42&quot;</span>;<br>var b = <span class="hljs-string">&quot;42px&quot;</span>;<br><br><span class="hljs-constructor">Number(<span class="hljs-params">a</span>)</span>; <span class="hljs-comment">// 42</span><br>parse<span class="hljs-constructor">Int(<span class="hljs-params">a</span>)</span>; <span class="hljs-comment">// 42</span><br><br><span class="hljs-constructor">Number(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">// NaN</span><br>parse<span class="hljs-constructor">Int(<span class="hljs-params">b</span>)</span> <span class="hljs-comment">// 42</span><br><br></code></pre></td></tr></table></figure><p>parseInt和parseFloat是针对字符串值，所以传递其他类型的值是没有用的，他们会被强制类型转换成字符串。</p><p>ES5之前的一个坑就是如果没有指定第二个参数来给定转换基数，则会以第一个参数的第一个字符来自行决定。如果第一个字符是 x 或者 X 则转换为十六进制， 如果是0则转换为八进制。</p><p>如下代码如果值为08:09 ,转换后的值为0:0 因为 8 和 9 都不是有效的八进制数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>var hour = parse<span class="hljs-constructor">Int(<span class="hljs-params">selectHour</span>.<span class="hljs-params">value</span>)</span>;<br>var minute = parse<span class="hljs-constructor">Int(<span class="hljs-params">selectMinute</span>.<span class="hljs-params">value</span>)</span>;<br><br></code></pre></td></tr></table></figure><p>将第二个参数设置为10即可避免这个问题</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var hour = parse<span class="hljs-constructor">Int(<span class="hljs-params">selectHour</span>.<span class="hljs-params">value</span>, 10)</span>;<br>var minute = parse<span class="hljs-constructor">Int(<span class="hljs-params">selectMinute</span>.<span class="hljs-params">value</span>, 10)</span>;<br><br></code></pre></td></tr></table></figure><p>幸运的是从ES5开始<code>parseInt(...)</code>默认转换为十进制， 除非另外指定。如果你的代码在ES5之前的环境运行，请记得将第二个值设置为10.</p><p>有这样一个坑</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">parseInt</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>, <span class="hljs-number">19</span>); // <span class="hljs-number">18</span><br><br></code></pre></td></tr></table></figure><p>这里parseInt接收字符串参数, 所以 Infinity 被转换为 “Infinity”; 19也不是一个正规的基数，所以这里其实是在转换 parseInt(“Infinity”, 19);</p><p>按照十六进制表示规则 a =&gt; 10, b =&gt; 11, c =&gt; 12, … i =&gt; 18 … z =&gt; 35; 基数是19所有小于19的字母都是有效数字。</p><p>此外还有一些看起来奇怪但是解释的通的例子</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这个例子 小数点后六位之前转为 <span class="hljs-number">0</span><br>parseInt(<span class="hljs-number">0.000008</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>    <br><span class="hljs-regexp">//</span>但是小数点后七位就转为 <span class="hljs-number">8</span>e-<span class="hljs-number">7</span> 再转字符串<span class="hljs-string">&quot;8e-7&quot;</span> <span class="hljs-number">8</span>是有效数字<br>parseInt(<span class="hljs-number">0.0000008</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">8</span><br><br><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;fa&quot;</span>都是有效数字 f = <span class="hljs-number">15</span> a = <span class="hljs-number">10</span>;  <span class="hljs-number">15</span> * <span class="hljs-number">16</span> + <span class="hljs-number">10</span> = <span class="hljs-number">250</span><br>parseInt(false, <span class="hljs-number">16</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">250</span><br><br><span class="hljs-regexp">//</span>parseInt.toString()<br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;function parseInt() &#123; [native code] &#125;&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;f&quot;</span>解析位<span class="hljs-number">16</span>进制的<span class="hljs-number">15</span><br>parseInt(parseInt, <span class="hljs-number">16</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">15</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">16</span>进制的<span class="hljs-number">10</span> 就是<span class="hljs-number">16</span><br>parseInt(<span class="hljs-string">&quot;0x10&quot;</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">16</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span>不是有效的二进制， 只解析 <span class="hljs-number">10</span>, <span class="hljs-number">2</span>进制的<span class="hljs-number">10</span>  就是十进制的<span class="hljs-number">2</span><br>parseInt(<span class="hljs-string">&quot;103&quot;</span>, <span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><br><br></code></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p><code>null</code>和<code>undefined</code> 之间<code>==</code>比较</p><ul><li>如果x为null， y是undefined 结果为true</li><li>如果x为undefined， y是null 结果为true</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> b;<br><br>a == b;    <span class="hljs-comment">// true</span><br>a == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span><br>b == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span><br><br>a == <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span><br>b == <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span><br>a == <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">// false</span><br>b == <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">// false</span><br>a == <span class="hljs-number">0</span>;     <span class="hljs-comment">// false</span><br>b == <span class="hljs-number">0</span>;     <span class="hljs-comment">// false</span><br><br><br><span class="hljs-keyword">var</span> a = doSomething();<br><br><span class="hljs-keyword">if</span>(a == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//...</span><br>&#125;<br>条件判断 a == <span class="hljs-literal">null</span> 仅在 doSomething() 返回 <span class="hljs-literal">null</span> 和 <span class="hljs-literal">undefined</span>时才成立，除此之外其他值不成立包括<span class="hljs-number">0</span>, <span class="hljs-literal">false</span> 和<span class="hljs-string">&quot;&quot;</span>这样的假植<br><br></code></pre></td></tr></table></figure><p>对象和非对象之间的比较</p><ul><li>如果Type(x)是字符串或者数字， Type(y)是对象， 则返回 x == ToPrimitive(y)的结果</li><li>如果Type(x)是对象， Type(y)是字符串或者数字， 则返回 ToPrimitive(x) == y的结果</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">42</span><span class="hljs-comment">;</span><br>var b <span class="hljs-operator">=</span> [<span class="hljs-number">42</span>]<span class="hljs-comment">;</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b<span class="hljs-comment">; // true</span><br><br><br><br>var a <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>var b <span class="hljs-operator">=</span> Object(a)<span class="hljs-comment">;  // 和 new String(a) 一样</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b<span class="hljs-comment">;  // true</span><br><br></code></pre></td></tr></table></figure><p>但是有一些值不这样， 原因是==算法中其他优先级更高的规则</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><br>var a <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>var b <span class="hljs-operator">=</span> Object(a)<span class="hljs-comment">; // 和Object()一样</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b<span class="hljs-comment">;  // false</span><br><br><br>var c <span class="hljs-operator">=</span> undefined<span class="hljs-comment">;</span><br>var d <span class="hljs-operator">=</span> Object(c)<span class="hljs-comment">; // 和Object一样</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> d<span class="hljs-comment">; // false</span><br><br><br>var e <span class="hljs-operator">=</span> NaN<span class="hljs-comment">;</span><br>var f <span class="hljs-operator">=</span> Object(e)<span class="hljs-comment">; // 和new Number(e)一样</span><br><br><span class="hljs-attribute">e</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> f<span class="hljs-comment">; // false</span><br><br></code></pre></td></tr></table></figure><p>因为没有对应的封装对象所以null和undefined不能够被封装， <code>Object(null)</code>, <code>Object(undefined)</code>，都返回一个常规对象。NaN能被封装为数字封装对象，但是拆封之后NaN == NaN返回false， 因为NaN不等于NaN。</p><p>比较少见的情况<br>2 == 3 不会有这种情况， new Number会调用valueOf</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Numebr</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span>; <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p>假值相等比较</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-string">&quot;0&quot;</span> == null;      <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&quot;0&quot;</span> == undefined; <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&quot;0&quot;</span> == false;     <span class="hljs-regexp">//</span> true<br><span class="hljs-string">&quot;0&quot;</span> == NaN;       <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-number">0</span>;        <span class="hljs-regexp">//</span> true<br><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-string">&quot;&quot;</span>;       <span class="hljs-regexp">//</span> false<br><br><br><br>false == null;      <span class="hljs-regexp">//</span> false<br>false == undefined; <span class="hljs-regexp">//</span> false<br>false == NaN;       <span class="hljs-regexp">//</span> false<br>false == <span class="hljs-number">0</span>;        <span class="hljs-regexp">//</span> true<br>false == <span class="hljs-string">&quot;&quot;</span>;       <span class="hljs-regexp">//</span> true<br>false == [];       <span class="hljs-regexp">//</span> true<br>false == &#123;&#125;;       <span class="hljs-regexp">//</span> false<br><br><br><br><span class="hljs-string">&quot;&quot;</span> == null;      <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&quot;&quot;</span> == undefined; <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&quot;&quot;</span> == NaN;       <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&quot;&quot;</span> == <span class="hljs-number">0</span>;        <span class="hljs-regexp">//</span> true<br><span class="hljs-string">&quot;&quot;</span> == [];       <span class="hljs-regexp">//</span> true<br><span class="hljs-string">&quot;&quot;</span> == &#123;&#125;;       <span class="hljs-regexp">//</span> false<br><br><br><span class="hljs-number">0</span> == null;      <span class="hljs-regexp">//</span> false<br><span class="hljs-number">0</span> == undefined; <span class="hljs-regexp">//</span> false<br><span class="hljs-number">0</span> == NaN;       <span class="hljs-regexp">//</span> false<br><span class="hljs-number">0</span> == [];       <span class="hljs-regexp">//</span> true<br><span class="hljs-number">0</span> == &#123;&#125;;       <span class="hljs-regexp">//</span> false<br><br><br>这个最好<br><br>[] == ![]  <span class="hljs-regexp">//</span> true<br><br><span class="hljs-number">2</span> == [<span class="hljs-number">2</span>] <span class="hljs-regexp">//</span> true<br><span class="hljs-string">&quot;&quot;</span> == [null] <span class="hljs-regexp">//</span> true<br><br><span class="hljs-number">0</span> == <span class="hljs-string">&quot;\n&quot;</span>   <span class="hljs-regexp">//</span> true<br><br></code></pre></td></tr></table></figure><p>抽象关系的比较</p><p>双方先调用toPrimitive，如果结果出现非字符串，就根据toNumber规则将双方强制转换为数字进行比较</p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cal"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">42</span>];<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;43&quot;</span>;<br><br>a &lt; b; // <span class="hljs-literal">true</span><br>b &lt; a; // <span class="hljs-literal">false</span><br><br>如果双方都是字符串，则按照字母顺序比较<br><br><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&quot;42&quot;</span>];<br><span class="hljs-keyword">var</span> b = [<span class="hljs-string">&quot;043&quot;</span>];<br><br>a &lt; b;  // <span class="hljs-literal">false</span><br>a和b不转为数字，因为你toPrimitive返回的字符串这里比较的是<span class="hljs-string">&quot;42&quot;</span> 和 <span class="hljs-string">&quot;043&quot;</span>两个字符串，比较的是<span class="hljs-string">&quot;4&quot;</span> 和<span class="hljs-string">&quot;0&quot;</span> <br><br><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">var</span> b = [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>];<br><br>a &lt; b; // <span class="hljs-literal">false</span>  比较 <span class="hljs-string">&quot;4, 2&quot;</span> 和 <span class="hljs-string">&quot;0, 4, 3&quot;</span>的首字母<br><br><span class="hljs-keyword">var</span> a = &#123; b: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">var</span> b = &#123; b: <span class="hljs-number">43</span> &#125;;<br><br>a &lt; b;  // <span class="hljs-literal">false</span> 转为<span class="hljs-string">&quot;[object Object]&quot;</span> 和<span class="hljs-string">&quot;[object Object]&quot;</span>所以按照字母顺序比较并不成立<br><br><br></code></pre></td></tr></table></figure><p>下面的例子比较奇怪</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = &#123; b: <span class="hljs-number">42</span> &#125;;<br>var b = &#123; b: <span class="hljs-number">43</span> &#125;;<br><br>a &lt; b; <span class="hljs-regexp">//</span> false<br><br>a == b; <span class="hljs-regexp">//</span> false<br><br>a &gt; b; <span class="hljs-regexp">//</span> false<br><br>a &lt;= b; <span class="hljs-regexp">//</span> true<br>a &gt;= b; <span class="hljs-regexp">//</span> true<br><br><br></code></pre></td></tr></table></figure><p>根据规范 a &lt;=b 被处理成 !(a &gt; b)</p><h2 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h2><p>表达式的副作用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">var</span> b = a++;<br><br>a; <span class="hljs-comment">// 43</span><br><br>b; <span class="hljs-comment">// 42</span><br><br><br></code></pre></td></tr></table></figure><p>标签表达式 break; continue;</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript上卷</title>
    <link href="/2018/10/08/2018-10-08-read-book-you-known-up-one/"/>
    <url>/2018/10/08/2018-10-08-read-book-you-known-up-one/</url>
    
    <content type="html"><![CDATA[<p>本书是读完 Effective JavaScript之后开的进行的阅读，整理自己需要注意的点。方便以后巩固。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JavaScript没有块级作用域的相关功能。但是使用<code>with</code>、<code>try...catch</code>可以创建块级作用域</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>提升时函数优先</p><figure class="highlight arcade"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs arcade">foo();<br><br><span class="hljs-keyword">var</span> foo;<br><br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输入结果是1，函数声明优先，同名的var变量会被忽略，但是后面的重新赋值仍然有效，第二次执行foo得到的结果就是2了。</p><h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>  &#125;<br><br>  bar();<br>&#125;<br><br>foo();<br><br></code></pre></td></tr></table></figure><p>这个是闭包吗？ 从技术上来讲，也许是。但是确切的说不是。准确的说bar()对a的引用方法是词法作用域的查找规则，这些规则只是闭包的一部分。但确实是非常重要的一部分。</p><p>来看一个清晰的闭包例子</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> bar;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> baz = foo();<br><br>baz(); <span class="hljs-comment">// 2  这是一个闭包的效果</span><br></code></pre></td></tr></table></figure><p>函数 bar() 的词法作用域能够访问foo() 的内部作用域。然后我们将bar()函数本身当作一个值类型进行传递， 在这个例子中，我们将bar所引用的函数对象本身当作返回值。</p><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>JavaScript只有词法作用域，并没有动态作用域</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  foo();<br>&#125;<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>bar();  <span class="hljs-comment">// 输出结果为2</span><br><br></code></pre></td></tr></table></figure><p>词法作用域，让foo在查找a时，只在全局作用域找到 <code>var a = 2</code>, 所以这里显示2。 这里可能会疑惑为什么没有找到bar方法内部， 因为这里只是执行foo方法，如果像下面这样写，才会读到a = 3</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>  &#125;<br><br>  foo();<br>&#125;<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>bar();<br><br><br></code></pre></td></tr></table></figure><h2 id="块级作用域的替代方案"><a href="#块级作用域的替代方案" class="headerlink" title="块级作用域的替代方案"></a>块级作用域的替代方案</h2><p>ES5之前块级作用域的解决方案catch或with</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span>&#123; <span class="hljs-keyword">throw</span> <span class="hljs-number">2</span> &#125; <span class="hljs-keyword">catch</span>(a)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// 2</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><br></code></pre></td></tr></table></figure><p>let作用域或着let声明还可以这样用</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let(a = <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 2</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// ReferenceError</span><br><br></code></pre></td></tr></table></figure><p>与隐式的劫持一个已经存在的作用域不同， let声明会显示的创建一个作用域并与其进行绑定。显示作用域不仅更突出，在代码重构时也表现更加健壮。<br>但是ES6语法不包含这个我们可以选择，合法的ES6语法，</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>  let a <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>  console.log(a)<span class="hljs-comment">;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>还可以选择使用bable转换器 let-er这个转换器然后开启 这个设置项 。这样就可以直接使用了。</p><h2 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h2><p>为什么要使用this？ this提供了一种更优雅的方式来隐式的传递对象引用，因此可以将API设计的更加简洁并且易于复用。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo:&quot;</span> + num);<br>  this.<span class="hljs-built_in">count</span>++;<br>&#125;<br><br>foo.<span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> i;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">5</span>) &#123;<br>    foo(i);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//foo: 6</span><br><span class="hljs-comment">//foo: 7</span><br><span class="hljs-comment">//foo: 8</span><br><span class="hljs-comment">//foo: 9</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo.<span class="hljs-built_in">count</span>); <span class="hljs-comment">// 0</span><br><br></code></pre></td></tr></table></figure><p>这里的this并没有指向自身， foo被当作方法调用时，this代表的是函数的接收者。 这里非严格模式下指向的是全局对象，然而全局对象进行++运算结果是NaN，foo.count作为foo这个函数对象的一个属性从来没有改变过。</p><p>我们可以这样来改进x</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo:&quot;</span> + num);<br>  data.<span class="hljs-built_in">count</span>++;<br>&#125;<br><br><span class="hljs-keyword">var</span> data = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">var</span> i;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">5</span>) &#123;<br>    foo(i);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//foo: 6</span><br><span class="hljs-comment">//foo: 7</span><br><span class="hljs-comment">//foo: 8</span><br><span class="hljs-comment">//foo: 9</span><br><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo.<span class="hljs-built_in">count</span>); <span class="hljs-comment">// 4</span><br><br></code></pre></td></tr></table></figure><p>这样貌似解决了问题，但是忽略了真正的问题，无法理解this的含义和工作原理而是返回了舒适区。</p><p>另一种结局方案是使用foo标识符来替代this引用函数对象，但是同样回避了this的问题，并且完全依赖于变量foo的词法作用域</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo:&quot;</span> + num);<br>  foo.<span class="hljs-built_in">count</span>++;<br>&#125;<br><br>foo.<span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> i;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">5</span>) &#123;<br>    foo(i);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//foo: 6</span><br><span class="hljs-comment">//foo: 7</span><br><span class="hljs-comment">//foo: 8</span><br><span class="hljs-comment">//foo: 9</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo.<span class="hljs-built_in">count</span>); <span class="hljs-comment">// 4</span><br><br></code></pre></td></tr></table></figure><p>我们可以强制使用this执行foo函数对象</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo:&quot;</span> + num);<br>  data.<span class="hljs-built_in">count</span>++;<br>&#125;<br><br><span class="hljs-keyword">var</span> data = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">var</span> i;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">5</span>) &#123;<br>    foo.call(foo,i);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//foo: 6</span><br><span class="hljs-comment">//foo: 7</span><br><span class="hljs-comment">//foo: 8</span><br><span class="hljs-comment">//foo: 9</span><br><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo.<span class="hljs-built_in">count</span>); <span class="hljs-comment">// 4</span><br><br></code></pre></td></tr></table></figure><h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>这是最常用的函数调用类型，独立函数调用。 这种情况this默认指向了全局对象</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>foo(); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br>obj.foo(); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><p>这种方式加上了对于obj对象的引用，拥有了上下文，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上细纹对象。</p><p>对象属性的引用链只有上一层或者说最后一层在调用位置中起作用。举例来说：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">obj2</span>: obj2<br>&#125;<br><br><br>obj1.obj2.foo(); <span class="hljs-comment">// 42  最后一个obj2起作用</span><br><br><br></code></pre></td></tr></table></figure><p>一个最常见的this对象绑定问题就是隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而吧this绑定到全局对象或着<code>undefined</code>这取决于是否是严格模式</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><br><span class="hljs-keyword">var</span> bar = obj.foo;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>;<br><br>bar(); <span class="hljs-comment">// oops, global</span><br></code></pre></td></tr></table></figure><p>还有一种，参数传递也是一种隐式赋值，因此我们穿日函数时也会被隐式赋值</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123;<br>  fn();<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><br><span class="hljs-keyword">var</span> bar = obj.foo;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>;<br><br>doFoo(obj.foo); <span class="hljs-comment">// oops, global</span><br><br></code></pre></td></tr></table></figure><p>同理如果向setTimeout中传递函数对象，同样会丢失this。</p><h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>显示绑定通常使用 <code>call</code>、<code>apply</code>、<code>bind</code>，这些方式来实现。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><br>foo.call(obj);<br><br></code></pre></td></tr></table></figure><p>foo.call(…)， 我们可以调用foo时强制把它的this绑定到obj上。</p><p>可惜的是显示绑定仍然无法解决我们之前提出的丢失绑定的问题。但是显示绑定的一个变种可以帮我们解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  foo.<span class="hljs-title function_">call</span>(obj);<br>&#125;<br><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">setTimeout</span>(bar, <span class="hljs-number">100</span>); <span class="hljs-comment">// 2</span><br><br>bar.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">window</span>); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><p>硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a, something);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> foo.apply(obj, arguments);<br>&#125;<br><br><br><span class="hljs-keyword">var</span> b = bar(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2, 3</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);  <span class="hljs-comment">// 5</span><br><br></code></pre></td></tr></table></figure><p>另一种使用方法是创建一个可以重复使用的辅助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    fn.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>(foo, obj);<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2 3</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 5</span><br><br><br></code></pre></td></tr></table></figure><p>由于硬绑定是一种非常常用的模式，所以ES5提供了内置的方法<code>Function.ptototype.bind</code>，它的用法如下</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>  <span class="hljs-keyword">return</span> this.a + something;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = foo.bind(obj);<br><br><span class="hljs-keyword">var</span> b = bar(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2 3</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 5</span><br><br><br></code></pre></td></tr></table></figure><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>虽然JavaScript中也有new操作符，使用方法看起来跟那些面向类的语言意义，绝大多数开发者都认为JavaScript中的new的机制也跟那些语言一样，然而JavaScript中的new机制实际上跟面向类的语言完全不同。</p><ul><li>构造函数 首先JavaScript中的构造函数只是使用new操作符调用的函数，它们并不会属于某个类，也不会实例化一个类，实际上它们甚至不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。 函数被使用new操作符调用成为构造函数调用，实际上不存在所谓的构造函数，只有对于函数的构造调用。</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  this.a = a;<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo(<span class="hljs-number">2</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bar.a); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><p>我们创造了一个新的对象，并把它绑定到foo调用中的this上。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>显示绑定比隐式绑定优先级要高， new绑定比隐式绑定优先级要高， 但是new绑定会得到一个新的对象。</p><h2 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h2><ul><li><p>函数是否在new中调用， 如果是的话this绑定的是新创建的对象。</p></li><li><p>函数是否通过<code>call</code>，<code>apply</code>,或者硬绑定调用，如果是的话this是指定的对象</p></li><li><p>函数是否在某个上下文对象中（隐式绑定）如果是的话，this绑定的是上下文对象。</p></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下绑定到undefined， 否则绑定到全局对象。</p></li></ul><h2 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h2><p>如果你把null或undefined作为this绑定对象传入call，apply或者bind，这些值会在调用时被忽略，实际应用的是默认绑定规则</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>foo.call(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><p>使用null忽略this可能产生一些副作用，如果某个函数确实使用了this（比如第三方库的一个函数）， 那默认绑定规则会把this绑定到全局对象。这将导致不可预计的后果。<br>所以我们使用一个更安全的空对象<br>在JavaScript中创建一个空对象最简单的方法是Obejct.create(null), 它和{}很像，但是不会创建Object.ptototype，所以它比{}更空</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">option</span> + o<br>var ø = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(<span class="hljs-keyword">null</span>);<br><br><br></code></pre></td></tr></table></figure><h2 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h2><p>还有一个需要注意的情况你可能创建一个函数的间接引用，调用这个函数会应用默认绑定规则</p><p>间接引用最容易在赋值时发生</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">var</span> o = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> p = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">4</span><br>&#125;<br><br>o.foo(); <span class="hljs-comment">// 3</span><br><br>(p.foo = o.foo)(); <span class="hljs-comment">// 2</span><br><br><br></code></pre></td></tr></table></figure><p>赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo() 而不是p.foo()或者o.foo();</p><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p><code>self = this</code>和箭头函数看起来都可以取代bind但本质上想取代的是this机制。如果你经常编写this风格的代码，但是绝大部份都会是用self = this,或者箭头函数，那么你或许应该</p><ul><li>只使用此法作用域并且完全抛弃错误this风格代码;</li><li>完全采用this风格，在必要时使用bind，避免使用self = this 和 箭头函数。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在对象中，属性名永远都是字符串。使用非String作为属性名它首先会被转成一个字符串。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var myObject <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br><br>myObject[true] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-comment">;</span><br>myObject[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bar&quot;</span><span class="hljs-comment">;</span><br>myObject[myObject] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;baz&quot;</span><span class="hljs-comment">;</span><br><br><br>myObject[<span class="hljs-string">&quot;true&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-comment">;</span><br>myObject[<span class="hljs-string">&quot;3&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bar&quot;</span><span class="hljs-comment">;</span><br>myObject[<span class="hljs-string">&quot;[object OBject]&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;baz&quot;</span><span class="hljs-comment">;</span><br><br><br><br></code></pre></td></tr></table></figure><h3 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe">浅复制<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = Object.assign(&#123;&#125;, myObject);<br><br>深复制<br>对于JSON安全的对象来说有一种巧妙的复制方法<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span> = JSON.parse(JSON.stringify(someObj));<br><br></code></pre></td></tr></table></figure><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">myObject</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">a:</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-string">Object.getOwnPropertyDescriptor(myObject,</span> <span class="hljs-string">&quot;a&quot;</span><span class="hljs-string">);</span><br><br><span class="hljs-string">//</span> &#123;<span class="hljs-attr">value:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span>&#125;<br><br><span class="hljs-string">如果configurable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-string">则不可以再配置，也不可以被删除</span><br><br></code></pre></td></tr></table></figure><h3 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h3><p>结合writable: false 和configurable: false就可以创建一个真正的常量属性(不可以重新定义，修改，删除)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<br><br>Object.<span class="hljs-title function_ invoke__">defineProterty</span>(myObject, <span class="hljs-string">&quot;FAVORITE_NUMBER&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> <br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h3><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(…)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var myObject = &#123;<br>  a: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prevent<span class="hljs-constructor">Extensions(<span class="hljs-params">myObject</span>)</span>;<br><br>myObject.b = <span class="hljs-number">3</span>;<br><br>myObject.b; <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure><p>在非严格模式下，创建属性b会静默失败，在严格模式下，将会抛出TyperError错误。</p><h3 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h3><p>Object.seal(…)会创建一个”密封”对象，这个方法实际会在一个现有对象上调用Object.preventExtensions并把所有现有属性标记为configurable: false.<br>所有密封后不能添加新属性，也不能重新配置和删除任何现有属性(虽然可以修改属性的值)</p><h3 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h3><p><code>Object.freeze(...)</code>，会创建一个冻结对象，这个方法是在现有对象调用了<code>Object.seal</code>并把所有数据访问属性标记为 writable: false, 这样就无法修改它们的值</p><h3 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;b&quot;</span>, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> * <span class="hljs-number">2</span>;<br>  &#125;,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>  <br><br>&#125;);<br><br></code></pre></td></tr></table></figure><p>通常get和set是成对出现的，只定义一个的话通常会产生意料之外的行为。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">var</span> myObject = &#123;<br>  <span class="hljs-keyword">get</span> a() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._a_;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> a(<span class="hljs-keyword">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._a_ = <span class="hljs-keyword">val</span> * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><br>myObject.a = <span class="hljs-number">2</span>;<br><br>myObject.a; <span class="hljs-comment">// 4</span><br><br><br></code></pre></td></tr></table></figure><h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>前面说过 如果本身对象中有值为undefiend的属性obj.a, 去获取该值得到的结果跟去获取一个不存在的属性结果是一样的，比如obj.b， 那么如果判断一个属性在对象中是否存在呢</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>var myObject = &#123;<br>  a: <span class="hljs-number">2</span><br>&#125;<br><br>(a <span class="hljs-keyword">in</span> myObject); <span class="hljs-regexp">//</span> true<br>(b <span class="hljs-keyword">in</span> myObject); <span class="hljs-regexp">//</span> false<br><br>myObject.hasOwnProperty(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-regexp">//</span> true<br>myObject.hasOwnProperty(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-regexp">//</span> false<br><br><br></code></pre></td></tr></table></figure><p>in操作符会检查属性是否存在对象及其[[prototype]]原型中，相比之下hasOwnProperty只会检查属性是否存在myObject对象中。</p><p>要注意的是in操作符检查的是容器内是否有某个值，实际上检查的是某个属性名是否存在。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">4</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]; <span class="hljs-regexp">//</span> false<br>这个数组包含的属性名其实是<span class="hljs-number">0</span> ，<span class="hljs-number">1</span>，<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p>是否可通过for…in操作符来枚举可以通过定义属性是设定</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk">var myObject = &#123;&#125;;<br><br>Object.defineProperty(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;<br>  enumerable: true, value: <span class="hljs-number">2</span>  <br>&#125;);<br><br>Object.defineProperty(myObject, <span class="hljs-string">&quot;b&quot;</span>, &#123;<br>  enumerable: false, value: <span class="hljs-number">3</span><br>&#125;);<br><br><br>myObject.b; <span class="hljs-regexp">//</span><span class="hljs-number">3</span><br>&#123;<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject&#125;; <span class="hljs-regexp">//</span>true<br>myObject.hasOwnProperty(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-regexp">//</span>true<br><br><br><span class="hljs-keyword">for</span>(var k <span class="hljs-keyword">in</span> myObject) &#123;<br>  console.log(k, myObject[k]);<br>&#125;<br><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-number">2</span><br><br>还可以通过另一种方式来区分属性是否可枚举<br><br>propertyIsEnumerable 会检查属性是否存在于对象中(而不是在原型链中)并且满足enumerable: true<br>Object.keys会返回一个数组，包含所有可枚举属性<br>Object.getOwnPropertyNames 返回一个数组包含所有属性无论是否可枚举<br><br>myObject.propertyIsEnumerable(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-regexp">//</span> true<br><br>myObject.propertyIsEnumerable(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-regexp">//</span> false<br><br>Object.keys(myObject); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>]<br><br>Object.getOwnPropertyNames(myObject); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br><br></code></pre></td></tr></table></figure><p>Object.keys 和Object.getOwnPropertyNames 都不回查找原型链，只会查找对象直接包含的属性</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>我们通常会通过<code>for...in</code>来遍历一个对象，但是这样便利对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样，因此在不同的环境中需要保持一致性时，一定不要相信任何观察到顺序，它们是不可靠的<br>那么如何直接遍历值而不是数组下标呢</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v of myArray) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(v);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为数组有内置的@iterator, 因此for…of可以直接应用到数组上。</p><p>我们可以使用内置的@@iterator来手动遍历数组， ES6中我们使用Symbol.iterator来获取对象的@@iterator内部属性</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">var myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br><br>var it = myArray[Symbol.iterator]();<br><br>it.<span class="hljs-keyword">next</span>();  <span class="hljs-regexp">//</span> &#123;value: <span class="hljs-number">1</span>, done: false&#125;<br><br>it.<span class="hljs-keyword">next</span>();  <span class="hljs-regexp">//</span> &#123;value: <span class="hljs-number">3</span>, done: false&#125;<br><br>it.<span class="hljs-keyword">next</span>();  <span class="hljs-regexp">//</span> &#123;value: <span class="hljs-number">5</span>, done: false&#125;<br><br>it.<span class="hljs-keyword">next</span>();  <span class="hljs-regexp">//</span> &#123;value: undefined, done: undefined&#125;<br><br></code></pre></td></tr></table></figure><p>和数组不同普通的对象没有内置的@@iterator,所以无法自动完成for…of遍历，之所以这样做有许多非常复杂的原因， 简单来说，这样做是为了避免影响未来的对象类型.</p><p>当然我们可以给任何想遍历的对象定义@@iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> myObject = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> ks = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(o);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: o[ks[idx++]];<br>          <span class="hljs-attr">done</span>: (idx &gt; ks.<span class="hljs-property">length</span>)<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;  <br>&#125;);<br><br>这样手动遍历<br><br><span class="hljs-keyword">var</span> it = myObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value:2, done: false&#125;</span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value:3, done: false&#125;</span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myObject) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="原型风格继承"><a href="#原型风格继承" class="headerlink" title="原型风格继承"></a>原型风格继承</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Foo(<span class="hljs-params">name</span>)</span> &#123;<br>  this.name = name;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>prototype.myName = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  return this.name;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Bar(<span class="hljs-params">name</span>, <span class="hljs-params">label</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>call(this, name);<br><br>  this.label = label;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bar</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>prototype);<br><span class="hljs-comment">// 这里还可以用这种写法，ES6 的 Object.setPrototypeOf  下面的写法更好一点， 当时上面的写法更容易理解</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(Bar.<span class="hljs-params">prototype</span>, Foo.<span class="hljs-params">prototype</span>)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bar</span>.</span></span>prototype.myLabel = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  return this.label;<br>&#125;<br><br>var a = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bar(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;obj a&quot;</span>)</span>;<br><br>a.my<span class="hljs-constructor">Name()</span>; <span class="hljs-comment">// &quot;a&quot;</span><br><br>a.my<span class="hljs-constructor">Label()</span>; <span class="hljs-comment">// &quot;obj a&quot;</span><br><br><br>该方法比较有用，<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>prototype是否出现在a的<span class="hljs-literal">[[<span class="hljs-identifier">prototype</span>]</span>]链中<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>prototype.is<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">a</span>)</span>;<br><br></code></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>基于委托实现与上面相同功能的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-title class_">Foo</span> = &#123;<br>  <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span> = who;<br>  &#125;,<br>  <span class="hljs-attr">identify</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Bar</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Foo</span>);<br><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">identify</span>() + <span class="hljs-string">&quot; . &quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">var</span> b1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Bar</span>);<br>b1.<span class="hljs-title function_">init</span>(<span class="hljs-string">&quot;b1&quot;</span>);<br><br><span class="hljs-keyword">var</span> b2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Bar</span>);<br>b2.<span class="hljs-title function_">init</span>(<span class="hljs-string">&quot;b2&quot;</span>);<br><br>b1.<span class="hljs-title function_">speak</span>();<br>b2.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>通过比较发现， 对象关联风格的代码更加简洁，因为这种风格的代码只关注一件事， 对象之间的关联关系。</p><h2 id="更简洁的设计"><a href="#更简洁的设计" class="headerlink" title="更简洁的设计"></a>更简洁的设计</h2><p>一个关于登陆验证器的设计</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>function Controller() &#123;<br>  <span class="hljs-keyword">this</span>.errors= [];<br>&#125;<br><br>Controller.prototype.showDialog = function(title, msg) &#123;<br>  <span class="hljs-comment">// 显示给用户的消息</span><br>&#125;<br><br>Controller.prototype.success = function(msg) &#123;<br>  <span class="hljs-keyword">this</span>.showDialog(<span class="hljs-string">&quot;success&quot;</span>, msg);<br>&#125;<br><br>Controller.prototype.failure = function(err) &#123;<br>  <span class="hljs-keyword">this</span>.errors.push(err);<br><br>  <span class="hljs-keyword">this</span>.showDialog(<span class="hljs-string">&quot;Error&quot;</span>, err);<br>&#125;<br><br><br>function LoginController() &#123;<br>  Controller.call(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>LoginController.prototype = Object.create(Controller.prototype);<br><br>LoginController.prototype.getUser = function() &#123;<br>  <span class="hljs-keyword">return</span> document.getElementById(<span class="hljs-string">&quot;login_username&quot;</span>).value;<br>&#125;<br><br>LoginController.prototype.getPassword = function() &#123;<br>  <span class="hljs-keyword">return</span> document.getElementById(<span class="hljs-string">&quot;login_password&quot;</span>).value;<br>&#125;<br><br><br>LoginController.prototype.validateEntry = function(user, pw) &#123;<br>  user = user || <span class="hljs-keyword">this</span>.getUser();<br>  pw = pw || <span class="hljs-keyword">this</span>.getPassword();<br><br>  <span class="hljs-keyword">if</span>(!(user &amp;&amp; pw)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.failure(<span class="hljs-string">&quot;Please enter a username &amp; password&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pw.length &lt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.failure(<span class="hljs-string">&quot;Password must be 5+ character!&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>LonginController.prototype.failure = function() &#123;<br>  Controller.prototype.failure.call(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Login invalid: &quot;</span> + err);<br>&#125;<br><br><br><br><br>function AuthController(login) &#123;<br>  Controller.call(<span class="hljs-keyword">this</span>);<br><br>  <span class="hljs-keyword">this</span>.login = login;<br>&#125;<br><br>AuthController.prototype = Object.create(Controller.prototype);<br><br>AuthController.prototype.server = function(url, <span class="hljs-keyword">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> $.ajax(&#123;<br>    url: url,<br>    <span class="hljs-keyword">data</span>: <span class="hljs-keyword">data</span><br>  &#125;);<br>&#125;<br><br>AuthController.prototype.checkAuth = function() &#123;<br>  <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">this</span>.login.getUser();<br>  <span class="hljs-keyword">var</span> pw = <span class="hljs-keyword">this</span>.login.getPassword();<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.login.validateEntry(user, pw)) &#123;<br>    <span class="hljs-keyword">this</span>.server(<span class="hljs-string">&quot;/check-auth&quot;</span>, &#123;<br>      user: user,<br>      pw: pw<br>    &#125;)<br>    .then(<span class="hljs-keyword">this</span>.success.bind(<span class="hljs-keyword">this</span>));<br>    .fail(<span class="hljs-keyword">this</span>.failure.bind(<span class="hljs-keyword">this</span>));<br>  &#125;<br>&#125;<br><br><br>AuthController.prototype.success = function() &#123;<br>  Controller.prototype.success.call(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Authenticated;&quot;</span>);<br>&#125;<br><br>AuthController.prototype.failure = function(err) &#123;<br>  Controller.prototype.failure.call(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Auth failed: &quot;</span> + err);<br>&#125;<br><br><br><span class="hljs-keyword">var</span> auth = new AuthController(new LoginController());<br><br>auth.checkAuth();<br><br></code></pre></td></tr></table></figure><p>反类，我们可以使用对象关联风格的行为委托来实现更简单的设计</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">var</span> LoginController = &#123;<br>  errors: [],<br>  getUser: function() &#123;<br>    <span class="hljs-keyword">return</span> document.getElementById(<span class="hljs-string">&quot;login_username&quot;</span>).value;<br>  &#125;,<br><br>  getPassword: function() &#123;<br>    <span class="hljs-keyword">return</span> document.getElementById(<span class="hljs-string">&quot;login_password&quot;</span>).value;<br>  &#125;,<br>  validateEntry: function(user, pw) &#123;<br>    user = user || <span class="hljs-keyword">this</span>.getUser();<br>    pw = pw || <span class="hljs-keyword">this</span>.getPassword();<br><br>    <span class="hljs-keyword">if</span>(!(user &amp;&amp; pw)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.failure(<span class="hljs-string">&quot;Please enter a username &amp; password&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pw.length &lt; <span class="hljs-number">5</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.failure(<span class="hljs-string">&quot;Password must be 5+ character!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>  showDialog: function() &#123;<br>    <span class="hljs-comment">// 给用户显示的消息</span><br>  &#125;,<br>  failure: function() &#123;<br>    <span class="hljs-keyword">this</span>.errors.push(err);<br>    <span class="hljs-keyword">this</span>.showDialog(<span class="hljs-string">&quot;Error&quot;</span>, <span class="hljs-string">&quot;Login invalid &quot;</span> + err);<br>  &#125;,<br>  success: function(msg) &#123;<br>    <span class="hljs-keyword">this</span>.showDialog(<span class="hljs-string">&quot;success&quot;</span>, msg);<br>  &#125;<br><br>&#125;<br><br><br><br><span class="hljs-keyword">var</span> AuthController = Object.create(LoginController);<br><br>AuthController.errors = [];<br><br>AuthController.checkAuth = function() &#123;<br>  <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">this</span>.getUser();<br>  <span class="hljs-keyword">var</span> pw = <span class="hljs-keyword">this</span>.getPassword();<br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.validateEntry(user, pw)) &#123;<br>    <span class="hljs-keyword">this</span>.server(<span class="hljs-string">&quot;/check-auth&quot;</span>, &#123;<br>      user: user,<br>      pw: pw  <br>    &#125;)<br>    .then(<span class="hljs-keyword">this</span>.accepted.bind(<span class="hljs-keyword">this</span>))<br>    .fail(<span class="hljs-keyword">this</span>.rejected.bind(<span class="hljs-keyword">this</span>));<br>  &#125;<br>&#125;<br><br>AuthController.server = function(url, <span class="hljs-keyword">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> $.ajax(&#123;<br>    url: url,<br>    <span class="hljs-keyword">data</span>: <span class="hljs-keyword">data</span>  <br>  &#125;)<br>&#125;<br><br>AuthController.accepted = function() &#123;<br>  <span class="hljs-keyword">this</span>.showDialog(<span class="hljs-string">&quot;Success&quot;</span>, <span class="hljs-string">&quot;Authenticated!&quot;</span>);<br>&#125;<br><br>AuthController.rejected = function(err) &#123;<br>  <span class="hljs-keyword">this</span>.failure(<span class="hljs-string">&quot;Auth Failed: &quot;</span> + err);<br>&#125;<br><br><br>AuthController.checkAuth();<br></code></pre></td></tr></table></figure><p>这种模式我们只需要两个实体LoginController 和 AuthController<br>总结： 我们用一种极其简单的设计实现了同样的功能， 这既是对象关联风格代码和行为委托设计模式的力量</p><h2 id="反词法"><a href="#反词法" class="headerlink" title="反词法"></a>反词法</h2><p>ES6简洁与法有一个非常小但重要的缺点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123;<br>  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">/**/</span>&#125;,<br>  <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">/**/</span>&#125;  <br>&#125;<br><br>去掉语法糖<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">/**/</span>&#125;<br>  <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">/**/</span>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于函数对象本身没有标识符， 所以bar()的缩写形式实际上会变成一个匿名函数表达式并赋值给bar属性。相比之下 具名函数表达式会额外的给.baz属性附加一个词法名称标识符baz。</p><p>匿名函数没有name标识符会导致</p><ul><li>调用栈更难追踪</li><li>自我引用（递归， 事件绑定和解除绑定）更难</li><li>代码稍微难理解</li></ul><p>这里只有第二个缺点无法避免，因此使用简洁语法一定要小心这一点。 如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁语法。</p><blockquote><p>再说一次，我们认为JavaScript种的对象关联比类风格代码更为简洁(而且功能相同)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (九)</title>
    <link href="/2018/09/28/2018-09-28-read-book-effective-nine/"/>
    <url>/2018/09/28/2018-09-28-read-book-effective-nine/</url>
    
    <content type="html"><![CDATA[<h2 id="保持一致的约定"><a href="#保持一致的约定" class="headerlink" title="保持一致的约定"></a>保持一致的约定</h2><h2 id="将undefined当作没有值"><a href="#将undefined当作没有值" class="headerlink" title="将undefined当作没有值"></a>将undefined当作没有值</h2><p>undefined很特殊，每当JavaScritp无法提供具体的值时，就产生undefined。为赋值的初始值即为undefiend</p><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> x;<br>x <span class="hljs-comment">// undefined;</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.x; <span class="hljs-comment">//undefined</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span><span class="hljs-params">()</span> &#123;&#125;<br><br><br>f();  <span class="hljs-comment">//undefined</span><br>f();  <span class="hljs-comment">//undefined</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">(x)</span> &#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br>f(); <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure><p>例如一个Web服务器可以接受一个可选的主机名称</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var s1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Server(80, <span class="hljs-string">&quot;example.com&quot;</span>)</span>;<br><br>var s2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Server(80)</span>; <span class="hljs-comment">//defaults to &quot;localhost&quot;</span><br><br>我们可以通过判断arguments.length来实现Server构造函数<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Server(<span class="hljs-params">port</span>, <span class="hljs-params">hostname</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(arguments.length &lt; <span class="hljs-number">2</span>) &#123;<br>hostname = <span class="hljs-string">&quot;localhost&quot;</span>;<br>&#125;<br><br>hostname = <span class="hljs-constructor">String(<span class="hljs-params">hostname</span>)</span>;<br>&#125;<br><br>这种情况如果第二个值是undefined的话可能会使用undefined，这并不是我们想要的所以我们最好判断undefined<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Server(<span class="hljs-params">port</span>, <span class="hljs-params">hostname</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(hostname<span class="hljs-operator"> === </span>undefined) &#123;<br>hostname = <span class="hljs-string">&quot;localhost&quot;</span>;<br>&#125;<br><br>host = <span class="hljs-constructor">String(<span class="hljs-params">hostname</span>)</span>;<br>&#125;<br><br><br>另一种合理的方式是测试hostname是否为真<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Server(<span class="hljs-params">port</span>, <span class="hljs-params">hostname</span>)</span> &#123;<br>hostname = <span class="hljs-constructor">String(<span class="hljs-params">hostname</span> <span class="hljs-operator">||</span> <span class="hljs-string">&quot;localhost&quot;</span>)</span>;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是最后一种的真值检测并不总是安全的，如果一个函数允许接受0(或NaN，虽然不常见)为可接受的参数,则不应该使用真值测试</p><p>比如</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-function">function <span class="hljs-title">Element</span><span class="hljs-params">(width, height)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.width = width || <span class="hljs-number">320</span>;<br><span class="hljs-keyword">this</span>.height = height || <span class="hljs-number">240</span>;<br><span class="hljs-comment">// ...</span><br>&#125;<br>var c1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Element</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <br>c1.width; <span class="hljs-comment">// 320</span><br>c1.height; <span class="hljs-comment">// 240</span><br><br><br>这种情况我们需要更详细的测试来测试<span class="hljs-function">undefined</span><br><span class="hljs-function">function <span class="hljs-title">Element</span><span class="hljs-params">(width, height)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.width = width === undefined ? <span class="hljs-number">320</span> : width;<br><span class="hljs-keyword">this</span>.height = height === undefined ? <span class="hljs-number">240</span> : height;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br><br>var c1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Element</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>c1.width; <span class="hljs-comment">// 0</span><br>c1.height; <span class="hljs-comment">// 0</span><br><br>var c2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Element</span>();<br>c2.width; <span class="hljs-comment">// 320</span><br>c2.height; <span class="hljs-comment">// 240</span><br><br></code></pre></td></tr></table></figure><h2 id="接受关键字参数的选项对象"><a href="#接受关键字参数的选项对象" class="headerlink" title="接受关键字参数的选项对象"></a>接受关键字参数的选项对象</h2><p>保持参数顺序的一致约定对于帮助程序员记住每个参数在函数调用中的意义是很重要的，参数较少时它是适用的。但是参数过多后根本不可扩展</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> alert = <span class="hljs-keyword">new</span> <span class="hljs-type">Alert</span>(<span class="hljs-number">100</span>, <span class="hljs-number">75</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>,<br><span class="hljs-string">&quot;Error&quot;</span>, message,<br><span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-string">&quot;black&quot;</span>,<br><span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-literal">true</span><br>);<br><br></code></pre></td></tr></table></figure><p>一个函数起初很简单，但是过一段时间，随着库功能的扩展，该函数的签名便会获得越来越多的参数。</p><p>幸运的是，JavaScrtip提供了一个简单、轻量的惯用法： 选项对象(options object).</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">alert</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">Alert(&#123;</span><br><span class="hljs-attr">x:</span> <span class="hljs-number">100</span><span class="hljs-string">,</span> <span class="hljs-attr">y:</span> <span class="hljs-number">75</span><span class="hljs-string">,</span><br><span class="hljs-attr">width:</span> <span class="hljs-number">300</span><span class="hljs-string">,</span> <span class="hljs-attr">height:</span> <span class="hljs-number">200</span><span class="hljs-string">,</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Error&quot;</span><span class="hljs-string">,</span> <span class="hljs-attr">message:</span> <span class="hljs-string">message,</span><br><span class="hljs-attr">titleColor:</span> <span class="hljs-string">&quot;blue&quot;</span><span class="hljs-string">,</span> <span class="hljs-attr">bgColor:</span> <span class="hljs-string">&quot;white&quot;</span><span class="hljs-string">,</span> <span class="hljs-attr">textColor:</span> <span class="hljs-string">&quot;black&quot;</span><span class="hljs-string">,</span><br><span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;error&quot;</span><span class="hljs-string">,</span> <span class="hljs-attr">modal:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">&#125;);</span><br><br></code></pre></td></tr></table></figure><p>这个虽然烦琐，但明显更易于阅读，每个参数都是自我描述(self-documenting)的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">function <span class="hljs-title">Alert</span><span class="hljs-params">(parent, message, opts)</span> </span>&#123;<br>opts = opts || &#123;&#125;;<br><br><span class="hljs-keyword">this</span>.width = opts.width === undefined ? <span class="hljs-number">320</span> : opts.width;<br><span class="hljs-keyword">this</span>.height = opts.width === undefined ? <span class="hljs-number">240</span> : opts.height;<br><span class="hljs-keyword">this</span>.title = otps.title || <span class="hljs-string">&quot;Alert&quot;</span>;<br><br>&#125;<br><br>基于 extend 的另一种实现<br><br><span class="hljs-function">function <span class="hljs-title">extend</span><span class="hljs-params">(target, source)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(source) &#123;<br><span class="hljs-keyword">for</span>(var key in source) &#123;<br>var val = source[key];<br><br><span class="hljs-keyword">if</span>(typeof val !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>target[key] = val;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> target;<br>&#125;<br><br><br><br><span class="hljs-function">function <span class="hljs-title">Alert</span><span class="hljs-params">(parent, message, opts)</span> </span>&#123;<br>opts = <span class="hljs-built_in">extend</span>(&#123;<br>width: <span class="hljs-number">320</span>,<br>height: <span class="hljs-number">240</span><br>&#125;);<br><br>opts = <span class="hljs-built_in">extend</span>(&#123;<br>title: <span class="hljs-string">&quot;Alert&quot;</span><br>&#125;, opts);<br><br><span class="hljs-keyword">this</span>.width = opts.width;<br><span class="hljs-keyword">this</span>.height = opts.height;<br><span class="hljs-keyword">this</span>.title = opts.title;<br><br>&#125;<br><br><br>进一步简化<br><br><br><span class="hljs-function">function <span class="hljs-title">Alert</span><span class="hljs-params">(parent, message, opts)</span> </span>&#123;<br>opts = <span class="hljs-built_in">extend</span>(&#123;<br>width: <span class="hljs-number">320</span>,<br>height: <span class="hljs-number">240</span><br>&#125;);<br><br>opts = <span class="hljs-built_in">extend</span>(&#123;<br>title: <span class="hljs-string">&quot;Alert&quot;</span><br>&#125;, opts);<br><br><span class="hljs-built_in">extend</span>(<span class="hljs-keyword">this</span>, opts);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="区分数组对象和类数组对象"><a href="#区分数组对象和类数组对象" class="headerlink" title="区分数组对象和类数组对象"></a>区分数组对象和类数组对象</h2><p>使用instanceof的不完美选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">StringSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;String&#x27;</span>) &#123;<br><span class="hljs-comment">// xxx</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123; <span class="hljs-comment">//有局限性</span><br><span class="hljs-comment">// xxx</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// xxx</span><br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>instanceof 操作符测试一个对象是否继承自Array.prototype。 在一些允许多个全局对象的环境中可能会有标准的Array构造函数和原型对象的多份副本。在浏览器中有这种情况，每个frame会有标准库的一份单独副本，当跨frame通信时，一个frame中的数组不会继承自另一个frame的Array.prototype.出于这个原因，ES5中引入了<code>Array.isArray</code>函数， 其用于测试一个值是否是数组，而不管原型继承。ESMAScript标准中， 该函数测试对象内部[[Class]]属性值是否是Array。它比<code>instanceof</code>更加可靠。<br>所以有这个更健壮的实现。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">StringSet</span>.proto<span class="hljs-keyword">type</span>.add = function(x) &#123;<br>if(typeof x  === &#x27;<span class="hljs-type">String</span>&#x27;) &#123;<br><br>&#125; else if(<span class="hljs-type">Array</span>.isArray(x)) &#123;<br><br>&#125; else &#123;<br><br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>对于不支持ES5的环境中我们可以自己实现一个测试方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> toString = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isArray</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">toString</span>(x) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 转为真实数组</span><br>你不能传入<span class="hljs-variable language_">arguments</span>对象并期待它被视为数组，<br>最好还是自己转化一下<br>[].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br><br><br><br></code></pre></td></tr></table></figure><p><code>Object.prototype.toString</code>函数使用对象内部<code>[[Class]]</code>属性创建结果字符串，所以比<code>instance of</code>操作符更可靠。</p><h2 id="避免过度的强制转换"><a href="#避免过度的强制转换" class="headerlink" title="避免过度的强制转换"></a>避免过度的强制转换</h2><p>我们创建一个BitVector的构造函数guard, 这里有一个思路可以用来做检测用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BitVector</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-comment">// 链式调用</span><br>uint32.<span class="hljs-title function_">or</span>(arrayLike).<span class="hljs-title function_">guard</span>(x);<br>&#125;<br><br><br><span class="hljs-keyword">var</span> guard = &#123;<br><span class="hljs-attr">guard</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">test</span>(x)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;expected &quot;</span> + <span class="hljs-variable language_">this</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> uint32 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(guard);<br><br>uint32.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;uint32&quot;</span>;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> arrayLike = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(guard);<br><br>arrayLike.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; x &amp;&amp; uint32.<span class="hljs-title function_">test</span>(x.<span class="hljs-property">length</span>);<br>&#125;<br><br>arrayLike.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;array-like object&quot;</span>;<br>&#125;<br><br><br>guard.<span class="hljs-property">or</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) &#123;<br><span class="hljs-keyword">var</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(guard);<br><br><span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>result.<span class="hljs-property">test</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> self.<span class="hljs-title function_">test</span>(x) || other.<span class="hljs-title function_">test</span>(x);<br>&#125;;<br><br><span class="hljs-keyword">var</span> description = <span class="hljs-variable language_">this</span> + <span class="hljs-string">&quot; or &quot;</span> + other;<br><br>result.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> description;<br>&#125;;<br><br><span class="hljs-keyword">return</span> result;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="支持方法链"><a href="#支持方法链" class="headerlink" title="支持方法链"></a>支持方法链</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeBasicHTML</span>(<span class="hljs-params">str</span>) &#123;<br><span class="hljs-keyword">return</span> str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&quot;&amp;amp;&quot;</span>)<br>  .<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&quot;&amp;lt;&quot;</span>)<br>  .<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&quot;&amp;gt;&quot;</span>)<br>  .<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&quot;&amp;quot;&quot;</span>)<br>  .<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&quot;&amp;apos;&quot;</span>);<br>&#125;<br><br>这种比下面的方法更加简洁<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeBasicHTML</span>(<span class="hljs-params">str</span>) &#123;<br><span class="hljs-keyword">var</span> str2 = str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&quot;&amp;amp;&quot;</span>);<br><span class="hljs-keyword">var</span> str3 = str2.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&quot;&amp;lt;&quot;</span>);<br><span class="hljs-keyword">var</span> str4 = str3.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&quot;&amp;gt;&quot;</span>);<br><span class="hljs-keyword">var</span> str5 = str4.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&quot;&amp;quot;&quot;</span>);<br><span class="hljs-keyword">var</span> str6 = str5..<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&quot;&amp;apos;&quot;</span>);<br><br><span class="hljs-keyword">return</span> str6;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> users = records.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">record</span>) &#123;<br><span class="hljs-keyword">return</span> record.username;<br>&#125;)<br>.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">username</span>) &#123;<br><span class="hljs-keyword">return</span> !!username;<br>&#125;)<br>.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">username</span>) &#123;<br><span class="hljs-keyword">return</span> username.toLowerCase();<br>&#125;);<br><br></code></pre></td></tr></table></figure><ul><li>使用方法链来连接无状态的操作</li><li>通过无状态的方法中返回新对象来支持方法链</li><li>通过在有状态的方法中返回this来支持方法链</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (十)</title>
    <link href="/2018/09/28/2018-09-28-read-book-effective-ten/"/>
    <url>/2018/09/28/2018-09-28-read-book-effective-ten/</url>
    
    <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>JavaScript被设计成一种嵌入式的脚本语言。它不是以单独的应用程序运行，而是作为大型应用程序环境下的脚本运行。典型的例子当然是Web浏览器。<br>JavaScript中编写响应多个并发事件的程序的方法非常人性化，而且强大，因为它使用了一个简单的执行模型(有时称为事件队列和事件循环并发)和被称为异步的API.<br>奇怪的是，到目前为止，ECMAScript标准从来没有关于并发的说明。我们讨论的都是“约定成俗”的JavaScript特性，并不是官方标准。然而，绝大多数JavaScript的环境都使用相同的并发策略，未来标准的版本很有可能会基于广泛实现的执行模型来标准化。不管标准如何定义，使用事件和异步API是JavaScript编程的基础部分。</p><h2 id="不要阻塞I-O事件队列"><a href="#不要阻塞I-O事件队列" class="headerlink" title="不要阻塞I/O事件队列"></a>不要阻塞I/O事件队列</h2><p>JavaScript程序是建立在事件之上的。输入可能来自各种各样的外部源，用户的交互操作，输入的网络数据或定时警报，我们通常会写这样的代码来等待某个特定的输入</p><figure class="highlight arcade"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">text</span> = downloadSync(<span class="hljs-string">&quot;http://example.com/file.txt&quot;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">text</span>);<br></code></pre></td></tr></table></figure><p>这样的函数通常被称为同步函数或阻塞函数， 程序会停止工作，等待它的输入。这个例子是等的网络下载文件的结果。</p><p>在JavaScript中，大多数的I/O操作都提供了异步的或非阻塞的API, 程序提供一个回调函数，一旦输入完成就可以被系统调用， 而不是将程序阻塞在等待结果的线程上。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">dowanloadAsync(<span class="hljs-string">&quot;http://example.com/file.txt&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">text</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>JavaScript并发的一个重要规则是绝不要在应用程序事件队列中使用阻塞I/O的API。对于Web应用程序的交互性，同步的I/O会导致灾难性的结果，在操作完成之前一直会阻塞用户于页面的交互。</p><p>Web平台提供了Workder的API，使得产生大量的并行计算称为可能。不同于传统的线程执行Workders在一个完全隔离的状态下进行，没有获取全局作用域或应用程序主线程Web页面内容的能力。因此它不回妨碍主事件队列中运行的代码的执行。在一个Worker中使用XMLHttpRequest同步的变种很少出问题。下载操作的确会阻塞Worker继续运行，但这并不会组织要么的渲染或事件队列中的事件响应。</p><h2 id="在异步序列中使用嵌套或命名的回调函数"><a href="#在异步序列中使用嵌套或命名的回调函数" class="headerlink" title="在异步序列中使用嵌套或命名的回调函数"></a>在异步序列中使用嵌套或命名的回调函数</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">db.lookupAsync(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) &#123;<br><span class="hljs-comment">//</span><br>&#125;);<br><br>downloadAsync(url, <span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;contents of &quot;</span> + url + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-built_in">text</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>两个异步函数第二个的url读取不到，我们可以使用嵌套</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">db.lookupAsync(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) &#123;<br>downloadAsync(url, <span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;contents of &quot;</span> + url + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-built_in">text</span>);<br>&#125;);<br>&#125;);<br><br><br></code></pre></td></tr></table></figure><p>但是回调函数越来越多会变得很笨拙。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.lookup<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">url</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">function</span>(<span class="hljs-params">text</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">a</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-string">&quot;b.txt&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">b</span>)</span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;)<br>&#125;)<br>&#125;);<br>&#125;);<br><br><br></code></pre></td></tr></table></figure><p>减少嵌套的方法之一就是将嵌套的回调函数作为命名的函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.lookup<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">downloadURL</span>)</span>;<br><br><br><span class="hljs-comment">// 仍然有嵌套</span><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">URL(<span class="hljs-params">url</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">function</span>(<span class="hljs-params">text</span>)</span> &#123;<br>show<span class="hljs-constructor">Contents(<span class="hljs-params">url</span>, <span class="hljs-params">text</span>)</span>;<br>&#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> show<span class="hljs-constructor">Contents(<span class="hljs-params">url</span>, <span class="hljs-params">text</span>)</span> &#123;<br>console.log(<span class="hljs-string">&quot;contents of &quot;</span> + url + <span class="hljs-string">&quot; : &quot;</span> + text);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的例子中仍然有嵌套，我们可以使用bind方法消除最深层的嵌套回调函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.lookup<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">downloadURL</span>)</span>;<br><br><br><span class="hljs-comment">// 仍然有嵌套</span><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">URL(<span class="hljs-params">url</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">showContents</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">url</span>)</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> show<span class="hljs-constructor">Contents(<span class="hljs-params">url</span>, <span class="hljs-params">text</span>)</span> &#123;<br>console.log(<span class="hljs-string">&quot;contents of &quot;</span> + url + <span class="hljs-string">&quot; : &quot;</span> + text);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是如果层级过多仍然会有问题， 比如</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.lookup<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">downloadURL</span>)</span>;<br><br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">URL(<span class="hljs-params">url</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">downloadABC</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">url</span>)</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">ABC(<span class="hljs-params">url</span>, <span class="hljs-params">file</span>)</span> &#123;<br>downloas<span class="hljs-constructor">Async(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-params">downloadFileBC</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">url</span>, <span class="hljs-params">file</span>)</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">BC(<span class="hljs-params">url</span>, <span class="hljs-params">file</span>, <span class="hljs-params">a</span>)</span> &#123;<br>downloas<span class="hljs-constructor">Async(<span class="hljs-string">&quot;b.txt&quot;</span>, <span class="hljs-params">downloadFileFinish</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">url</span>, <span class="hljs-params">file</span>, <span class="hljs-params">a</span>)</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">FileFinish(<span class="hljs-params">url</span>, <span class="hljs-params">file</span>, <span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>比如尴尬的函数命名，和参数传递。最好的方式还是将两种方式结合。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>db.lookup<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">url</span>)</span> &#123;<br>download<span class="hljs-constructor">URLAndFiles(<span class="hljs-params">url</span>)</span>;<br>&#125;);<br><br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">URLAndFiles(<span class="hljs-params">url</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">downloadFiles</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">url</span>)</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">Files(<span class="hljs-params">url</span>, <span class="hljs-params">file</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">a</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-string">&quot;b.txt&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">b</span>)</span> &#123;<br><span class="hljs-comment">// ...</span><br>&#125;)<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>更好的方法是抽象出一个可以下载多个文件的方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">downloadFiles</span>(<span class="hljs-params">url, file</span>) &#123;<br>downloadAllAsync([<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;b.txt&quot;</span>, <span class="hljs-string">&quot;c.txt&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">all</span>) &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">all</span>[<span class="hljs-number">0</span>], b = <span class="hljs-built_in">all</span>[<span class="hljs-number">1</span>], c = <span class="hljs-built_in">all</span>[<span class="hljs-number">2</span>];<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="当心丢弃错误"><a href="#当心丢弃错误" class="headerlink" title="当心丢弃错误"></a>当心丢弃错误</h2><p>同步代码我们可以通过<code>try...catch</code>来捕获所有错误，比如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">try &#123;<br><span class="hljs-built_in">f</span>();<br><span class="hljs-built_in">g</span>();<br><span class="hljs-built_in">h</span>();<br>&#125; <span class="hljs-built_in">catch</span>(e) &#123;<br><span class="hljs-comment">// handle any error that occured</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>但是异步代码根本不可能抛出异常， 通常异步API会有一个额外的回调函数来处理网络错误。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>downloadAsync(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) &#123;<br><br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Error &quot;</span> + err);<br>&#125;);<br><br>多个回调时可以提取公共部分<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onErr</span>(<span class="hljs-params">err</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Error &quot;</span> + err);<br>&#125;<br><br>downloadAsync(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) &#123;<br><br>&#125;, onErr);<br><br></code></pre></td></tr></table></figure><p>Node.js 异步处理API的错误处理，我们通过if判断来控制每个回调函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> on<span class="hljs-constructor">Err(<span class="hljs-params">err</span>)</span> &#123;<br>console.log(<span class="hljs-string">&quot;Error &quot;</span> + err);<br>&#125;<br><br>download<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">error</span>, <span class="hljs-params">text</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(error) &#123;<br>on<span class="hljs-constructor">Error(<span class="hljs-params">error</span>)</span>;<br>return <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//success</span><br>&#125;);<br><br><br>更简洁写法<br><br>download<span class="hljs-constructor">Async(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-params">function</span>(<span class="hljs-params">error</span>, <span class="hljs-params">text</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(error) return on<span class="hljs-constructor">Error(<span class="hljs-params">error</span>)</span>;<br><br><span class="hljs-comment">//success</span><br>&#125;);<br><br><br></code></pre></td></tr></table></figure><h2 id="对异步循环使用递归"><a href="#对异步循环使用递归" class="headerlink" title="对异步循环使用递归"></a>对异步循环使用递归</h2><p>如果一个函数接受一个URL的数组并尝试下载买每个文件，如果API是同步的很容易实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> download<span class="hljs-constructor">OneSync(<span class="hljs-params">urls</span>)</span> &#123;<br><span class="hljs-keyword">for</span>(var i = <span class="hljs-number">0</span>, n = urls.length; i &lt; n; i++) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>return download<span class="hljs-constructor">Sync(<span class="hljs-params">urls</span>[<span class="hljs-params">i</span>])</span>;<br>&#125; catch(e) &#123;<br><br>&#125;<br>&#125;<br><br>throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;all downloads failed&quot;</span>)</span>;<br>&#125;<br>如果调用downloadAsync的话会所有文件一起下载没有顺序，所以我们需要这样做在每个回调结束调用自身<br><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">OneAsync(<span class="hljs-params">urls</span>, <span class="hljs-params">onsuccess</span>, <span class="hljs-params">onfailur</span>)</span> &#123;<br>var n = urls.length;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">try</span><span class="hljs-constructor">NextURL(<span class="hljs-params">i</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(i &gt;= n) &#123;<br>onfailur(<span class="hljs-string">&quot;all downloads failed&quot;</span>);<br>return;<br>&#125;<br><br>download<span class="hljs-constructor">Async(<span class="hljs-params">urls</span>[<span class="hljs-params">i</span>], <span class="hljs-params">onsuccess</span>, <span class="hljs-params">function</span>()</span> &#123;<br><span class="hljs-keyword">try</span><span class="hljs-constructor">NextURL(<span class="hljs-params">i</span> + 1)</span>;<br>&#125;)<br>&#125;<br><br><span class="hljs-keyword">try</span><span class="hljs-constructor">NextURL(0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>局部函数tryNextURL是一个递归函数。它的实现调用了自身。 目前典型的JavaScript环境中一个递归函数调用自身多次会导致失败。<br>因为当一个程序执行有太多的函数调用，它会耗尽栈空间，最终抛出异常。这种情况被称为栈溢出。</p><p>该例子调用100000次会产生一个运行时错误。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(n) &#123;<br>if(n === 0) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">&quot;done&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> countdown(n -<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>异步操作不需要等待递归回调返回后才返回，调用栈不回有十万个函数在等待。每次有进有出只调用一个。</p><ul><li>循环不能是异步的</li><li>使用递归函数在事件循环的单独轮次中执行迭代</li><li>在事件循环的单独轮次中执行递归，并不会导致栈溢出</li></ul><h2 id="不要在计算时阻塞事件队列"><a href="#不要在计算时阻塞事件队列" class="headerlink" title="不要在计算时阻塞事件队列"></a>不要在计算时阻塞事件队列</h2><p>如果你的程序需要执行代价高昂的计算你该怎么办，最简单的方法就是使用想Web客户端平台的Worker API这样的并发机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> ai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;ai.js&#x27;</span>);<br><br><span class="hljs-keyword">var</span> userMove = <span class="hljs-comment">/* *** */</span>;<br><br>ai.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br><span class="hljs-attr">userMOve</span>: userMove<br>&#125;));<br><br><br>ai.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br><span class="hljs-title function_">executeMove</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>).<span class="hljs-property">computerMove</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样会产生一个新的线程独立的事件队列的并发执行线程。该worker是一个完全隔离的状态–没有任何应用程序对象的直接访问。但是，应用程序于worker之间可以功过发送形式为字符串的message来交互。</p><ul><li>避免在主事件队列中执行代价高昂的计算</li><li>在支持Worker API的平台，该API可以用来在一个独立的事件队列中运行长计算程序。</li><li>在Worker API不可用活代价高昂的环境中，考虑将计算程序分解到事件循环的多个轮次中</li></ul><h2 id="使用计数器来执行并行操作"><a href="#使用计数器来执行并行操作" class="headerlink" title="使用计数器来执行并行操作"></a>使用计数器来执行并行操作</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">downloadAllAsync</span>(<span class="hljs-params">urls, onsuccess, onerror</span>) &#123;<br><br><span class="hljs-keyword">var</span> result = [], <span class="hljs-built_in">length</span> = urls.<span class="hljs-built_in">length</span>;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">length</span> === <span class="hljs-number">0</span>) &#123;<br>setTimeout(onsuccess.bind(<span class="hljs-literal">null</span>, result), <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>urls.forEach(<span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) &#123;<br>downloadAsync(url, <span class="hljs-keyword">function</span>(<span class="hljs-params">rext</span>) &#123;<br><span class="hljs-keyword">if</span>(result) &#123;<br>result.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">text</span>);<br><span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">length</span> === urls.<span class="hljs-built_in">length</span>) &#123;<br>onsuccess(result);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br><span class="hljs-keyword">if</span>(result) &#123;<br>result = <span class="hljs-literal">null</span>;<br>onerror(error);<br>&#125;<br>&#125;);<br>&#125;)<br>&#125;<br><br>这段代码有个错误<br><br><span class="hljs-keyword">var</span> filenames = [<br><span class="hljs-string">&quot;huge.txt&quot;</span>,<br><span class="hljs-string">&quot;tiny.txt&quot;</span>,<br><span class="hljs-string">&quot;medium.txt&quot;</span>,<br>];<br><br>downloadAllAsync(filenames, <span class="hljs-keyword">function</span>(<span class="hljs-params">files</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Huge file: &quot;</span> + files[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>); <span class="hljs-comment">// tiny</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Tiny file: &quot;</span> + files[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>); <span class="hljs-comment">// medium</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Medium file: &quot;</span> + files[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>); <span class="hljs-comment">// huge</span><br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Error : &quot;</span> + error);<br>&#125;);<br><br><br></code></pre></td></tr></table></figure><p>这里下载文件的顺序并不可控，因为文件是并行下载的。 调用者无法找出那个结果对应哪个文件， 上面的例子假设结果合输入有相同的顺序其实是错误的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> download<span class="hljs-constructor">AllAsync(<span class="hljs-params">urls</span>, <span class="hljs-params">onsuccess</span>, <span class="hljs-params">onerror</span>)</span> &#123;<br><br>var result = <span class="hljs-literal">[]</span>, length = urls.length;<br><br><span class="hljs-keyword">if</span>(length<span class="hljs-operator"> === </span><span class="hljs-number">0</span>) &#123;<br>set<span class="hljs-constructor">Timeout(<span class="hljs-params">onsuccess</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">result</span>)</span>, <span class="hljs-number">0</span>);<br>return;<br>&#125;<br><br>urls.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">url</span>, <span class="hljs-params">i</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">function</span>(<span class="hljs-params">text</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(result) &#123;<br><br>result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = text;<br><span class="hljs-keyword">if</span>(result.length<span class="hljs-operator"> === </span>urls.length) &#123;<br>onsuccess(result);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-keyword">function</span>(error) &#123;<br><span class="hljs-keyword">if</span>(result) &#123;<br>result = null;<br>onerror(error);<br>&#125;<br>&#125;);<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个版本也有问题如果先下载完成的是第三个文件则 result[2] = text; 那么result的长度也是3， 则直接在if条件中返回，用户的success回调函数将被过早调用，其参数为一个不完整的结果数组。</p><p>所以正确的方式应该是这样</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-keyword">function</span> download<span class="hljs-constructor">AllAsync(<span class="hljs-params">urls</span>, <span class="hljs-params">onsuccess</span>, <span class="hljs-params">onerror</span>)</span> &#123;<br><br>var result = <span class="hljs-literal">[]</span>, pending = urls.length;<br><br><span class="hljs-keyword">if</span>(pending<span class="hljs-operator"> === </span><span class="hljs-number">0</span>) &#123;<br>set<span class="hljs-constructor">Timeout(<span class="hljs-params">onsuccess</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">null</span>, <span class="hljs-params">result</span>)</span>, <span class="hljs-number">0</span>);<br>return;<br>&#125;<br><br>urls.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">url</span>, <span class="hljs-params">i</span>)</span> &#123;<br>download<span class="hljs-constructor">Async(<span class="hljs-params">url</span>, <span class="hljs-params">function</span>(<span class="hljs-params">text</span>)</span> &#123;<br><span class="hljs-keyword">if</span>(result) &#123;<br><br>result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = text;<br>pending--;<br><span class="hljs-keyword">if</span>(pending<span class="hljs-operator"> === </span><span class="hljs-number">0</span>) &#123;<br>onsuccess(result);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-keyword">function</span>(error) &#123;<br><span class="hljs-keyword">if</span>(result) &#123;<br>result = null;<br>onerror(error);<br>&#125;<br>&#125;);<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="绝不要同步的调用异步的回调函数"><a href="#绝不要同步的调用异步的回调函数" class="headerlink" title="绝不要同步的调用异步的回调函数"></a>绝不要同步的调用异步的回调函数</h2><p>加入下载文件的例子有一个缓存</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">new</span> Dict();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadCachingAsync</span>(<span class="hljs-params">url, onsuccess, onerrur</span>) </span>&#123;<br><span class="hljs-keyword">if</span>(cache.has(<span class="hljs-built_in">url</span>)) &#123;<br>onsuccess(cache.get(<span class="hljs-built_in">url</span>));  <span class="hljs-comment">// 同步调用</span><br>&#125;<br><br><span class="hljs-keyword">return</span> downloadAsync(<span class="hljs-built_in">url</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">file</span>) </span>&#123;<br>cache.set(<span class="hljs-built_in">url</span>, file);<br>onsuccess(file);<br>&#125;, onerror);<br>&#125;<br><br>通常情况如果可以回立即提供数据，但这改变了用户预期<br><br>downloadAsync(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">file</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;finished&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;starting&quot;</span>);<br><br>这里按照我们预想 可能先返回 <span class="hljs-string">&quot;starting&quot;</span> 然后 <span class="hljs-string">&quot;finished&quot;</span>, 但是由于同步调用了函数，<br>这里如果文件有缓存的话 先返回了<span class="hljs-string">&quot;finished&quot;</span> 然后才是 <span class="hljs-string">&quot;starting&quot;</span>; 这与我们的预想不符。<br>所以我们应该这样来使用<br><br><span class="hljs-keyword">if</span>(cache.has(<span class="hljs-built_in">url</span>)) &#123;<br><span class="hljs-keyword">var</span> cached = cache.get(<span class="hljs-built_in">url</span>);<br>setTimeout(onsuccess.bind(<span class="hljs-literal">null</span>, cached), <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="使用promise模式清洁异步逻辑"><a href="#使用promise模式清洁异步逻辑" class="headerlink" title="使用promise模式清洁异步逻辑"></a>使用promise模式清洁异步逻辑</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>downloadAsync(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">file</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;file : &quot;</span> + file);<br>&#125;);<br><br><br>相比之下，基于promise的API不接受回调函数作为参数<br><br><span class="hljs-keyword">var</span> p = downloadP(<span class="hljs-string">&quot;file.txt&quot;</span>);<br><br>p.then(<span class="hljs-keyword">function</span>(<span class="hljs-params">file</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;file: &quot;</span> + file);<br>&#125;);<br><br>promise的返回值是一个新的promise<br><br><span class="hljs-keyword">var</span> fileP = downloadP(<span class="hljs-string">&quot;file.txt&quot;</span>);<br><br><span class="hljs-keyword">var</span> lengthP = fileP.then(<span class="hljs-keyword">function</span>(<span class="hljs-params">file</span>) &#123;<br><span class="hljs-keyword">return</span> file.<span class="hljs-built_in">length</span>;<br>&#125;);<br><br>lengthP.then(<span class="hljs-keyword">function</span>(<span class="hljs-params">length</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;length: &quot;</span> + <span class="hljs-built_in">length</span>);<br>&#125;);<br><br><br></code></pre></td></tr></table></figure><p>promise通常提供给一个叫做when的工具函数，或者join</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> filesP = join(downloadP(<span class="hljs-string">&quot;file1.txt&quot;</span>),<br>downloadP(<span class="hljs-string">&quot;file2.txt&quot;</span>),<br>downloadP(<span class="hljs-string">&quot;file3.txt&quot;</span>));<br><br>filesP.then(<span class="hljs-keyword">function</span>(<span class="hljs-params">files</span>) &#123;<br><span class="hljs-comment">// files[0]</span><br>&#125;);<br><br><br><span class="hljs-keyword">var</span> fileP1 = downloadP(<span class="hljs-string">&quot;file1.txt&quot;</span>);<br><span class="hljs-keyword">var</span> fileP2 = downloadP(<span class="hljs-string">&quot;file2.txt&quot;</span>);<br><span class="hljs-keyword">var</span> fileP3 = downloadP(<span class="hljs-string">&quot;file3.txt&quot;</span>);<br><br><span class="hljs-built_in">when</span>([fileP1, fileP2, fileP3], <span class="hljs-keyword">function</span>(<span class="hljs-params">files</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;file1: &quot;</span> + files[<span class="hljs-number">0</span>]);<br><br>&#125;)<br><br></code></pre></td></tr></table></figure><p>使用select或choose工具函数可以使几个promise彼此竞争。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var filesP = select(download<span class="hljs-constructor">P(<span class="hljs-string">&quot;file1.txt&quot;</span>)</span>,<br>download<span class="hljs-constructor">P(<span class="hljs-string">&quot;file2.txt&quot;</span>)</span>,<br>download<span class="hljs-constructor">P(<span class="hljs-string">&quot;file3.txt&quot;</span>)</span>);<br><br>filesP.<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(file) &#123;<br><span class="hljs-comment">//file</span><br><span class="hljs-comment">// 返回值最先完成下载的文件的promise</span><br>&#125;);<br><br></code></pre></td></tr></table></figure><p>select函数的另一个用途是提供超时来终止长时间的操作</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">var fileP = <span class="hljs-keyword">select</span>(downloadP(<span class="hljs-string">&quot;file.txt&quot;</span>), timeoutErrorP(2000));<br><br>filep.the<span class="hljs-meta">n</span>(functio<span class="hljs-meta">n</span>(<span class="hljs-keyword">file</span>) &#123;<br>console.<span class="hljs-meta">log</span>(<span class="hljs-string">&quot;file: &quot;</span> + <span class="hljs-keyword">file</span>);<br>&#125;, functio<span class="hljs-meta">n</span>(<span class="hljs-keyword">error</span>) &#123;<br>console.<span class="hljs-meta">log</span>(<span class="hljs-string">&quot;I/O error or timeout: &quot;</span> + <span class="hljs-keyword">error</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (八)</title>
    <link href="/2018/09/25/2018-09-25-read-book-effective-eight/"/>
    <url>/2018/09/25/2018-09-25-read-book-effective-eight/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Object的直接实例构造轻量级的字典"><a href="#使用Object的直接实例构造轻量级的字典" class="headerlink" title="使用Object的直接实例构造轻量级的字典"></a>使用Object的直接实例构造轻量级的字典</h2><figure class="highlight maxima"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> dict = &#123; alice: <span class="hljs-number">34</span>, bob: <span class="hljs-number">24</span>, chris: <span class="hljs-number">62</span> &#125;;<br><br><span class="hljs-built_in">var</span> people = [];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span> name <span class="hljs-keyword">in</span> dict) &#123;<br>people.<span class="hljs-built_in">push</span>(name + <span class="hljs-string">&quot;: &quot;</span> + dict[name]);<br>&#125;<br><br>people; // [<span class="hljs-string">&quot;alice: 34&quot;</span>, <span class="hljs-string">&quot;bob: 24&quot;</span>, <span class="hljs-string">&quot;chris: 62&quot;</span>];<br><br></code></pre></td></tr></table></figure><p>我们创建一个自定义的字典类会怎样呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">NaiveDict</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">NaiveDict</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">count</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>) &#123;<br>i++;<br>&#125;<br><br><span class="hljs-keyword">return</span> i;<br>&#125;;<br><br><span class="hljs-title class_">NaiveDict</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[object NaiveDict]&quot;</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NaiveDict</span>();<br><br>dict.<span class="hljs-property">alice</span> = <span class="hljs-number">34</span>;<br>dict.<span class="hljs-property">bob</span> = <span class="hljs-number">24</span>;<br>dict.<span class="hljs-property">chris</span> = <span class="hljs-number">62</span>;<br><br>dict.<span class="hljs-title function_">count</span>(); <span class="hljs-comment">// 5</span><br><br></code></pre></td></tr></table></figure><p>这样有一个问题，count会枚举出所有的属性包括了toString 和count,而不仅仅是我们需要的值。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var dict <span class="hljs-operator">=</span> new Array()<span class="hljs-comment">;</span><br><br>dict.alice <span class="hljs-operator">=</span> <span class="hljs-number">34</span><span class="hljs-comment">;</span><br>dict.bob <span class="hljs-operator">=</span> <span class="hljs-number">24</span><span class="hljs-comment">;</span><br>dict.chris <span class="hljs-operator">=</span> <span class="hljs-number">62</span><span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>这样也会有问题，代码对原型污染很脆弱，应用程序的其他库有可能会打猴子补丁，比如</p><blockquote><p>原型污染是指当枚举字典的条目时，原型对象中的一些属性可能会导致出现一些不期望的属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">first</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">last</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">var</span> names = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> dict) &#123;<br>names.<span class="hljs-title function_">push</span>(name);<br>&#125;<br><br>names; [<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-string">&quot;chris&quot;</span>, <span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;last&quot;</span>]<br><br></code></pre></td></tr></table></figure><p>使用使用 <code>new Object() </code>可能会面临同样的问题，但是使用 <code>&#123;&#125;</code>的方式会更好, 虽然不能保证对于原型污染时安全的，任何人仍然能增加属性到Object.prototype，但是风险可以降低到仅仅局限于Object.prototype</p><ul><li>坚持使用Object的直接实例原则可以使for…in循环摆脱原型污染的影响</li><li>使用对象字面量构建轻量级字典</li></ul><h2 id="使用null原型以防止原型污染"><a href="#使用null原型以防止原型污染" class="headerlink" title="使用null原型以防止原型污染"></a>使用null原型以防止原型污染</h2><p>防止原型污染的最简单的方式之一就是一开始就不使用原型。但是ES5发布之前并没有一个标准的方式创建一个空原型的新对象。你可能会这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) &#123; &#125;<br><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o) === <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br><br><br><span class="hljs-comment">// ES5之后应该这样做</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o) === <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span><br><br>在不支持<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>的<span class="hljs-title class_">JavaScript</span>环境中特殊对象__proto__提供了对对象内部原型链的读写访问<br><br><span class="hljs-keyword">var</span> x = &#123; <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span> &#125;;<br><br>x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>;  <span class="hljs-comment">// false;</span><br><br></code></pre></td></tr></table></figure><p>第二种貌似更方便，但是有了Object.create函数后，Object.create是更值得推荐的方式。</p><ul><li>在ES5中要使用Object.create(null)创建自由原型的空对象是不太容易被污染的。</li><li>在一些老环境中考虑使用{ <strong>proto</strong>: null }， 但是它既不是标准的也不是可移植的还有可能在未来被删除</li><li>绝对不要使用__proto__作为字典中的key</li></ul><h2 id="使用hasOwnProperty方法避免原型污染"><a href="#使用hasOwnProperty方法避免原型污染" class="headerlink" title="使用hasOwnProperty方法避免原型污染"></a>使用hasOwnProperty方法避免原型污染</h2><p>JavaScript的对象操作总是以继承的方式工作，即使一个空的对象字面量也继承了Object.prototype的大量属性</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">var dict = &#123;&#125;<br><span class="hljs-string">&quot;alice&quot;</span> <span class="hljs-keyword">in</span> dict; <span class="hljs-regexp">//</span>false;<br><span class="hljs-string">&quot;bob&quot;</span> <span class="hljs-keyword">in</span> dict; <span class="hljs-regexp">//</span>false;<br><span class="hljs-string">&quot;chris&quot;</span> <span class="hljs-keyword">in</span> dict; <span class="hljs-regexp">//</span>false;<br><br><span class="hljs-regexp">//</span> toString 和valueOf方法继承自Object.prototype<br><span class="hljs-string">&quot;toString&quot;</span> <span class="hljs-keyword">in</span> dict; <span class="hljs-regexp">//</span>false;  <br><span class="hljs-string">&quot;valueOf&quot;</span> <span class="hljs-keyword">in</span> dict; <span class="hljs-regexp">//</span>false;<br></code></pre></td></tr></table></figure><p>幸运的是Object.hasOwnProperty方法可以用来判断属性是否继承自原型对象。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">dict.hasOwnProperty(<span class="hljs-string">&quot;alice&quot;</span>);     <span class="hljs-regexp">//</span> false<br>dict.hasOwnProperty(<span class="hljs-string">&quot;toString&quot;</span>);  <span class="hljs-regexp">//</span> false<br>dict.hasOwnProperty(<span class="hljs-string">&quot;valueOf&quot;</span>);   <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>不幸的是我们没有完全解决问题，当调用dict.hasOwnProperty时，我们请求调查对象的hasOwnProperty方法，通常情况下，该方法会简单的继承自Object.property对象，然而如果字典中存储一个同名的条目时，那么原型中的hasOwnProperty方法不能再被捕获到。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">dict</span>.hasOwnProperty <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">dict</span>.hasOwnProperty(<span class="hljs-string">&quot;alice&quot;</span>);<br><span class="hljs-comment">// error dict.hasOwnProperty is not a function</span><br></code></pre></td></tr></table></figure><p>这是有可能的,最安全的方式就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hasOwn = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>;<br>或者<br><span class="hljs-keyword">var</span> hasOwn = &#123;&#125;.<span class="hljs-property">hasOwnProperty</span>;<br><br>hasOwn.<span class="hljs-title function_">call</span>(dict, <span class="hljs-string">&quot;alice&quot;</span>);<br></code></pre></td></tr></table></figure><p>不管起接收者的hasOwnProperty方法是否被覆盖，该方法都能工作。</p><p>我们开始创建一个字典类 版本一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dict</span>(<span class="hljs-params">elements</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span> = elements || &#123;&#125;;<br>&#125;<br><br><span class="hljs-title class_">Dict</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">has</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-keyword">return</span> &#123;&#125;.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>, key);<br>&#125;<br><br><span class="hljs-title class_">Dict</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(key) ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>[key] : <span class="hljs-literal">undefined</span>;<br>&#125;<br><br><span class="hljs-title class_">Dict</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key, val</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>[key] = val;<br>&#125;<br><br><span class="hljs-title class_">Dict</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">remove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) &#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>[key];<br>&#125;<br><br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dict</span>(&#123;<br><span class="hljs-attr">alice</span>: <span class="hljs-number">34</span>,<br><span class="hljs-attr">bob</span>: <span class="hljs-number">24</span>,<br><span class="hljs-attr">chris</span>: <span class="hljs-number">62</span><br>&#125;);<br><br>dict.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;alice&quot;</span>);    <span class="hljs-comment">// true</span><br>dict.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;bob&quot;</span>);      <span class="hljs-comment">// 24</span><br>dict.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;valueOf&quot;</span>)   <span class="hljs-comment">//false</span><br><br></code></pre></td></tr></table></figure><p>在一些JavaScript的环境中，特殊的属性名__proto__可能导致自身的污染问题__proto__属性只是简单的继承Object.prototype,所以我们的例子会有一个问题</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">var <span class="hljs-built_in">dict</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Dict();<br><span class="hljs-built_in">dict</span>.has(<span class="hljs-string">&quot;__proto__&quot;</span>); <span class="hljs-comment">// ?</span><br><br></code></pre></td></tr></table></figure><p>这段代码在不同的环境下可能会有不同的结果，所以为了达到最大的可移植性和安全性，便有了下面更复杂但是更安全的实现<br>这里检测到__proto__的可以 重新设置一个新属性作为实例对象的一个属性，随对象而在但是不会去设置对象的__proto__</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function Dict(elements) &#123;<br><span class="hljs-keyword">this</span>.elements = elements || &#123;&#125;;<br><span class="hljs-keyword">this</span>.hasSpecialProto = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">this</span>.specialProto = undefined;<br>&#125;<br><br>Dict.prototype.has = function(key) &#123;<br><span class="hljs-keyword">if</span>(key === <span class="hljs-string">&quot;__proto__&quot;</span>) &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hasSpecialProto;<br>&#125;<br><span class="hljs-keyword">return</span> &#123;&#125;.hasOwnProperty.call(<span class="hljs-keyword">this</span>.elements, key);<br>&#125;<br><br>Dict.prototype.<span class="hljs-keyword">get</span> = function(key) &#123;<br><span class="hljs-keyword">if</span>(key === <span class="hljs-string">&quot;__proto__&quot;</span>) &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.specialProto;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.has(key) ? <span class="hljs-keyword">this</span>.elements[key] : undefined;<br>&#125;<br><br>Dict.prototype.<span class="hljs-keyword">set</span> = function(key, <span class="hljs-keyword">val</span>) &#123;<br><span class="hljs-keyword">if</span>(key === <span class="hljs-string">&quot;__proto__&quot;</span>) &#123;<br><span class="hljs-keyword">this</span>.hasSpecialProto = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">this</span>.specialProto = <span class="hljs-keyword">val</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.elements[key] = <span class="hljs-keyword">val</span>;<br>&#125;<br><br>&#125;<br><br>Dict.prototype.remove = function(key) &#123;<br><span class="hljs-keyword">if</span>(key === <span class="hljs-string">&quot;__proto__&quot;</span>) &#123;<br><span class="hljs-keyword">this</span>.hasSpecialProto = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">this</span>.sepcialProto = undefined;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>delete <span class="hljs-keyword">this</span>.elements[key];<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> dict = new Dict(&#123;<br>alice: <span class="hljs-number">34</span>,<br>bob: <span class="hljs-number">24</span>,<br>chris: <span class="hljs-number">62</span><br>&#125;);<br><br>dict.has(<span class="hljs-string">&quot;alice&quot;</span>);    <span class="hljs-comment">// true</span><br>dict.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;bob&quot;</span>);      <span class="hljs-comment">// 24</span><br>dict.has(<span class="hljs-string">&quot;valueOf&quot;</span>)   <span class="hljs-comment">//false</span><br><br></code></pre></td></tr></table></figure><h2 id="使用数组而不要使用字典来存储有序集合"><a href="#使用数组而不要使用字典来存储有序集合" class="headerlink" title="使用数组而不要使用字典来存储有序集合"></a>使用数组而不要使用字典来存储有序集合</h2><p>JavaScript对象是一个无序集合,ECMAScript标准并未规定属性存储的任何特定顺序，甚至对于枚举对象也未涉及。这将会导致一个问题，<code>for...in</code>循环会挑选一个特定顺序来枚举对象属性.比如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">report</span>(<span class="hljs-params">highScores</span>) </span>&#123;<br><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> name in highScores) &#123;<br>result += i + <span class="hljs-string">&quot; . &quot;</span> + name + <span class="hljs-string">&quot; : &quot;</span> + highScores[name] + <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>i++;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-title function_ invoke__">report</span>([&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Hank&quot;</span>,<br><span class="hljs-attr">points</span>: <span class="hljs-number">1110100</span><br>&#125;,&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Steve&quot;</span>,<br><span class="hljs-attr">points</span>: <span class="hljs-number">1064500</span><br>&#125;,&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Billy&quot;</span>,<br><span class="hljs-attr">points</span>: <span class="hljs-number">1052000</span><br>&#125;]);<br><br>由于不同的环境选择不同的顺序来存储和枚举对象属性，所以这个函数得到顺序混乱的“最高分”报表<br></code></pre></td></tr></table></figure><p>请记住你的程序是否以来对象枚举的顺序并不总是显而易见的，如果没有在多个JavaScript环境中测试过你的程序，你甚至可能不回注意到程序的行为因为一个for…in循环的确切顺序而被改变，对于上面的例子需要使用数组,那么它完全可以工作在任何JavaScript环境中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">report</span>(<span class="hljs-params">highScores</span>) </span>&#123;<br><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = highScores.length; i &lt; n; i++) &#123;<br><span class="hljs-keyword">var</span> score = hightScores[i];<br>result += (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; . &quot;</span> + score.name + <span class="hljs-string">&quot; : &quot;</span> + score.points + <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>i++;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-title function_ invoke__">report</span>([&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Hank&quot;</span>,<br><span class="hljs-attr">points</span>: <span class="hljs-number">1110100</span><br>&#125;,&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Steve&quot;</span>,<br><span class="hljs-attr">points</span>: <span class="hljs-number">1064500</span><br>&#125;,&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Billy&quot;</span>,<br><span class="hljs-attr">points</span>: <span class="hljs-number">1052000</span><br>&#125;]);<br><br></code></pre></td></tr></table></figure><p>一个微妙的顺序以来的典型例子是浮点运算， 假设一个对象使用<code>for...in</code> 如下</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> ratings = &#123;<br><span class="hljs-string">&quot;Good will Hunting&quot;</span>: 0.8,<br><span class="hljs-string">&quot;Mystic River&quot;</span>: 0.7,<br><span class="hljs-string">&quot;21&quot;</span>: 0.6,<br><span class="hljs-string">&quot;Doubt&quot;</span>: 0.9<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">total</span> = 0, <span class="hljs-keyword">count</span> = 0;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span>. ratings) &#123;<br><span class="hljs-keyword">total</span> += ratings[key];<br><span class="hljs-keyword">count</span>++;<br>&#125;<br><br><span class="hljs-keyword">total</span> /= <span class="hljs-keyword">count</span>;<br><br><span class="hljs-keyword">total</span>; <span class="hljs-comment">//?</span><br><br></code></pre></td></tr></table></figure><p>事实证明，流行的JavaScrtip环境实际上使用不同的顺序执行这个循环。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gcode">一些环境这样计算<br><br><span class="hljs-comment">(0.8 + 0.7 + 0.6 + 0.9)</span> / <span class="hljs-number">4</span>  <span class="hljs-comment">// 0.75</span><br><br>还有一些环境先枚举潜在的数组索引，<span class="hljs-number">21</span>恰好是一个可行的数组索引，它首先被枚举，导致如下结果<br><br><span class="hljs-comment">(0.6 + 0.8 + 0.7 + 0.9)</span> / <span class="hljs-number">4</span>  <span class="hljs-comment">// 0.7499999999999999</span><br><br><br>更好的表示方法是使用整数值<br><br><span class="hljs-comment">(8 + 7 + 6 + 9)</span> / <span class="hljs-number">4</span>/ <span class="hljs-number">10.</span>  <span class="hljs-comment">//0.75</span><br><br><span class="hljs-comment">(6 + 8 + 7  + 9)</span> / <span class="hljs-number">4</span>/ <span class="hljs-number">10.</span>  <span class="hljs-comment">//0.75</span><br><br></code></pre></td></tr></table></figure><p>通常当执行<code>for...in</code> 循环时应当时刻小心，确保操作行为与顺序无关。</p><h2 id="绝不要在Object-prototype中增加可枚举属性"><a href="#绝不要在Object-prototype中增加可枚举属性" class="headerlink" title="绝不要在Object.prototype中增加可枚举属性"></a>绝不要在Object.prototype中增加可枚举属性</h2><p><code>for...in</code>非常便利，然而它很容易受到原型污染的影响。目前为止<code>for...in</code>最常见的用法是枚举字典中的元素。这暗示着如果想允许对字典对象使用<code>for...in</code>循环，那么不要在共享的Object.prototype中增加可枚举的属性。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Object.prototype.allKeys = function() &#123;<br><span class="hljs-built_in">var</span> result = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> this) &#123;<br>result.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">key</span>);<br>&#125;<br><br><span class="hljs-built_in">return</span> result;<br>&#125;<br><br>(&#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>&#125;).allKeys(); // [<span class="hljs-string">&quot;allkeys&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]  该方法污染了自身<br><br>更友好的做法是将allkeys定义为一个函数而不是方法，虽然着稍微有点不方便<br><br>function allKeys(obj) &#123;<br><span class="hljs-built_in">var</span> result = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> obj) &#123;<br>result.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">key</span>);<br>&#125;<br><br><span class="hljs-built_in">return</span> result;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>如果你确实想在Object.prototype中增加属性， ES5提供了一个更加友好的机制Object.defineProperty</p><blockquote><p><code>Object.defineProperty</code>方法可以定义一个对象的属性并制定该属性的元数据。例如，我们可以用与之前完全一样的方法定义上面的属性而通过设置其可枚举属性为false使其在<code>for...in</code>循环中不可见。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;allKeys&quot;</span>, &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>) &#123;<br>result.<span class="hljs-title function_">push</span>(key);<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;,<br><span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>它不会污染其他所有<code>Object</code>实例的所有<code>for...in</code>循环。每当你需要增加一个不应该出现在<code>for...in</code>循环中出现的属性时，Object.defineProperty便是你的选择</p><h2 id="避免在枚举期间修改对象"><a href="#避免在枚举期间修改对象" class="headerlink" title="避免在枚举期间修改对象"></a>避免在枚举期间修改对象</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Member</span></span>(name) &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.friends = [];<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Member</span>(<span class="hljs-string">&quot;Alice&quot;</span>),<br>b = <span class="hljs-keyword">new</span> <span class="hljs-type">Member</span>(<span class="hljs-string">&quot;Bob&quot;</span>),<br>c = <span class="hljs-keyword">new</span> <span class="hljs-type">Member</span>(<span class="hljs-string">&quot;Carol&quot;</span>),<br>d = <span class="hljs-keyword">new</span> <span class="hljs-type">Member</span>(<span class="hljs-string">&quot;Dieter&quot;</span>),<br>e = <span class="hljs-keyword">new</span> <span class="hljs-type">Member</span>(<span class="hljs-string">&quot;Eli&quot;</span>),<br>f = <span class="hljs-keyword">new</span> <span class="hljs-type">Member</span>(<span class="hljs-string">&quot;Fatima&quot;</span>);<br><br>a.friends.push(b);<br>b.friends.push(c);<br>c.friends.push(e);<br>d.friends.push(b);<br>e.friends.push(d,f);<br><br>如果我们写了一个方法 在<span class="hljs-keyword">for</span>...<span class="hljs-keyword">in</span>的时候操作对象比如，删除或添加， 在许多JavaScript环境中这段代码根本不能工作。<br><br></code></pre></td></tr></table></figure><blockquote><p>ECMAScript规定了，如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能够被访问。</p></blockquote><p>这个隐式的规范的实际后果是： 如果我们修改了被枚举的对象则不能保证<code>for...in</code>循环行为的可预见性。</p><p>我们可以新建一个WorkSet类来追踪当前集合中元素的数量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function WorkSet() &#123;<br><span class="hljs-keyword">this</span>.entries = new Dict();<br><span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br>&#125;<br><br>WorkSet.prototype.isEmpty = function() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count === <span class="hljs-number">0</span>;<br>&#125;<br><br>WorkSet.prototype.add = function(key, <span class="hljs-keyword">val</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.entries.has(key)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">this</span>.entries.<span class="hljs-keyword">set</span>(key, <span class="hljs-keyword">val</span>);<br><span class="hljs-keyword">this</span>.count++;<br>&#125;<br><br>WorkSet.prototype.<span class="hljs-keyword">get</span> = function(key) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.entries.<span class="hljs-keyword">get</span>(key);<br>&#125;<br><br>WorkSet.prototype.remove = function(key) &#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.entries.had(key)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">this</span>.entries.remove(key);<br><span class="hljs-keyword">this</span>.count--;<br>&#125;<br><br>WorkSet.prototype.pick = function() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.entries.pick();<br>&#125;<br><br><span class="hljs-comment">//这里同时需要给Dict类增加一个pick方法</span><br><br>Dick.prototype.pick = function() &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.elements) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.has(key)) &#123;<br><span class="hljs-keyword">return</span> key;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">throw</span> new Error(<span class="hljs-string">&quot;empty dictionary&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 现在我们可以实现一个inNetwork的方法</span><br>到最后发现这段代码没什么卵用<br>Member.prototype.inNetwork = function(other) &#123;<br><span class="hljs-keyword">var</span> visited = &#123;&#125;;<br><span class="hljs-keyword">var</span> workset = new WorkSet();<br>workset.add(<span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">this</span>);<br><br><span class="hljs-keyword">while</span>(!workset.isEmpty()) &#123;<br><span class="hljs-keyword">var</span> name = = workset.pick();<br><span class="hljs-keyword">var</span> member = workset.<span class="hljs-keyword">get</span>(name);<br>workset.remove(name);<br><span class="hljs-keyword">if</span>(name <span class="hljs-keyword">in</span> visited) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>visited[name] = member;<br><br><span class="hljs-keyword">if</span>(member === other) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>member.friends.forEach(function(friend) &#123;<br>workset.add(friend.name, friend);<br>&#125;)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上pick方法是一个不确定性的例子， 不确定性指的是一个操作不能保证使用语言的语意产生一个单一的可预见的结果。这个不确定性来源于这样一个事实，for…in循环可能在不同的JavaScript环境中选择不同的枚举顺序。<br>基于这些原因，考虑使用一个确定的工作集算法替代方案是值得的。集工作列表算法Work-list.</p><ul><li>使用for…in循环枚举一个对象属性时，确保不要修改该对象</li><li>当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环代替for…in循环</li><li>为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象</li></ul><h2 id="数组迭代优先使用for循环而不是for-in"><a href="#数组迭代优先使用for循环而不是for-in" class="headerlink" title="数组迭代优先使用for循环而不是for...in"></a>数组迭代优先使用<code>for</code>循环而不是<code>for...in</code></h2><p>看下面代码mean的输出值时多少？</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> scores = [98, 74, 85, 77, 93, 100, 89];<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">total</span> = 0;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">score</span> <span class="hljs-keyword">in</span> scores) &#123;<br><span class="hljs-keyword">total</span> += <span class="hljs-keyword">score</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">mean</span> = <span class="hljs-keyword">total</span> / socres.length;<br><br> <span class="hljs-keyword">mean</span>; <span class="hljs-comment">// ?  17636.571428571428</span><br><br><br> 请记住即使是数组的索引属性，对象属性的key始终是字符串<br><br> <span class="hljs-keyword">total</span> = 0 + <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-string">&quot;3&quot;</span> + <span class="hljs-string">&quot;4&quot;</span> + <span class="hljs-string">&quot;5&quot;</span> + <span class="hljs-string">&quot;6&quot;</span>;<br><br> <span class="hljs-keyword">total</span> = <span class="hljs-string">&quot;00123456&quot;</span>;<br><br><br></code></pre></td></tr></table></figure><p>迭代数组内容的正确方式是使用传统的for循环, 建议存储数组长度到一个局部变量中</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> scores = [<span class="hljs-number">98</span>, <span class="hljs-number">74</span>, <span class="hljs-number">85</span>, <span class="hljs-number">77</span>, <span class="hljs-number">93</span>, <span class="hljs-number">100</span>, <span class="hljs-number">89</span>];<br><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = scores.<span class="hljs-built_in">length</span>; i &lt; n; i++) &#123;<br>total += socres[i];<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">mean</span> = toal / scores.<span class="hljs-built_in">length</span>;<br><br><span class="hljs-built_in">mean</span>; <span class="hljs-comment">// 88</span><br><br></code></pre></td></tr></table></figure><h2 id="迭代方法由于循环"><a href="#迭代方法由于循环" class="headerlink" title="迭代方法由于循环"></a>迭代方法由于循环</h2><p>一些常见的for循环错误</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) <span class="hljs-meta">&#123;...&#125;</span>. // 获取最后一项错误<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-meta">&#123;...&#125;</span>. // 丢失第一项<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = n; i &gt;= <span class="hljs-number">0</span> ; i--) <span class="hljs-meta">&#123;...&#125;</span>. // 获取起始值错误<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span> ; i--) <span class="hljs-meta">&#123;...&#125;</span>. // 丢失最后一项<br><br></code></pre></td></tr></table></figure><p>我们面对这样一个事实，搞清楚终止条件是一个累赘。<br>幸运的是ES5提供了一些便利的方法。Array.prototype.forEach是其中最简单的一个。例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = players.<span class="hljs-built_in">length</span>; i &lt; n; i++) &#123;<br>players[i].score++;<br>&#125;<br>可以用下面代码替换<br>players.forEach(<span class="hljs-keyword">function</span>(<span class="hljs-params">p</span>) &#123;<br>p.socre++;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>这段代码不仅更简单可读而且消除了终止条件和任何数组索引。</p><p>另一个例子是对数组进行操作后建立一个新的数组我们可以这样实现</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> trimmed = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = input.lenght; i &lt; n; i++) &#123;<br>trimmed.<span class="hljs-built_in">push</span>(input[i].<span class="hljs-built_in">trim</span>());<br>&#125;<br><br>我们同样可以使用forEach来实现<br><br><span class="hljs-keyword">var</span> trimmed = [];<br>input.forEach(<span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>trimmed.<span class="hljs-built_in">push</span>(s.<span class="hljs-built_in">trim</span>());<br>&#125;);<br><br><br>因为这是一个十分普遍的操作，所以ES5提供了一个更简单优雅的实现<span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">map</span><br><br><span class="hljs-keyword">var</span> trimmed = input.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br><span class="hljs-keyword">return</span> s.<span class="hljs-built_in">trim</span>();<br>&#125;)<br><br><br></code></pre></td></tr></table></figure><p>另外一种常见的模式是计算一个新的数组，该数组只包含现有数组的一部分元素.<code>Array.prototype.filter</code>使其变得简单</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>listings.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">listing</span>) &#123;<br><span class="hljs-keyword">return</span> listing.price &gt;= <span class="hljs-built_in">min</span> &amp;&amp; listing.price &lt;= <span class="hljs-built_in">max</span>;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>这些都是ES5的默认方法，我们当然可以实现自己的方法，比如我们需要这样一个模式，提取满足谓词的数组的前几个元素</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">takeWhile</span>(<span class="hljs-params">a</span>, <span class="hljs-params">pred</span>) &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-variable">a</span>.<span class="hljs-property">length</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">n</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span><span class="hljs-title function_">pred</span>(<span class="hljs-variable">a</span>[<span class="hljs-variable">i</span>], <span class="hljs-variable">i</span>)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-variable">result</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-variable">a</span>[<span class="hljs-variable">i</span>];<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">result</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">taleWhile</span>([1, 2, 4, 8, 16, 32], <span class="hljs-params">function</span>(<span class="hljs-params">n</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">n</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br>&#125;);<br><br><span class="hljs-comment">// [1, 2, 4, 8]</span><br><br><br></code></pre></td></tr></table></figure><p>请注意我们将索引i赋值给了pred, 我们可以选择使用或忽略该索引。事实上标准库中的所有迭代方法包括(forEach, map, filter)都将数组索引传递给了用户自定义函数。</p><p>我们也可以将takeWhile加入到Array.prototype中参考猴子补丁的影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">takeWhile</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">pred</span>) &#123;<br><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_">pred</span>(<span class="hljs-variable language_">this</span>[i], i)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>result[i] = <span class="hljs-variable language_">this</span>[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">var</span> prefix = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>].<span class="hljs-title function_">takeWhile</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br><span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">10</span>;<br>&#125;)<br><br></code></pre></td></tr></table></figure><blockquote><p>循环只有一点优于迭代函数，那就是前者有控制流操作，如break 和continue。 </p></blockquote><p>举例来说</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">takeWhile</span>(<span class="hljs-params">a</span>, <span class="hljs-params">pred</span>) &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> [];<br><span class="hljs-variable">a</span>.<span class="hljs-property">forEach</span>(<span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>, <span class="hljs-params">i</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span><span class="hljs-title function_">pred</span>(<span class="hljs-variable">x</span>)) &#123;<br><span class="hljs-comment">// ?</span><br>&#125;<br><span class="hljs-variable">result</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-variable">x</span>;<br>&#125;);<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">result</span>;<br>&#125;<br><br>我们可以使用一个内部异常来提前终止该循环，但是这既尴尬又效率低下<br><br><span class="hljs-variable">function</span> <span class="hljs-title function_">takeWhile</span>(<span class="hljs-params">a</span>, <span class="hljs-params">pred</span>) &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> [];<br><span class="hljs-keyword">var</span> <span class="hljs-variable">earlyExit</span> <span class="hljs-operator">=</span> [];<br><span class="hljs-title function_">try</span> &#123;<br><span class="hljs-variable">a</span>.<span class="hljs-property">forEach</span>(<span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>, <span class="hljs-params">i</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span><span class="hljs-title function_">pred</span>(<span class="hljs-variable">x</span>)) &#123;<br><span class="hljs-variable">throw</span> <span class="hljs-variable">earlyExit</span>;<br>&#125;<br><br><span class="hljs-variable">result</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-variable">x</span>;<br>&#125;);<br>&#125; <span class="hljs-title function_">catch</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">e</span> <span class="hljs-operator">!=</span><span class="hljs-operator">=</span> <span class="hljs-variable">earlyExit</span>) &#123;<br><span class="hljs-variable">throw</span> <span class="hljs-variable">e</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">result</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ES5的数组方法some和every可以用于提前终止循环。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">[<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>].some(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;.<span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">5</span>; &#125;);  <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>].some(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;.<span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span>; &#125;);  <span class="hljs-comment">// false</span><br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>].every(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;.<span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span>; &#125;);  <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>].every(<span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;.<span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">3</span>; &#125;);  <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p>利用这一点我们可以重新实现takeWhile方法</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs wren"><br><span class="hljs-variable">function</span> <span class="hljs-title function_">takeWhile</span>(<span class="hljs-params">a</span>, <span class="hljs-params">pred</span>) &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> [];<br><br><span class="hljs-variable">a</span>.<span class="hljs-property">every</span>(<span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>, <span class="hljs-params">i</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span><span class="hljs-title function_">pred</span>(<span class="hljs-variable">x</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// break</span><br>&#125;<br><br><span class="hljs-variable">result</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-variable">x</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// continue</span><br>&#125;);<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">result</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>使用迭代方法 forEach 和map替换for循环使得代码更可读，并且避免了重复循环控制逻辑</li><li>使用自定义的迭代函数来抽象未被标准库支持的常见循环模式</li><li>在需要提前终止循环的情况下， 仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出</li></ul><h2 id="在类数组对象上复用通用的数组方法"><a href="#在类数组对象上复用通用的数组方法" class="headerlink" title="在类数组对象上复用通用的数组方法"></a>在类数组对象上复用通用的数组方法</h2><p><code>Array.prototype</code>中的标准方法被设计成其他对象可复用的方法，即使这些对象并没有继承Array,一个很好的例子 函数的arguments对象，它并没有继承Array.prototype，因此我们不能简单的调用arguments.forEach方法来遍历每一个参数。取而代之我们提取forEach方法对象的引用并使用其call方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 同样也可先转化为一个数组 var args = [].slice.call(arguments);</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">highlight</span>(<span class="hljs-params"></span>) &#123;<br>[].<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">widget</span>) &#123;<br>widget.<span class="hljs-title function_">setBackground</span>(<span class="hljs-string">&quot;yellow&quot;</span>);<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如何使一个对象“看起来像数组”，数组对象的基本契约总共有两个简单规则</p><ul><li>具有一个范围在0-2^32-1的整型length属性。</li><li>length属性大于该对象的最大索引。索引的范围是0-2^32-2的整数，它的字符串表示就是该对象的一个key</li></ul><p>例子</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arrayLike = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">map</span>.call(arrayLike, <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br><span class="hljs-keyword">return</span> s.toUpperCase();<br>&#125;);<br><br><span class="hljs-comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br></code></pre></td></tr></table></figure><p>字符串也表现为不可变的数组，因为它们是可索引的， 并且其长度也可以通过length属性获取。因此，Array.prototype中的方法操作字符串不回修改原始数组。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">map</span>.call(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br><span class="hljs-keyword">return</span> s.toUpperCase();<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>对于使用Array.prototype中的方法，在增加或删除索引属性的时候它们都会强制的更新length属性。所有的Array.prototype方法在类数组中可以通用。</p><p>只有一个Array方法不是通用的那就是数组连接方法concat。该方法可以由任意的类数组调用但是它会检查其参数的[[Class]]属性，如果是一个真实的数组才会连接，如果不是例子如下</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">nameColum</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">[&quot;Names&quot;].concat(arguments)</span>;<br>&#125;<br><br>namesColumn(<span class="hljs-string">&quot;Alice&quot;</span>,<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Chris&quot;</span>);<br><br><br>// [<span class="hljs-string">&quot;Names&quot;</span>, &#123;.<span class="hljs-number">0</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Chris&quot;</span> &#125;]<br><br>这种时候我们可以使用数组转换的方法<br><span class="hljs-keyword">function</span> <span class="hljs-title">nameColum</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">[&quot;Names&quot;].concat([].slice.call(arguments))</span>;<br>&#125;<br><br>namesColumn(<span class="hljs-string">&quot;Alice&quot;</span>,<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Chris&quot;</span>);<br><br>// [<span class="hljs-string">&quot;Names&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>,<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Chris&quot;</span>]<br><br></code></pre></td></tr></table></figure><h2 id="数组字面量优于数组构造函数"><a href="#数组字面量优于数组构造函数" class="headerlink" title="数组字面量优于数组构造函数"></a>数组字面量优于数组构造函数</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br>也可以使用数组构造函数来替代<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br><br>有这样几个问题<br>首先要保证没有人重新包装过<span class="hljs-keyword">Array</span>变量<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span></span>(<span class="hljs-keyword">Array</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>&#125;<br><br>f(<span class="hljs-keyword">String</span>);  <span class="hljs-comment">//  new String(1)</span><br><br>其次要确保没人修改过全局<span class="hljs-keyword">Array</span>变量<br><br><span class="hljs-keyword">Array</span> = <span class="hljs-keyword">String</span>;<br><span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// new String(1)</span><br><br><br><br>还有一个问题 <br><br>[<span class="hljs-string">&quot;hello&quot;</span>] 和 <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-string">&quot;hello&quot;</span>) 行为虽然一致<br><br>但是<br><br>[<span class="hljs-number">17</span>] 和 <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">17</span>) 行为完全不同了<br><br></code></pre></td></tr></table></figure><ul><li>使用数组字面量替代数组构造函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (七)</title>
    <link href="/2018/09/19/2018-09-19-read-book-effective-seven/"/>
    <url>/2018/09/19/2018-09-19-read-book-effective-seven/</url>
    
    <content type="html"><![CDATA[<h2 id="理解prototype-getPrototypeOf-和-proto-之间的不同"><a href="#理解prototype-getPrototypeOf-和-proto-之间的不同" class="headerlink" title="理解prototype,getPrototypeOf 和__proto__之间的不同"></a>理解prototype,getPrototypeOf 和__proto__之间的不同</h2><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, passwordHash</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">passwordHash</span> = passwordHash;<br>&#125;<br><br><span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[User &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; ]&quot;</span>;<br>&#125;;<br><br><span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">checkPassword</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">password</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">hash</span>(password) === <span class="hljs-variable language_">this</span>.<span class="hljs-property">passwordHash</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;sfalken&quot;</span>, <span class="hljs-string">&quot;objjowewe&quot;</span>);<br><br><span class="hljs-comment">// ES5 提供了Obejct.getPrototypeOf() 来获得对象的原型</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(u) === <span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br><br>非标准的环境提供一个特殊的__proto__属性，在这些环境下可以这样检测<br>u.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br><br><br></code></pre></td></tr></table></figure><h2 id="使用Object-getPrototypeOf的函数而不要使用-proto-属性"><a href="#使用Object-getPrototypeOf的函数而不要使用-proto-属性" class="headerlink" title="使用Object.getPrototypeOf的函数而不要使用__proto__属性"></a>使用Object.getPrototypeOf的函数而不要使用__proto__属性</h2><p>并不是所有的JavaScript环境都支持通过__proto__属性来获取对象的原型，因此该属性并不是完全兼容的。由于__proto__会污染所有的对象，因此它会导致大量的Bug。</p><p>但是无论在什么情况下 <code>Object.getPrototypeOf</code>函数都是有效的。</p><p>对于没有提供ES5 API的JavaScript环境，我们可以利用__proto__属性来实现Object.getPrototypeOf的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">getPrototypeOf</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property">getPrototypeOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123;<br><span class="hljs-keyword">var</span> t = <span class="hljs-keyword">typeof</span> obj;<br><span class="hljs-keyword">if</span>(!obj || (t !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; t !== <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;not an object&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> obj.<span class="hljs-property">__proto__</span>;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="始终不要修改-ptoto-属性"><a href="#始终不要修改-ptoto-属性" class="headerlink" title="始终不要修改__ptoto__属性"></a>始终不要修改__ptoto__属性</h2><p>原因：</p><ul><li>避免修改__proto__属性的最明显原因是可移植问题。毕竟不是所有平台都支持</li><li>避免修改__proto__属性的另一个原因是性能问题</li><li>避免修改__proto__属性的最大原因是为了保持行为的可预测性。</li></ul><p>可以使用ES5中的Object.create函数创建一个具有自定义原型链的新对象。对于不支持的ES5环境下下面有一种不依赖于__proto__可移植的实现。</p><h2 id="使用构造函数与new操作符无关"><a href="#使用构造函数与new操作符无关" class="headerlink" title="使用构造函数与new操作符无关"></a>使用构造函数与new操作符无关</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span><span class="hljs-params">(name, passwordHash)</span> &#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.passwordHash = passwordHash;<br>&#125;<br>如果使用<span class="hljs-keyword">new</span>操作符调用构造函数会是实例化一个对象，不使用<span class="hljs-keyword">new</span>函数的接收者将是全局对象。<br><br><br><span class="hljs-keyword">var</span> u = User(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;pass&quot;</span>);<br><br>u; <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">this</span>.name <span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-keyword">this</span>.passwordHash <span class="hljs-comment">// &quot;pass&quot;</span><br><br>如果User定为ES5的严格代码，那么它的接收者默认为<span class="hljs-literal">undefined</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span><span class="hljs-params">(name, passwordHash)</span> &#123;<br><span class="hljs-string">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.passwordHash = passwordHash;<br>&#125;<br><span class="hljs-keyword">var</span> u = User(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;pass&quot;</span>);<br><br><span class="hljs-comment">// error this is undefined</span><br><br></code></pre></td></tr></table></figure><p>所以无论是否用new都可以使用构造函数，为了保证代码的健壮性最好是提供一个不管怎样都会工作的代码。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">User</span>(<span class="hljs-type">name</span>, pass) &#123;<br><span class="hljs-keyword">if</span>(!(this instanceof <span class="hljs-keyword">User</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(<span class="hljs-type">name</span>, pass);<br>&#125;<br><br>this.name = <span class="hljs-type">name</span>;<br>this.pass = pass;<br>&#125;<br><br>var x = <span class="hljs-keyword">User</span>(&quot;hello&quot;, &quot;pas1&quot;);<br><br>var y = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(&quot;hel&quot;, &quot;pas2&quot;);<br><br>x instanceof <span class="hljs-keyword">User</span> // <span class="hljs-keyword">true</span><br><br>y instanceof <span class="hljs-keyword">User</span> // <span class="hljs-keyword">true</span><br><br><br><br></code></pre></td></tr></table></figure><p>这种方式不管怎样调用构造函数都会返回一个继承了User.prototype的实例对象。<br>这种模式的缺点是有一次额外的函数调用，ES5有一种更奇异的调用方式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">User</span>(<span class="hljs-type">name</span>, pass) &#123;<br>var self = this instanceof <span class="hljs-keyword">User</span><br>? this<br>: Obejct.<span class="hljs-keyword">create</span>(<span class="hljs-keyword">User</span>.prototype);<br><br>self.name = <span class="hljs-type">name</span>;<br>self.pass = pass;<br><span class="hljs-keyword">return</span> self;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种方式只有在ES5中才可以使用，对于不支持的环境，我们可以制造一个兼容性的版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这里只实现了单参数版本的Object.create</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">creat</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">prototype</span>) &#123;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) &#123;&#125;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="在原型中存储方法"><a href="#在原型中存储方法" class="headerlink" title="在原型中存储方法"></a>在原型中存储方法</h2><ul><li>将方法存储到实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本</li><li>将方法存储于原型中优于存储在实例对象中</li></ul><h2 id="使用闭包存储私有变量"><a href="#使用闭包存储私有变量" class="headerlink" title="使用闭包存储私有变量"></a>使用闭包存储私有变量</h2><p>闭包将数据存储到封闭的变量中而不提供对这些变量的直接访问，获取闭包内容结构的唯一方式是该函数显示的提供获取它的途径。</p><blockquote><p>对象和闭包剧哟相反的策略，对象的属性会被自动暴露出去，然而闭包中的变量会被自动隐藏起来。</p></blockquote><p>我们可以利用这一特性在对象中存储真正的私有数据。不是将数据作为对象属性来存储而是在构造函数中以变量的方式来存储它，并将对象的方法转为引用这些变量的闭包</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span><span class="hljs-params">(name, passwordHash)</span> &#123;<br><span class="hljs-keyword">this</span>.toString = <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[User &quot;</span> + name +<span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><span class="hljs-keyword">this</span>.checkPassword = <span class="hljs-keyword">function</span><span class="hljs-params">(password)</span> &#123;<br><span class="hljs-keyword">return</span> hash(password) === passwordHash;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里name和passwordHash并不是以this的属性存储的，读取不到this.name 和this.passwordHash， User不包含任何实例属性。<br>该模式有一个缺点为了让构造函数的变量 在使用它们的方法的作用域中，这些方法必须置于实例对象中。 因此违背了上一条<code>在原型中存储方法</code><br>但是为了那些看中保障信息隐藏的情形来说，这点额外代价是值得的</p><h2 id="在子类的构造函数中调用父类的构造函数"><a href="#在子类的构造函数中调用父类的构造函数" class="headerlink" title="在子类的构造函数中调用父类的构造函数"></a>在子类的构造函数中调用父类的构造函数</h2><p>如果正确构建父子级关系的对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function Actor(scene, x, y) &#123;<br><span class="hljs-keyword">this</span>.scene = scene;<br><span class="hljs-keyword">this</span>.x = x;<br><span class="hljs-keyword">this</span>.y = y;<br>scene.register(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>Actor.prototype.moveTo = function(x, y) &#123;<br><span class="hljs-keyword">this</span>.x = x;<br><span class="hljs-keyword">this</span>.y = y;<br><span class="hljs-keyword">this</span>.scene.draw();<br>&#125;<br><br>Actor.prototype.exit = function() &#123;<br><span class="hljs-keyword">this</span>.scene.unregister(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">this</span>.scene.draw();<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>如果我们要创建一个Actor的一个子类， 名字为SpaceShip怎么办</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SpaceShip</span>(<span class="hljs-params">scene, x, y</span>) &#123;<br><span class="hljs-title class_">Actor</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, scene, x, y);  <br><span class="hljs-comment">// 这里SpaceShip的实例对象作为方法的接收者，会将Actor的实例属性加到SpaceShip的实例上，从而继承了Actor的实例属性</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">points</span> = &#123;&#125;;<br>&#125;<br><br><span class="hljs-title class_">Actor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">moveTo</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">draw</span>();<br>&#125;<br><br><span class="hljs-title class_">Actor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">exit</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">unregister</span>(<span class="hljs-variable language_">this</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">draw</span>();<br>&#125;<br><br>如何继承<span class="hljs-title class_">Actor</span>的prototype中的方法呢，我们可以使用之前提到过的<span class="hljs-title class_">ES5</span>下的 <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(非<span class="hljs-title class_">ES5</span>需要自己实现<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>)<br><br><span class="hljs-title class_">SpaceShip</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Actor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>这样就很好的实现了继承<br><br><br></code></pre></td></tr></table></figure><h2 id="避免使用轻率的猴子补丁"><a href="#避免使用轻率的猴子补丁" class="headerlink" title="避免使用轻率的猴子补丁"></a>避免使用轻率的猴子补丁</h2><p>由于对象共享原型，因此每一个对象都可以增加、删除、或修改原型的属性，这个有争议的实现通常被称为猴子补丁（monkey-patching）</p><p>猴子补丁的吸引力在于它的强大。数组缺少一个有用的方法吗？</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">Array.prototype.split = function(i) &#123;<br><span class="hljs-built_in">return </span>[this.slice(0, i), this.slice(i)];<br>&#125;<br><br>//Error Everry<span class="hljs-built_in"> array </span>instance has a split method<br></code></pre></td></tr></table></figure><p>当多个库以不兼容的方式给同一个原型打猴子补丁时，问题便出现了，另外的库可能使用同一个方法给Array.prototype打猴子补丁，这样会有冲突。<br>一种替代的方法是增加一个<code>addArrayMethods</code>方法,用户可以选择调用或者忽略</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addArrayMethods</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">split</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br><span class="hljs-keyword">return</span> [this.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>,i), this.<span class="hljs-built_in">slice</span>(i)];<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>尽管猴子补丁很危险但是有一种特别可靠而且有价值的使用场景 polyfill. ES5定义一些新的Array方法（forEach, map和filter）,如果一些浏览器版本可能不支持这些版本我们可以通过猴子补丁来实现。由于这些行为是标准化的，所以不会造成库与库之间的不兼容风险。</p>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数柯里化</title>
    <link href="/2018/09/17/2018-09-17-js-base-currying/"/>
    <url>/2018/09/17/2018-09-17-js-base-currying/</url>
    
    <content type="html"><![CDATA[<h2 id="JS-函数柯里化"><a href="#JS-函数柯里化" class="headerlink" title="JS 函数柯里化"></a>JS 函数柯里化</h2><p>什么是函数柯里化？ 柯里化通常也称部分求值，其含义是给函数分步传递参数。 </p><blockquote><p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p></blockquote><p>一个简单的函数柯里化例子</p><figure class="highlight wren"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">var</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">+</span> <span class="hljs-variable">y</span>;<br>&#125;<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">var</span> <span class="hljs-variable">addCurry</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">y</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">+</span> <span class="hljs-variable">y</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>);<br><br></code></pre></td></tr></table></figure><p>上面的例子是一个最简单的柯里化例子， 现在又有新的需要我需要能传多个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">items</span>) &#123;<br><span class="hljs-keyword">return</span> items.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;);<br>&#125;<br><br><span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br>但如果要求把每个数乘以<span class="hljs-number">10</span>之后再相加，那么：<br><br><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">items, multi</span>) &#123;<br><br><span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br><span class="hljs-keyword">return</span> item * multi<br>&#125;).<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;)<br><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">10</span>));<br><br></code></pre></td></tr></table></figure><p>下面是柯里化实现：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> adder = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> _args = [];<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span>(arguments.<span class="hljs-built_in">length</span> === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> _args.<span class="hljs-built_in">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;);<br>&#125;<br><br>[].<span class="hljs-built_in">push</span>.apply(args, [].<span class="hljs-built_in">slice</span>.call(arguments))<br><br><span class="hljs-keyword">return</span> arguments.callee;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">sum</span> = adder();<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>);<br><br><span class="hljs-built_in">sum</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)(<span class="hljs-number">300</span>);   <span class="hljs-comment">// 调用形式灵活， 一次调用可输入一个或多个参数， 并且支持链式调用</span><br><br><span class="hljs-built_in">sum</span>(<span class="hljs-number">400</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>());  <span class="hljs-comment">// 没有参数进行加总计算</span><br><br></code></pre></td></tr></table></figure><p>adder是柯里化了的函数，它返回一个新的函数，新的函数接收可分批次接受新的参数，延迟到最后一次计算。</p><p>通用的柯里化函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> currying = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br><span class="hljs-keyword">var</span> _args = [];<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span>(arguments.<span class="hljs-built_in">length</span> === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> fn.apply(this, _args);<br>&#125;<br><br><span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">push</span>.apply(_args, [].<span class="hljs-built_in">slice</span>.call(arguments));<br><span class="hljs-keyword">return</span> arguments.callee;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> multi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, c = arguments.<span class="hljs-built_in">length</span>; i &lt; c; i++) &#123;<br>total += c;<br>&#125;<br><br><span class="hljs-comment">// for一个特别骚的写法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, c; c = arguments[i++];) &#123;<br>total += c;<br>&#125;<br><br><span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">sum</span> = currying(multi);<br><br><span class="hljs-built_in">sum</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)(<span class="hljs-number">300</span>);<br><span class="hljs-built_in">sum</span>(<span class="hljs-number">400</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>());<br><br></code></pre></td></tr></table></figure><p>上面的代码其实是一个高阶函数。</p><blockquote><p>高阶函数是指操作函数的函数，它接受一个或者多个函数作为参数，并返回一个新函数。</p></blockquote><p> 此外还依赖闭包的特性，来保存中间过程中输入的参数</p><ul><li>函数可以作为参数传递</li><li>函数能够作为函数的返回值</li><li>闭包</li></ul><p>柯里化的作用</p><ul><li>延迟计算</li><li>参数复用， 当在多次调用同一个函数，并且传递的参数绝大多数相同，那么该函数可能是一个很好的柯里化候选</li><li>动态创建函数， 这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了计算</li></ul><p>比如一个绑定事件的辅助方法</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">var</span> <span class="hljs-variable">addEvent</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">el</span>, <span class="hljs-params">type</span>, <span class="hljs-params">fn</span>, <span class="hljs-params">capture</span>) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">window</span>.<span class="hljs-property">addEventListener</span>) &#123;<br><span class="hljs-variable">el</span>.<span class="hljs-property">addEventListener</span>(<span class="hljs-variable">type</span>, <span class="hljs-title function_">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-variable">fn</span>.<span class="hljs-property">call</span>(<span class="hljs-variable">el</span>, <span class="hljs-variable">e</span>);<br>&#125;, <span class="hljs-variable">capture</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">window</span>.<span class="hljs-property">attachEvent</span>) &#123;<br><span class="hljs-variable">el</span>.<span class="hljs-property">attachEvent</span>(<span class="hljs-string">&quot;on&quot;</span><span class="hljs-operator">+</span><span class="hljs-variable">type</span>, <span class="hljs-title function_">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-variable">fn</span>.<span class="hljs-property">call</span>(<span class="hljs-variable">el</span>, <span class="hljs-variable">e</span>);<br>&#125;)<br>&#125;<br>&#125;<br><br>每次添加事件处理都要执行一遍 <span class="hljs-keyword">if</span><span class="hljs-operator">...</span><span class="hljs-keyword">else</span><span class="hljs-operator">...</span>，其实在一个浏览器中只要一次判定就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。<br><br><span class="hljs-keyword">var</span> <span class="hljs-variable">addEvent</span> <span class="hljs-title function_">=</span> (<span class="hljs-title function_">function</span>()&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">window</span>.<span class="hljs-property">addEventListener</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">el</span>, <span class="hljs-params">sType</span>, <span class="hljs-params">fn</span>, <span class="hljs-params">capture</span>) &#123;<br>            <span class="hljs-variable">el</span>.<span class="hljs-property">addEventListener</span>(<span class="hljs-variable">sType</span>, <span class="hljs-title function_">function</span>(<span class="hljs-params">e</span>) &#123;<br>                <span class="hljs-variable">fn</span>.<span class="hljs-property">call</span>(<span class="hljs-variable">el</span>, <span class="hljs-variable">e</span>);<br>            &#125;, (<span class="hljs-variable">capture</span>));<br>        &#125;;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">window</span>.<span class="hljs-property">attachEvent</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">el</span>, <span class="hljs-params">sType</span>, <span class="hljs-params">fn</span>, <span class="hljs-params">capture</span>) &#123;<br>            <span class="hljs-variable">el</span>.<span class="hljs-property">attachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">sType</span>, <span class="hljs-title function_">function</span>(<span class="hljs-params">e</span>) &#123;<br>                <span class="hljs-variable">fn</span>.<span class="hljs-property">call</span>(<span class="hljs-variable">el</span>, <span class="hljs-variable">e</span>);<br>            &#125;);<br>        &#125;;<br>    &#125;<br>&#125;)();<br><br></code></pre></td></tr></table></figure><p>Function.prototype.bind 方法也是柯里化应用</p><p>与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">888</span>&#125;;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);<br>&#125;.<span class="hljs-title function_">bind</span>(foo);               <span class="hljs-comment">// 绑定</span><br><span class="hljs-title function_">bar</span>();                     <span class="hljs-comment">// 888</span><br><br><span class="hljs-comment">// 猜测bind的实现</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">testBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">scope</span>) &#123;<br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>;                    <span class="hljs-comment">//// this 指向的是调用 testBind 方法的一个函数， </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(scope);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> testBindBar = bar.<span class="hljs-title function_">testBind</span>(foo);  <span class="hljs-comment">// 绑定 foo，延迟执行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testBindBar);             <span class="hljs-comment">// Function (可见，bind之后返回的是一个延迟执行的新函数)</span><br><span class="hljs-title function_">testBindBar</span>();                        <span class="hljs-comment">// 888</span><br><br></code></pre></td></tr></table></figure><p>再来看这道面试题<br>编程题目的要求如下，完成plus函数，通过全部的测试用例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">n</span>)&#123;<br>  <br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = plus<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>)<br><br><span class="hljs-keyword">var</span> plus = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../lib/assign-4&#x27;</span>)<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;闭包应用&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;plus(0) === 0&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">0</span>,<span class="hljs-title function_">plus</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;plus(1)(1)(2)(3)(5) === 12&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">12</span>,<span class="hljs-title function_">plus</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;plus(1)(4)(2)(3) === 10&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">10</span>,<span class="hljs-title function_">plus</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;方法引用&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> plus2 = <span class="hljs-title function_">plus</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">1</span>)<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">12</span>,<span class="hljs-title function_">plus2</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>答案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">num</span>)&#123;<br><span class="hljs-keyword">var</span> adder = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> _args = [];<br><br><span class="hljs-keyword">var</span> _adder = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>[].<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(_args, [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>));<br><span class="hljs-keyword">return</span> _adder;<br>&#125;<br><br>_adder.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> _args.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;);<br>&#125;<br><br><span class="hljs-keyword">return</span> _adder;<br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">adder</span>()(num);<br>  <br>&#125;<br><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = plus;<br><br></code></pre></td></tr></table></figure><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="https://www.cnblogs.com/zztt/p/4142891.html#3078374">函数 currying 柯里化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>js基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试题</title>
    <link href="/2018/09/11/2018-09-11-inverview-css/"/>
    <url>/2018/09/11/2018-09-11-inverview-css/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>说出下面s1,s2, s5,s6的答案</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s2&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s5&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s6&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>.p1 &#123;font-size: 16px; line-height: 32px;&#125;<br>.s1 &#123;font-size: 2em;&#125;<br>.s2 &#123;font-size: 2em; line-height: 2em;&#125;<br><br>.p2 &#123;font-size: 16px; line-height: 2;&#125;<br>.s5 &#123;font-size: 2em;&#125;<br>.s6 &#123;font-size: 2em; line-height: 2em;&#125;<br><br></code></pre></td></tr></table></figure><p>先来看第一组的答案</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">p1：font-size: <span class="hljs-number">16</span>px; line-height: <span class="hljs-number">32</span>px<br>s1：font-size: <span class="hljs-number">32</span>px; line-height: <span class="hljs-number">32</span>px<br>s2：font-size: <span class="hljs-number">32</span>px; line-height: <span class="hljs-number">64</span>px<br></code></pre></td></tr></table></figure><p>和你的答案一样吗？下面来解释下:</p><blockquote><p>p1 无需解释<br>s1 em作为字体单位，相对于父元素字体大小；line-height继承父元素计算值<br>s2 em作为行高单位时，相对于自身字体大小<br>再来看看第二组的答案</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">p2：font-size: <span class="hljs-number">16</span>px; line-height: <span class="hljs-number">32</span>px<br>s5：font-size: <span class="hljs-number">32</span>px; line-height: <span class="hljs-number">64</span>px<br>s6：font-size: <span class="hljs-number">32</span>px; line-height: <span class="hljs-number">64</span>px<br></code></pre></td></tr></table></figure><p>意不意外？惊不惊喜？下面来解释下</p><blockquote><p>p2 line-height: 2自身字体大小的两倍<br>s5 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍<br>s6 无需解释</p></blockquote><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;.&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试题</title>
    <link href="/2018/09/11/2018-09-11-inverview-html/"/>
    <url>/2018/09/11/2018-09-11-inverview-html/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="/2018/09/11/2018-09-11-inverview-js/"/>
    <url>/2018/09/11/2018-09-11-inverview-js/</url>
    
    <content type="html"><![CDATA[<h3 id="在浏览器输入-URL-回车之后发生了什么"><a href="#在浏览器输入-URL-回车之后发生了什么" class="headerlink" title="在浏览器输入 URL 回车之后发生了什么"></a>在浏览器输入 URL 回车之后发生了什么</h3><p><a href="https://4ark.me/post/b6c7c0a2.html#%E5%89%8D%E8%A8%80">在浏览器输入 URL 回车之后发生了什么</a></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><br>var a<span class="hljs-comment">;</span><br><br>console.log(a)<span class="hljs-comment">;  // 结果</span><br><br></code></pre></td></tr></table></figure><p>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在的作用域中使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><br><br>foo(); <span class="hljs-regexp">//</span> TypeError<br>bar(); <span class="hljs-regexp">//</span> ReferenceErrtr<br><br>var foo = <span class="hljs-keyword">function</span> bar() &#123;<br><span class="hljs-regexp">//</span>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数优先提升, 重复的var会被忽略掉，但是后面的函数声明还是会覆盖前面</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arcade">foo();<br><br><span class="hljs-keyword">var</span> foo;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果是 1</span><br><br><br><br>foo();<br><br><span class="hljs-keyword">var</span> foo;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-comment">// 输出结果 3</span><br></code></pre></td></tr></table></figure><h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo:&quot;</span> + num);<br><br>this.<span class="hljs-built_in">count</span>++;<br>&#125;<br><br>foo.<span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> i;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">5</span>) &#123;<br>foo(i);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo.<span class="hljs-built_in">count</span>);<br><br></code></pre></td></tr></table></figure><p>还有一个更好的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><br></code></pre></td></tr></table></figure><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>JavaScript 只有词法作用域，没有动态作用域</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>foo();<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>bar();<br><br><br><span class="hljs-comment">// 输出结果是 2</span><br><br><br><br></code></pre></td></tr></table></figure><h3 id="使用立即调用函数IIFE创建局部作用域"><a href="#使用立即调用函数IIFE创建局部作用域" class="headerlink" title="使用立即调用函数IIFE创建局部作用域"></a>使用立即调用函数IIFE创建局部作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">wrapElements</span>(<span class="hljs-params">a</span>) &#123;<br><span class="hljs-keyword">var</span> result = [], i, n;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, n = a.<span class="hljs-property">length</span>; i &lt; n; i++) &#123;<br>result[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a[i] &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">var</span> wrapped = <span class="hljs-title function_">wrapElements</span>([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]);<br><br><span class="hljs-keyword">var</span> f = wrapped[<span class="hljs-number">0</span>];<br><br><span class="hljs-title function_">f</span>();  <span class="hljs-comment">// ? 输出结果 undefined</span><br><br><br><span class="hljs-comment">// 更具有欺骗性的例子</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">wrapElements</span>(<span class="hljs-params">a</span>) &#123;<br><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = a.<span class="hljs-property">length</span>; i &lt; n; i++) &#123;<br>result[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a[i] &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">var</span> wrapped = <span class="hljs-title function_">wrapElements</span>([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]);<br><br><span class="hljs-keyword">var</span> f = wrapped[<span class="hljs-number">0</span>];<br><br><br><span class="hljs-title function_">f</span>();  <span class="hljs-comment">// ? 输出结果 undefined</span><br><br><br></code></pre></td></tr></table></figure><p>在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123; returen <span class="hljs-number">17</span>; &#125;<br><span class="hljs-title function_">g</span>(); <span class="hljs-comment">// 17 (在非标准的环境中，标准环境会报错 g is not defined)</span><br><br><br>我们应该怎样做<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>; &#125;<br><span class="hljs-keyword">var</span> g = <span class="hljs-literal">null</span>;<br><br></code></pre></td></tr></table></figure><p>方法调用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> username=<span class="hljs-string">&quot;test&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-string">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-keyword">this</span>.username;<br>&#125;<br><br>hello(); <span class="hljs-string">&quot;hello, undefined&quot;</span><br><br></code></pre></td></tr></table></figure><p>bind绑定方法接收者，下面例子返回什么结果， 用尽可能多的方法修复该例子</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">buffer</span> = &#123;<br><span class="hljs-attr">entries</span>: [],<br><span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>this.entries.<span class="hljs-built_in">push</span>(s);<br>&#125;,<br><span class="hljs-attr">concat</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> this.entries.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> source = [<span class="hljs-string">&quot;867&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;5309&quot;</span>];<br><br>source.forEach(<span class="hljs-built_in">buffer</span>.add);  <span class="hljs-comment">// error: entries is undefined</span><br><br><br></code></pre></td></tr></table></figure><p>什么是函数柯里化？柯里化的作用</p><ul><li>延迟计算</li><li>参数复用， 当在多次调用同一个函数，并且传递的参数绝大多数相同，那么该函数可能是一个很好的柯里化候选</li><li>动态创建函数， 这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了计算</li></ul><p>函数柯里化 一道有难度的面试题,完成plus函数 满足通过所有的测试条件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params">n</span>)&#123;<br>  <br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = plus<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>)<br><br><span class="hljs-keyword">var</span> plus = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../lib/assign-4&#x27;</span>)<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;闭包应用&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;plus(0) === 0&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">0</span>,<span class="hljs-title function_">plus</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;plus(1)(1)(2)(3)(5) === 12&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">12</span>,<span class="hljs-title function_">plus</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;plus(1)(4)(2)(3) === 10&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">10</span>,<span class="hljs-title function_">plus</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;方法引用&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> plus2 = <span class="hljs-title function_">plus</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">1</span>)<br>    assert.<span class="hljs-title function_">equal</span>(<span class="hljs-number">12</span>,<span class="hljs-title function_">plus2</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>).<span class="hljs-title function_">toString</span>())<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="创建一个原型为null的对象用作字典"><a href="#创建一个原型为null的对象用作字典" class="headerlink" title="创建一个原型为null的对象用作字典"></a>创建一个原型为null的对象用作字典</h3><p>防止原型污染的最简单的方式之一就是一开始就不使用原型。但是ES5发布之前并没有一个标准的方式创建一个空原型的新对象。你可能会这样做<br>该例子是否能创建一个原型为null的对象。不能的话要怎么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) &#123; &#125;<br><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o) === <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o) === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// ES5之后应该这样做</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(o) === <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span><br><br>在不支持<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>的<span class="hljs-title class_">JavaScript</span>环境中特殊对象__proto__提供了对对象内部原型链的读写访问<br><br><span class="hljs-keyword">var</span> x = &#123; <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span> &#125;;<br><br>x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>;  <span class="hljs-comment">// false;</span><br><br></code></pre></td></tr></table></figure><p>第二种貌似更方便，但是有了Object.create函数后，Object.create是更值得推荐的方式。</p><h3 id="看下面代码mean的输出值时多少？"><a href="#看下面代码mean的输出值时多少？" class="headerlink" title="看下面代码mean的输出值时多少？"></a>看下面代码mean的输出值时多少？</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> scores = [98, 74, 85, 77, 93, 100, 89];<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">total</span> = 0;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">score</span> <span class="hljs-keyword">in</span> scores) &#123;<br><span class="hljs-keyword">total</span> += <span class="hljs-keyword">score</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">mean</span> = <span class="hljs-keyword">total</span> / socres.length;<br><br><br><span class="hljs-keyword">mean</span>; <span class="hljs-comment">// ?   </span><br><br><br></code></pre></td></tr></table></figure><h3 id="JavaScript位操作符的诀窍"><a href="#JavaScript位操作符的诀窍" class="headerlink" title="JavaScript位操作符的诀窍"></a>JavaScript位操作符的诀窍</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk">无符号右移自动转换成数字<br><span class="hljs-string">&quot;&quot;</span> &gt;&gt;&gt; <span class="hljs-number">0</span>.  <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><span class="hljs-string">&quot;sdsd&quot;</span> &gt;&gt;&gt; <span class="hljs-number">0</span>   <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><br>NaN &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><br>undefined &gt;&gt;&gt; <span class="hljs-number">0</span>  <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br> <br>null &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><br>[] &gt;&gt;&gt; <span class="hljs-number">0</span>  <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;70&quot;</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> <span class="hljs-number">70</span><br><br>&#123;&#125; &gt;&gt;&gt; <span class="hljs-number">0</span>. <span class="hljs-regexp">//</span> Uncaught SyntaxError: Unexpected token &gt;&gt;&gt;<br><br>～操作自动转换数字<br>负数转正数减一， 整数转负数减一， 其他-<span class="hljs-number">1</span><br><br>~<span class="hljs-string">&quot;sdsd&quot;</span> <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span><br>~<span class="hljs-string">&quot;0&quot;</span>    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~<span class="hljs-number">0</span>     <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~NaN    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~null    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~undefined    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~[]    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~&#123;&#125;    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~<span class="hljs-string">&quot;sdsd&quot;</span>    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~<span class="hljs-string">&quot;45sdsd&quot;</span>    <span class="hljs-regexp">//</span>-<span class="hljs-number">1</span><br>~<span class="hljs-string">&quot;-1&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br>~<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-regexp">//</span> -<span class="hljs-number">2</span><br><br><br></code></pre></td></tr></table></figure><h3 id="隐式转换一个题目"><a href="#隐式转换一个题目" class="headerlink" title="隐式转换一个题目"></a>隐式转换一个题目</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">如果想输出success英国如何定义a<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>)  &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;success&quot;</span>)<br>&#125;<br><br><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">Number</span>.prototype.valueOf = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> i++;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>( <span class="hljs-number">42</span> );<br><br></code></pre></td></tr></table></figure><h3 id="“1”-”12”-”121”-map-parseInt"><a href="#“1”-”12”-”121”-map-parseInt" class="headerlink" title="[“1”,”12”,”121”].map(parseInt)"></a>[“1”,”12”,”121”].map(parseInt)</h3><p>这是一个很有意思的题目乍一看认为可能会输出[1,12,123] 其实不然输入结果为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1,NaN, 1]</span><br><br></code></pre></td></tr></table></figure><p> 为什么会这样呢，我们知道parseInt方法可以将数字转为10进制的数值，parseInt(string, radix);其中第二个参数是基数<br> An integer between 2 and 36 that represents the radix (the base in mathematical numeral systems) of the string. Be careful — this does not default to 10.</p><p>而Array的map方法可以接受三个参数<br> <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> new_array = arr.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) &#123;<br>    <span class="hljs-comment">// Return element for new_array</span><br>&#125;[, thisArg])<br><br>这里不写参数默认将index作为基数传给了parseInt所以输出结果时并不是按照我们所想的 <br><br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-string">&quot;121&quot;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> parseInt(val)); 来输出的因为你发现这样写结果反而没有问题<br><br>真实结果是这样<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-string">&quot;121&quot;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-function">(<span class="hljs-params">val,index,<span class="hljs-built_in">array</span></span>) =&gt;</span> parseInt(val, index));<br><br></code></pre></td></tr></table></figure></p><h3 id="HTTP请求307什么时候会发生"><a href="#HTTP请求307什么时候会发生" class="headerlink" title="HTTP请求307什么时候会发生"></a>HTTP请求307什么时候会发生</h3><p>HTTP Strict Transport Security <code>HSTS</code>, 当在浏览器输入一个域名baidu.com, nginx启用了HSTS,重定向了 <a href="https://baidu.com,这时浏览器控制台会看到307/">https://baidu.com,这时浏览器控制台会看到307</a></p><h3 id="什么是DNS劫持和DNS污染"><a href="#什么是DNS劫持和DNS污染" class="headerlink" title="什么是DNS劫持和DNS污染"></a>什么是DNS劫持和DNS污染</h3><h3 id="babel的polyfill和runtime的区别"><a href="#babel的polyfill和runtime的区别" class="headerlink" title="babel的polyfill和runtime的区别"></a>babel的polyfill和runtime的区别</h3><h3 id="Promise为什么需要一个catch-done方法是干什么用的"><a href="#Promise为什么需要一个catch-done方法是干什么用的" class="headerlink" title="Promise为什么需要一个catch done方法是干什么用的"></a>Promise为什么需要一个catch done方法是干什么用的</h3><p>如果捕获promise的异常</p><h3 id="webpack-tree-shaking用来做什么的"><a href="#webpack-tree-shaking用来做什么的" class="headerlink" title="webpack  tree shaking用来做什么的"></a>webpack  tree shaking用来做什么的</h3>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (五)</title>
    <link href="/2018/09/11/2018-09-11-read-book-effective-five/"/>
    <url>/2018/09/11/2018-09-11-read-book-effective-five/</url>
    
    <content type="html"><![CDATA[<h2 id="理解变量提升"><a href="#理解变量提升" class="headerlink" title="理解变量提升"></a>理解变量提升</h2><p>try…catch 语句将捕获的异常绑定到一个变量，该变量的作用域只是catch语句块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;var&quot;</span>, result = [];<br>  result.<span class="hljs-title function_">push</span>(x);<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;exception&quot;</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(x) &#123;<br>    x = <span class="hljs-string">&quot;catch&quot;</span>;<br>  &#125;<br><br>  result.<span class="hljs-title function_">push</span>(x);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// [&quot;var&quot;, &quot;var&quot;]</span><br><br><br></code></pre></td></tr></table></figure><h2 id="使用立即调用函数IIFE创建局部作用域"><a href="#使用立即调用函数IIFE创建局部作用域" class="headerlink" title="使用立即调用函数IIFE创建局部作用域"></a>使用立即调用函数IIFE创建局部作用域</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">wrapElements</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [], i, n;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, n = a.<span class="hljs-property">length</span>; i &lt; n; i++) &#123;<br>    result[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a[i] &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">var</span> wrapped = <span class="hljs-title function_">wrapElements</span>([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]);<br><br><span class="hljs-keyword">var</span> f = wrapped[<span class="hljs-number">0</span>];<br><br><span class="hljs-title function_">f</span>();  <span class="hljs-comment">// ? 输出结果 undefined</span><br><br><br><span class="hljs-comment">// 更具有欺骗性的例子</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">wrapElements</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = a.<span class="hljs-property">length</span>; i &lt; n; i++) &#123;<br>    result[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a[i] &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">var</span> wrapped = <span class="hljs-title function_">wrapElements</span>([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]);<br><br><span class="hljs-keyword">var</span> f = wrapped[<span class="hljs-number">0</span>];<br><br><br><span class="hljs-title function_">f</span>();  <span class="hljs-comment">// ? 输出结果 undefined</span><br><br><br><span class="hljs-comment">// 为了避免这种问题需要用一个立即调用的函数创建一个局部作用域</span><br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> j = i;<br>  result[j] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a[j]; &#125;<br>&#125;)();<br><br><span class="hljs-comment">// or</span><br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>  result[j] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> a[j]; &#125;<br>&#125;)(i);<br><br><br></code></pre></td></tr></table></figure><h2 id="当心命名函数表达式笨拙的作用域"><a href="#当心命名函数表达式笨拙的作用域" class="headerlink" title="当心命名函数表达式笨拙的作用域"></a>当心命名函数表达式笨拙的作用域</h2><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>; &#125;<br><br>这里既可以是一个函数声明，也可以是一个命名函数表达式<br><br><span class="hljs-keyword">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>; &#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-variable">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span> &#125;<br><br>根据<span class="hljs-title class_">ECMAScript</span>规范， 此语句将该函数绑定到变量<span class="hljs-variable">f</span>，而不是变量<span class="hljs-variable">double</span>。<br><br>匿名和命名函数表但是的官方区别在于后者会绑定到其函数名相同的变量上，该变量将作为该函数内的一个局部变量。（只能在函数内部调用）可以用来写递归函数表达式<br><br></code></pre></td></tr></table></figure><blockquote><p>命名函数表达式是作用域和兼容性问题臭名昭著的来源，这归结于ECMAScript规范的历史中很不幸的错误以及流行的JavaScript引擎中的Bug. 规范的错误在ES3中就已经存在，JavaScript引擎被要求将命名函数表达式的作用域表示为一个对象，这有点像with，该作用域对象也继承了Object.prototype的属性，这意味着仅仅是给函数表达式命名也会将Object.prototype中的所有属性引入到作用域中。</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span> = <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; return null; &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">var</span> <span class="hljs-title">f</span> = <span class="hljs-title">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  return constructor();</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">()</span>;</span>  <span class="hljs-comment">// 结果 &#123;&#125; (in ES3 环境中)。这里错误的使用了Object.prototype.constructor (Object的构造函数)</span><br></code></pre></td></tr></table></figure><p>幸运的ES5修正了这个问题，但是有些JavaScript仍然使用过时的对象作用域，还有些更不符合标准的对于匿名函数的表达式也使用对象的作用域。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span> = <span class="hljs-title">function</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; return null; &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">var</span> <span class="hljs-title">f</span> = <span class="hljs-title">function</span> <span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  return constructor();</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">()</span>;</span>  <span class="hljs-comment">// 结果 &#123;&#125; (在更不标准的环境中)。本来这里应该正确解析不使用对象的作用域但是不标准的环境导致匿名函数表达式仍然使用对象作用域</span><br><br></code></pre></td></tr></table></figure><blockquote><p>最好的做法就是避免任何时候在Object.prototype中添加属性，以及避免使用与标准Object.prototype属性同名的局部变量</p></blockquote><p>在流行的JavaScript的引擎中的另一个缺陷是函数命名表达式的声明进行提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123; returen <span class="hljs-number">17</span>; &#125;<br><span class="hljs-title function_">g</span>(); <span class="hljs-comment">// 17 (在非标准的环境中会返回17，标准环境会报错 g is not defined)</span><br><br>我们应该怎样做<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>; &#125;<br><span class="hljs-keyword">var</span> g = <span class="hljs-literal">null</span>;<br><br></code></pre></td></tr></table></figure><blockquote><p>由于命名函数表达式会导致很多问题，所以不值得使用</p></blockquote><h2 id="当心局部块函数声明笨拙的作用域"><a href="#当心局部块函数声明笨拙的作用域" class="headerlink" title="当心局部块函数声明笨拙的作用域"></a>当心局部块函数声明笨拙的作用域</h2><p>比较有迷惑性的一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;global&quot;</span>; &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;local&quot;</span>; &#125;<br><br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">if</span>(x) &#123;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">f</span>());<br>  &#125;<br><br>  result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">f</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 返回结果</span><br><span class="hljs-title function_">test</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [&quot;local&quot;, &quot;local&quot;]</span><br><span class="hljs-title function_">test</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// [&quot;local&quot;]</span><br><br></code></pre></td></tr></table></figure><p>当函数f放到局部块里将有什么不同呢，首先要记住一点<br> <code>JavaScript没有块级作用域</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;global&quot;</span>; &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x</span>) &#123;<br><br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">if</span>(x) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;local&quot;</span>; &#125;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">f</span>());<br>  &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f);<br>  result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">f</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 返回结果</span><br><span class="hljs-title function_">test</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [&quot;local&quot;, &quot;local&quot;]</span><br><span class="hljs-title function_">test</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 有些平台显示[&quot;local&quot;] 有些平台返回： f is not a function</span><br><br>你可能认为 第一个结果为[<span class="hljs-string">&quot;local&quot;</span>, <span class="hljs-string">&quot;global&quot;</span>], 第二个结果为 [<span class="hljs-string">&quot;global&quot;</span>], 但是有一点需要记住 <span class="hljs-title class_">JavaScript</span>没有块级作用域<br>这里根据平台的实现不同结果会不一样,代码很难理解，还会导致性能降低。 <br><br></code></pre></td></tr></table></figure><p><code> 对此官方指定函数声明只能出现在其他函数或者程序的最外层。</code></p><p>编写可移植的函数最好方式是始终避免将函数声明置于局部块或者子语句中，如果想写嵌套函数声明应该将它置于父函数的最外层。如果要根据条件判断选择函数，最好的方法是使用var声明和函数表达式来实现。例子如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;global&quot;</span>; &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x</span>) &#123;<br><br>  <span class="hljs-keyword">var</span> g = f, result = [];<br>  <span class="hljs-keyword">if</span>(x) &#123;<br>    g = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;local&quot;</span>; &#125;<br>    result.<span class="hljs-built_in">push</span>(g());<br>  &#125;<br>  result.<span class="hljs-built_in">push</span>(g());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>这样消除内部变量作用域的神秘性，结果很明确，函数可移植。<br></code></pre></td></tr></table></figure><h2 id="避免使用eval创建局部变量"><a href="#避免使用eval创建局部变量" class="headerlink" title="避免使用eval创建局部变量"></a>避免使用eval创建局部变量</h2><p>使用eval的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> y = <span class="hljs-string">&quot;global&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">if</span>(x) &#123;<br>    <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;var y = &#x27;local&#x27;;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// &quot;local&quot;;</span><br><span class="hljs-title function_">test</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// &quot;global&quot;</span><br><br><span class="hljs-keyword">var</span> y = <span class="hljs-string">&quot;global&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">if</span>(x) &#123;<br>    <span class="hljs-built_in">eval</span>(src);<br>  &#125;<br>  <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;var y = &#x27;local&#x27;;&quot;</span>); <span class="hljs-comment">// &quot;local&quot;;</span><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;var z = &#x27;local&#x27;;&quot;</span>); <span class="hljs-comment">// &quot;global&quot;</span><br>这段代码很脆弱，也很不安全，它赋予了外部调用者能改变test函数内部作用域的能力。<span class="hljs-title class_">ES5</span>严格模式将<span class="hljs-built_in">eval</span>函数运行在一个嵌套的作用域中防止这种污染<br><br></code></pre></td></tr></table></figure><blockquote><p>保证eval函数不影响外部作用域的一个简单的方法是一个明确的嵌套作用域中运行它</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> y = <span class="hljs-string">&quot;global&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">if</span>(x) &#123;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-built_in">eval</span>(src); &#125;)();<br>  &#125;<br>  <span class="hljs-keyword">return</span> y;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="间接调用eval函数由于直接调用"><a href="#间接调用eval函数由于直接调用" class="headerlink" title="间接调用eval函数由于直接调用"></a>间接调用eval函数由于直接调用</h2><p>大部分函数只能访问他们所在的作用域，而不能访问除此之外的作用域。然而 eval函数具有访问调用它那时的整个作用域的能力。这是很强大的能力，但是导致一个问题eval很难很高效的调用一个任何函数，因为一旦被调用的是eval函数，那么每个函数调用都需要确保在运行时整个作用域对eval函数是可访问的。</p><p>总而言之我们使用过程中尽可能间接调用eval而不要直接调用。代码如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> f = <span class="hljs-built_in">eval</span>;<br>f(<span class="hljs-string">&quot;x&quot;</span>);<br><br>编写间接调用的一种简洁方法是<br><br>(<span class="hljs-number">0</span>, <span class="hljs-built_in">eval</span>)(src);  // 逗号表达式求值返回<span class="hljs-built_in">eval</span>函数，然后调用。  这种表达式被视为<span class="hljs-built_in">eval</span>的一种间接调用。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (六)</title>
    <link href="/2018/09/11/2018-09-11-read-book-effective-six/"/>
    <url>/2018/09/11/2018-09-11-read-book-effective-six/</url>
    
    <content type="html"><![CDATA[<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>理解函数调用， 方法调用，构造函数调用之间的不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><br>最简单的函数调用<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">username</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, &quot;</span> + username;<br>&#125;<br><br><span class="hljs-title function_">hello</span>(<span class="hljs-string">&quot;Keyser soze&quot;</span>);<br><br>方法调用<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span>;<br>&#125;,<br><span class="hljs-attr">username</span>: <span class="hljs-string">&quot;Hans, Gruber&quot;</span>;<br>&#125;<br><br>obj.<span class="hljs-title function_">hello</span>(); <span class="hljs-comment">// hello, Hans, Gruber</span><br><br><br><span class="hljs-comment">// 在函数调用过程中由调用表达式自身来确定this变量的绑定。 </span><br>  <br>构造函数调用<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, pass</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">pass</span> = pass;<br>&#125;  <br><br><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;sketcon&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br><br>与函数调用和方法调用不同的是，构造函数调用将一个全新的对象作为<span class="hljs-variable language_">this</span>变量的值，并隐式的返回这个对象作为调用结果。<br>构造函数的主要职责是初始化这个新对象。<br><br><br></code></pre></td></tr></table></figure><h2 id="熟练掌握高阶函数"><a href="#熟练掌握高阶函数" class="headerlink" title="熟练掌握高阶函数"></a>熟练掌握高阶函数</h2><p>高阶函数无非就是将函数作为参数或返回值的函数。将函数作为参数通常称为回调函数。</p><h2 id="使用call方法自定义接收者来调用方法"><a href="#使用call方法自定义接收者来调用方法" class="headerlink" title="使用call方法自定义接收者来调用方法"></a>使用call方法自定义接收者来调用方法</h2><p>通常情况下，函数或方法的接接收者（即绑定到特殊关键字this的值）是由调用者的语法决定的。但是有时我需要自定义一个接收者，幸运的是函数有一个内置的方法call来自定义接收者。可以通过函数对象的call方法来调用自身。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">f<span class="hljs-selector-class">.call</span>(obj, arg1, arg2, arg3);<br><br><span class="hljs-built_in">f</span>(arg1, arg2, arg3);<br></code></pre></td></tr></table></figure><p>不同的是第一个参数提供了一个显示的接收者对象。</p><h2 id="使用apply方法通过不同数量的参数调用函数"><a href="#使用apply方法通过不同数量的参数调用函数" class="headerlink" title="使用apply方法通过不同数量的参数调用函数"></a>使用apply方法通过不同数量的参数调用函数</h2><p>这里理解有误区，接受一个数组的参数，但是方法调用时将参数依次传入方法</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gcode">average 函数是一个称为可变参数或可变元的函数（函数的元市值其期望的参数个数）<br><br>average<span class="hljs-comment">(1, 2, 3)</span>;<br><br>average<span class="hljs-comment">(1)</span>;<br><br>average<span class="hljs-comment">(1, 2, 3, 7, 9)</span>;<br><br>可变参数的版本更加简洁，优雅。<br><br><br>averageOfArray<span class="hljs-comment">([1, 2, 3])</span>;<br><br>averageOfArray<span class="hljs-comment">([1])</span>;<br><br>averageOfArray<span class="hljs-comment">([1, 2, 3, 7, 9])</span>;<br><br><br><span class="hljs-comment">// 本来average 只接受可变参数，假设我有这样一个数字数组， average函数中没有this引用，所以简单的传null就可以。</span><br>var scores = getAllScores<span class="hljs-comment">()</span>;<br>average.apply<span class="hljs-comment">(null, scores)</span>  <br>传入一个数组，调用时这样 average<span class="hljs-comment">(scores[0], scores[1], scores[2])</span><br><br><br><br><br><br>使用apply方法指定一个可计算的参数数组来调用可变参数的函数。<br>使用apply方法的第一个参数给可变参数的方法提供一个接收者。<br><br></code></pre></td></tr></table></figure><h2 id="使用arguments创建可变参数的函数"><a href="#使用arguments创建可变参数的函数" class="headerlink" title="使用arguments创建可变参数的函数"></a>使用arguments创建可变参数的函数</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">参数可变函数的实现<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">average</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>, n = argumants.<span class="hljs-built_in">length</span>; i &lt; n; i++) &#123;<br><span class="hljs-built_in">sum</span> += arguments[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> / n;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数的函数提供了灵活的接口，不同的调用者可以使用不同数量的参数来调用它们，但是它们自身也失去了一点便利。如果使用者要使用数组的参数则只能使用 apply。<br>apply方法会降低可读性而且经常导致性能损失</p><p>好的经验是</p><blockquote><p>如果提供了一个便利的可变参数的函数，最好也提供一个需要显示指定数组的固定元数的版本。这样可以编写一个轻量级的封装，并委托固定元数的版本来实现可变参数的函数</p></blockquote><p>比较拗口，代码比较直观如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><br>固定元数的版本实现 用来作为数组参数的调用<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">averageOfArray</span>(<span class="hljs-params">a</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>, n = a.<span class="hljs-built_in">length</span>; i &lt; n; i++) &#123;<br><span class="hljs-built_in">sum</span> += a[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> / n;<br>&#125;<br><br>averageOfArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><br>参数可变函数的实现可以通过调用 固定元数版本来实现<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">average</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// averageOfArray本来就支持数组 所以无论average传入数组还是啥</span><br><span class="hljs-keyword">return</span> averageOfArray(arguments);<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="永远不要修改arguments对象"><a href="#永远不要修改arguments对象" class="headerlink" title="永远不要修改arguments对象"></a>永远不要修改arguments对象</h2><p>不要修改arguments对象，并且将arguments对象复制到一个真正的数组中再进行调整。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) &#123; <span class="hljs-keyword">return</span> x + y; &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callMethod</span>(<span class="hljs-params">obj, method</span>) &#123;<br><span class="hljs-keyword">var</span> shift = [].<span class="hljs-property">shift</span>;<br>shift.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>shift.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br><br><span class="hljs-keyword">return</span> obj[method].<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br><br><span class="hljs-title function_">callMethod</span>(obj, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">17</span>, <span class="hljs-number">25</span>);  <span class="hljs-comment">// cannot read property &quot;apply&quot; of undefined   17[25]</span><br><br>这里的<span class="hljs-variable language_">arguments</span> 对象并不是函数参数的副本，所有命名参数都是<span class="hljs-variable language_">arguments</span>对象中对应索引的别名。<br><br></code></pre></td></tr></table></figure><p>永远不要修改arguments对象是更为安全的，通过一开始复制参数中的元素到一个真正的数组的方式，很容易避免修改arguments对象。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var args = [].<span class="hljs-keyword">slice</span>.<span class="hljs-keyword">call</span>(argumants);<br><br><span class="hljs-keyword">slice</span>会复制整个数组，其结果是一个真正的标准<span class="hljs-keyword">Array</span>类型实例。<br><br><span class="hljs-keyword">function</span> callMethod(obj, <span class="hljs-keyword">method</span>) &#123;<br>var args = [].<span class="hljs-keyword">slice</span>.<span class="hljs-keyword">call</span>(arguments, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> obj[<span class="hljs-keyword">method</span>].apply(obj, args);<br>&#125;<br><br>callMethod(obj, &quot;add&quot;, <span class="hljs-number">17</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><h2 id="使用变量保存arguments的引用"><a href="#使用变量保存arguments的引用" class="headerlink" title="使用变量保存arguments的引用"></a>使用变量保存arguments的引用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个迭代器</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">hasNext</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> i &lt; n;<br>&#125;,<br><span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span>(i &gt;= n) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;end of iteration&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>[i++]; <span class="hljs-comment">// wrong arguments;</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> it = <span class="hljs-title function_">values</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">78</span>);<br><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">//undefined</span><br><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">//undefined</span><br><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">//undefined</span><br><br>每次调用next的时候，next方法内部会存在一个<span class="hljs-variable language_">arguments</span>这里可能我们关心的只是values的<span class="hljs-variable language_">arguments</span>, 所以正确的方法是将values的<span class="hljs-variable language_">arguments</span>保存下来<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, n = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>, arg = <span class="hljs-variable language_">arguments</span>;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">hasNext</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> i &lt; n;<br>&#125;,<br><span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span>(i &gt;= n) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;end of iteration&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> arg[i++];<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="使用bind方法提取具有确定接收者的方法"><a href="#使用bind方法提取具有确定接收者的方法" class="headerlink" title="使用bind方法提取具有确定接收者的方法"></a>使用bind方法提取具有确定接收者的方法</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">buffer</span> = &#123;<br><span class="hljs-attr">entries</span>: [],<br><span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>this.entries.<span class="hljs-built_in">push</span>(s);<br>&#125;,<br><span class="hljs-attr">concat</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> this.entries.join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> source = [<span class="hljs-string">&quot;867&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;5309&quot;</span>];<br><br>source.forEach(<span class="hljs-built_in">buffer</span>.add);  <span class="hljs-comment">// error: entries is undefined</span><br><br><br></code></pre></td></tr></table></figure><p>buffer.add 方法的接收者并不是buffer对象，函数的接收者取决于它是如何被调用，<br>不过我们并没有调用它，而是把它传给了forEach方法<br>而我们并不知道forEach在哪里调用了它，事实上forEach方法的实现使用全局对象作为默认的接收者。由于全局对象没有entries属性所以这段代码抛出了一个错误。<br>幸运的是forEach允许调用者提供一个可选的参数作为回调函数的接收者，所以我们可以很轻松的修复该例子。</p><p>方法一</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> source = [<span class="hljs-string">&quot;867&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;5309&quot;</span>];<br><br>source.forEach(<span class="hljs-built_in">buffer</span>.add, <span class="hljs-built_in">buffer</span>); <br><br><br></code></pre></td></tr></table></figure><p>并非所有的高阶函数都会为使用者提供其毁掉函数的接收者。如果forEach不接受额外的接收者参数怎么办</p><p>方法二</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">source.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">function</span>(s) &#123;<br>buffer.<span class="hljs-keyword">add</span>(s);<br>&#125;);<br><br>bujjer.<span class="hljs-keyword">join</span>();<br><br></code></pre></td></tr></table></figure><p>创建一个函数用来实现绑定其接收者到一个指定的对象是非常常见的，因此ES5标准库直接支持这种模式，函数对象的bind方法需要一个接收者对象，并产生一个以该接收者对象的方法调用的方式调用原来的函数的封装函数。</p><p>方法三</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> source = [<span class="hljs-string">&quot;867&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;5309&quot;</span>];<br><br>source.forEach(<span class="hljs-built_in">buffer</span>.add.bind(<span class="hljs-built_in">buffer</span>)); <br><br><br><span class="hljs-built_in">buffer</span>.add.bind(<span class="hljs-built_in">buffer</span>) 创建了一个新函数而不是修改了bufffer.add函数 该函数将接收者绑定到了<span class="hljs-built_in">buffer</span>对象，而原有函数的接收者保持不变<br><br><span class="hljs-built_in">buffer</span>.add === <span class="hljs-built_in">buffer</span>.add.bind(<span class="hljs-built_in">buffer</span>);  <span class="hljs-comment">// false;</span><br></code></pre></td></tr></table></figure><h2 id="使用bind实现函数柯里化"><a href="#使用bind实现函数柯里化" class="headerlink" title="使用bind实现函数柯里化"></a>使用bind实现函数柯里化</h2><p>函数对象的bind方法除了具有降方法绑定到接收者的用途外，它还有更多功能。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> simpleURL(protocol, <span class="hljs-keyword">domain</span>, <span class="hljs-type">path</span>) &#123;<br><span class="hljs-keyword">return</span> protocol + &quot;://&quot; + <span class="hljs-keyword">domain</span> + &quot;/&quot; + <span class="hljs-type">path</span>;<br>&#125;<br><br>var urls = paths.map(<span class="hljs-keyword">function</span>(<span class="hljs-type">path</span>) &#123;<br><span class="hljs-keyword">return</span> simpleURL(&quot;http&quot;, siteDomain, <span class="hljs-type">path</span>);<br>&#125;);<br><br><br></code></pre></td></tr></table></figure><p>传给simpleURL的前两个参数是固定的， 只有第三个参数在变化，我们可以通过调用simpleURL函数的bind方法来自动构造该匿名函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> urls = path.<span class="hljs-built_in">map</span>(simpleURL.bind(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;http&quot;</span>, siteDomain));<br></code></pre></td></tr></table></figure><p>对simpleURL.bind的调用产生了一个委托到simpleURL的新函数，bind的第一个参数提供了接收者的值， 由于simpleURL.bind不需要引用this，所以可以使用任何值。使用null和undefined是习惯用法。 simpleURL.bind的其余参数和提供给你新函数的所有参数共同组成了传递给simpleURL的参数。</p><blockquote><p>将函数与其参数的一个子集绑定的技术称为函数柯里化。</p></blockquote><h2 id="不要信赖函数对象的toString方法"><a href="#不要信赖函数对象的toString方法" class="headerlink" title="不要信赖函数对象的toString方法"></a>不要信赖函数对象的toString方法</h2><p>JavaScript有一个非凡的特性， 即将其源代码重现为字符串的能力</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren">(<span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>) &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <br>&#125;).<span class="hljs-property">toString</span>();<br><br><span class="hljs-comment">// &quot;function (x) &#123;\n return x + 1; \n&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>ECMAScript标准对于函数对象的toString方法的返回结果并没有任何要求。这意味着不同的JavaScript引擎将产生不同的结果，甚至产生的字符串跟函数并不相关。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> <span class="hljs-comment">&#123; </span></span><br><span class="hljs-comment"><span class="hljs-function">return x + 1 </span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span>).<span class="hljs-title">bind</span><span class="hljs-params">(16)</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span>;</span><br><br><span class="hljs-comment">// &quot;function (x) &#123;\n [native code] \n&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>由于bind函数通常是由其他语言实现的通常c++，宿主提供一个编译后的函数，在此环境下通常没有源代码可展示。</p><p>还有一点就是 toString方法生成的源代码并不展示闭包中保存的和内部变量引用相关的值</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren">(<span class="hljs-title function_">function</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">y</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">+</span> <span class="hljs-variable">y</span>;<br>&#125;<br>&#125;)(<span class="hljs-number">42</span>).<span class="hljs-property">toString</span>();<br><br><span class="hljs-comment">// &quot;function(y) &#123;\n return x + y; \n &#125;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>总而言之，应该避免使用函数对象的toString方法</p></blockquote><h2 id="避免使用非标准的栈检查属性"><a href="#避免使用非标准的栈检查属性" class="headerlink" title="避免使用非标准的栈检查属性"></a>避免使用非标准的栈检查属性</h2><ul><li>arguments.callee 指向使用该arguments对象被调用的函数</li><li>arguments.caller 指向调用该arugments对象的函数（该arguments对象调用函数的函数）</li></ul><p>出于安全考虑大多环境移除了arguments.caller,因此它是不可靠的</p><p>许多JavaScript环境提供了一个相似的函数对象属性—非标准但是普遍适用的caller属性。 它指向函数最近的调用者</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">revealCaller</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">revealCaller.caller</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">revealCaller()</span>;<br>&#125;<br><br>start() === start;  // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>ES5的严格模式禁止使用arguments.caller 和arguments.callee ，因为它们不具备良好的可移植性， 非标准的函数对象caller属性应该避免使用，因为在包含全部栈信息方面，它是不可靠的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (四)</title>
    <link href="/2018/06/27/2018-06-27-read-book-effective-four/"/>
    <url>/2018/06/27/2018-06-27-read-book-effective-four/</url>
    
    <content type="html"><![CDATA[<h2 id="了解分号插入的局限性"><a href="#了解分号插入的局限性" class="headerlink" title="了解分号插入的局限性"></a>了解分号插入的局限性</h2><p>JavaScript的一个便利是能够离开 语句结束分号 工作。 删除分号后，结果变得轻量而优雅，比如下面这个例子去掉所有分号，JavaScript会自动插入分号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Point</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x || <span class="hljs-number">0</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y || <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isOrigin</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> === <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段没有分号的代码能够工作依赖于JavaScript的<code>自动分号插入技术(automatic semicolon insertion)</code>, 它是一种程序解析技术。它能够推断出上下文省略的分号，然后有效的将分号自动插入到程序中。</p><blockquote><p>像隐式的强制转换一样，分号插入也有其陷阱，你根本不能避免学习其规则， 即使你从来不省略分号，受分号插入的影响，JavaScript语法也有一些额外的限制。一旦学会分号插入机制，你会从删除不必要的分号的痛苦中解脱出来</p></blockquote><h2 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h2><blockquote><p>分号仅在 } 标记之前、一个或多个换行之后和程序输入的结尾被插入。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//合法省略分号</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">var</span> n = +x<br>  <span class="hljs-keyword">return</span> n * n<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">r</span>) &#123; r = +r; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * r * r &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span> &#125;<br><br><span class="hljs-comment">// 不合法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">r</span>) &#123; r = +r <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * r * r &#125;<br><br></code></pre></td></tr></table></figure><h2 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h2><blockquote><p>分号进在随后的输入标记不能被解析时插入 , 换句话说分号插入是一种错误矫正机制。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>a = b<br>(<span class="hljs-title function_">f</span>()); <span class="hljs-comment">// 这个例子会被解析为 a = b(f()); 所以不会插入分号，因为能够正确解析</span><br><br>a = b<br><span class="hljs-title function_">f</span>();   <span class="hljs-comment">// 这个例子会被解析为 a = b f(); 解析有误，所以会插入分号</span><br></code></pre></td></tr></table></figure><h2 id="有5个明确有问题的字符需要密切注意"><a href="#有5个明确有问题的字符需要密切注意" class="headerlink" title="有5个明确有问题的字符需要密切注意"></a>有5个明确有问题的字符需要密切注意</h2><p>**(、[、+、-和/**， 每一个字符都能作为一个表达式运算符或一条语句的前缀， 这依赖于具体上下文。，如果下一行以这五个有问题的字符串之一来时，则不会自动插入分号。向上面的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = b<br>[<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) &#123;<br>  background[key] = foreground[key] / <span class="hljs-number">2</span>;<br>&#125;);<br><span class="hljs-comment">// 这看起来像两条语句但是使用了&lt;code&gt;[&lt;/code&gt;，所以被解析为一条语句</span><br><span class="hljs-comment">// 这里例子看起来有点奇怪，但是，JavaScript允许逗号分隔表达式。</span><br><span class="hljs-comment">// 逗号分隔表达式从左至右依次执行，并返回最后一个表达式的值。</span><br>a = b[<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) &#123;<br>  background[key] = foreground[key] / <span class="hljs-number">2</span>;<br>&#125;);<br><br><span class="hljs-comment">// /通常作为正则表达式的开始</span><br><span class="hljs-regexp">/Error/i</span>.<span class="hljs-title function_">test</span>(str) &amp;&amp; <span class="hljs-title function_">fail</span>();<br><br><span class="hljs-comment">//这种情况会被解析到一行不会插入分号</span><br>a = b<br>/<span class="hljs-title class_">Error</span>/i.<span class="hljs-title function_">test</span>(str) &amp;&amp; <span class="hljs-title function_">fail</span>();<br><br>a = b/<span class="hljs-title class_">Error</span>/i.<span class="hljs-title function_">test</span>(str) &amp;&amp; <span class="hljs-title function_">fail</span>();  <span class="hljs-comment">//  / 解析为除法运算符</span><br><br><br></code></pre></td></tr></table></figure><p>又一个例子,这是一个完全正确的例子，因为会自动插入分号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = b<br><span class="hljs-keyword">var</span> x<br>(<span class="hljs-title function_">f</span>())<br><br><span class="hljs-comment">// 但是如果重构时被意外的修改过如下，第二个分号不会插入, 会被错误的解析为 a = b(f())</span><br><span class="hljs-keyword">var</span> x<br>a = b<br>(<span class="hljs-title function_">f</span>())<br></code></pre></td></tr></table></figure><p>一个不幸的结果就是，你总是需要注意省略的分号， 并且检查接下来的一行开始的标记是否会禁用自动插入分号。所以你可以采用在**(、[、+、-和/**，字符的开始前置一个额外的分号语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = b<br><span class="hljs-keyword">var</span> x<br>;(<span class="hljs-title function_">f</span>())<br><br><br><span class="hljs-keyword">var</span> x<br>a = b<br>;(<span class="hljs-title function_">f</span>())<br></code></pre></td></tr></table></figure><p>还有一个常用的情况就是脚本连接的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// file1.js</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()<br><br><span class="hljs-comment">// file2.js</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()<br><br><span class="hljs-comment">// 当文件连接到一起时</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()<br><br><span class="hljs-comment">// 被视为一条单一的语句，等价于：</span><br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)();<br><br><span class="hljs-comment">// 所以如果文件最开始的语句以这5个字符开始，你应该防御性的给每个前缀一个额外的分号</span><br><br><span class="hljs-comment">// file1.js</span><br>;(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()<br><br><span class="hljs-comment">// file2.js</span><br>;(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;)()<br><br></code></pre></td></tr></table></figure><blockquote><p>最安全的选择就是防御性的增加分号</p></blockquote><p>你可能认为 “我从来不省略分号，我会没事的。” 事实并不是这样。也有一些情况，尽管不会出现解析错误，但是也会强制性的插入分号，<br>这是所谓的JavaScript的语法限制式（restricted production），它不允许两个字符之间存在换行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-comment">// 返回一个对象</span><br><br><span class="hljs-keyword">return</span>  <span class="hljs-comment">// 这段代码被解析为</span><br>&#123;&#125;;<br><br><span class="hljs-keyword">return</span>;<br>&#123;&#125;<br>;<br></code></pre></td></tr></table></figure><p>类似的JavaScript的语法限制产生式包括： return, throw, break, continue, 后置自增或自减运算符。<br>在<code>return, throw, break, continue, ++, --</code>,参数之前决不能出现换行</p><p>关于自增和自减运算符 是为了避免以下代码出现的歧义，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a<br>++<br>b<br><span class="hljs-comment">// ++既可以作为前置也可以作为后置，但是后置根据语法限制式,不允许a++之间存在换行 所以上面代码解析为</span><br><br>a; ++b;<br><br></code></pre></td></tr></table></figure><h2 id="第三条也是最后一条规则"><a href="#第三条也是最后一条规则" class="headerlink" title="第三条也是最后一条规则"></a>第三条也是最后一条规则</h2><p>分号不会作为分隔符在for循环空语句头部被自动插入，换言之，for头部里面的<code>;</code>不能省略，必须显示的包含分号</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 下面代码会解析错误</span><br><span class="hljs-built_in">for</span>(<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>, total = <span class="hljs-number">1</span> <span class="hljs-comment">// parse error</span><br>    <span class="hljs-selector-tag">i</span> &lt; n<br>    i++) &#123;<br>  total *= <span class="hljs-selector-tag">i</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>同样的 <code>while</code>，也是需要显示分号的情况</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#125;  <span class="hljs-comment">// parse error</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>); &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (三)</title>
    <link href="/2018/06/22/2018-06-22-read-book-effective-three/"/>
    <url>/2018/06/22/2018-06-22-read-book-effective-three/</url>
    
    <content type="html"><![CDATA[<h2 id="当心隐式的强制转换"><a href="#当心隐式的强制转换" class="headerlink" title="当心隐式的强制转换"></a>当心隐式的强制转换</h2><p>JavaScript对类型的错误出奇宽容,算数运算符 - 、*、%、/都会把参数转为数字。然而 + 会根据参数来决定<br>位运算符不仅会将操作数转换为数字，而且还会将操作数转换为32位整数(表示数字的子集)。这些运算符包括算术运算符(~ 、&amp; 、^ 、| 、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">3</span> + <span class="hljs-literal">true</span>; <span class="hljs-comment">// 4</span><br><span class="hljs-number">2</span> + <span class="hljs-number">3</span>;    <span class="hljs-comment">// 5</span><br><span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-number">3</span>;  <span class="hljs-comment">// 23</span><br><span class="hljs-string">&quot;17&quot;</span> * <span class="hljs-number">3</span>; <span class="hljs-comment">// 51</span><br><span class="hljs-string">&quot;8&quot;</span> | <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h2 id="注意NaN"><a href="#注意NaN" class="headerlink" title="注意NaN"></a>注意NaN</h2><p>NaN不等于其自身，所以测试一个值是否是NaN是行不通的 ，标准库里面的isNaN也是不可靠的，因为它也带有隐式的强制转换，尝试将参数转为数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-title class_">NaN</span>;<br>x === <span class="hljs-title class_">NaN</span>;  <span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 由于隐式的类型转换所以以下 都会返回true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>);<br><span class="hljs-built_in">isNaN</span>(&#123;&#125;);<br><span class="hljs-built_in">isNaN</span>(&#123; <span class="hljs-attr">valueOf</span>: <span class="hljs-string">&quot;foo&quot;</span> &#125;);<br><br><span class="hljs-comment">// 由于NaN是不等于其自身的，所以真正正确判断一个参数是否是NaN的方法是判断是否等于自身</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isReallyNaN</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x !== x;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="对象的隐式转换"><a href="#对象的隐式转换" class="headerlink" title="对象的隐式转换"></a>对象的隐式转换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象转换成字符串</span><br><span class="hljs-string">&quot;the Math object: &quot;</span> + <span class="hljs-title class_">Math</span>; <span class="hljs-comment">// &quot;the Math object: [object Math]&quot;</span><br><span class="hljs-string">&quot;the JSON object: &quot;</span> + <span class="hljs-title class_">JSON</span>; <span class="hljs-comment">// &quot;the JSON object: [object JSON]&quot;</span><br><br><span class="hljs-comment">// 对象转换成数字， 对象可以通过valueOf 方法转为数字,你可以控制对象的类型转换</span><br><br><span class="hljs-comment">// 这里讲调用对象的toString 进行拼接</span><br><span class="hljs-string">&quot;J&quot;</span> + &#123; <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;S&quot;</span>; &#125; &#125;;  <span class="hljs-comment">// &quot;JS&quot;</span><br><br><span class="hljs-comment">// 通过valueOf将对象转为数字</span><br><span class="hljs-number">2</span> * &#123; <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>; &#125; &#125;;       <span class="hljs-comment">// 6</span><br><br></code></pre></td></tr></table></figure><p>如果一个对象同时有toString 和valueOf方法 ，运算符 + 应该调用哪个方法呢，JavaScript通过盲目的选择valueOf方法而不是toString方法来解决这种含糊的情况，这就意味着如果有人打算对一个对象执行字符串连接操作，那么产生的行为会出乎意料</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[object MyObject]&quot;</span>;<br>  &#125;,<br>  <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-string">&quot;object: &quot;</span> + obj; <span class="hljs-comment">// &quot;object: 17&quot;;</span><br></code></pre></td></tr></table></figure><blockquote><p>这里例子说明，valueOf方法才真正是为那些代表数值的对象(如 Number对象)而设计的。对于这些对象toString 和valueOf方法应返回一致的结果。一般情况下，字符串的强制转换远比数字转换更常见、更有用。 最好避免使用valueOf方法，除非对象的确是一个数字的抽象，并且obj.toString()能产生一个obj.valueOf() 的字符串表示。</p></blockquote><h2 id="真值运算"><a href="#真值运算" class="headerlink" title="真值运算"></a>真值运算</h2><p>if、||、&amp;&amp;等运算符逻辑上需要布尔值作为操作参数，但实际上可以接受任何值。JavaScript会按照简单的隐式强制转换规则将值解释为布尔值。</p><p>false, 0, -0,””, NaN,null, undefined 外的所有值会转换为false， 其他所有值都为真值。</p><p>因为数字0和字符串””会转换为false,因此通过隐式转换来判断一个值是否已经定义是不准确的需要通过判断，应该通过以下方式来进行判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;&#125;<br><span class="hljs-keyword">if</span>(x === <span class="hljs-literal">undefined</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="原始类型优于封装对象"><a href="#原始类型优于封装对象" class="headerlink" title="原始类型优于封装对象"></a>原始类型优于封装对象</h2><p>除了对象之外，JavaScript有5个原始值类型： 布尔值，数字，字符串，null, undefined;<br>以String为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br>s + <span class="hljs-string">&quot;world&quot;</span>;  <span class="hljs-comment">// &quot;hello world&quot;</span><br><br>s[<span class="hljs-number">4</span>]          <span class="hljs-comment">// &quot;o&quot;</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment">// &quot;string&quot;</span><br><br><span class="hljs-keyword">typeof</span> s        <span class="hljs-comment">// &quot;Object&quot;</span><br><br><span class="hljs-comment">// 每个string都是一个单独的对象其总等于自身，对于非严格相等运算符，结果相同</span><br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>s1 === s2; <span class="hljs-comment">// false</span><br><br>s1 == s2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>这些封装的行为并不十分正确所以<code>用处不大</code> ， 其存在的理由是他们的使用方法。例如<br>隐式封装后会有一个奇怪的结果，你可以对原始类型的值设置属性，但是对其没有丝毫影响.<br>每次隐式的封装都会产生一个新的String对象 <code>"hello"</code> 每次写这个相当于声明了一个新的对象，更新第一个对象的someProperty不会对第二个对象产生影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_">toUpperCase</span>();  <span class="hljs-comment">// HELLO</span><br><br><span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-property">someProperty</span> = <span class="hljs-number">17</span>;<br><br><span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-property">someProperty</span>; <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure><h2 id="避免对混合类型使用-运算符"><a href="#避免对混合类型使用-运算符" class="headerlink" title="避免对混合类型使用==运算符"></a>避免对混合类型使用==运算符</h2><p>下面的表达式的值其实是true， 对于看似无关的值使用==实际是相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;1.0e0&quot;</span> == &#123; <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125; &#125;    <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 理由如下</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;1.0e0&quot;</span>)   <span class="hljs-comment">// 转换为数字 1</span><br><br><span class="hljs-comment">// 对象调用 valueOf方法返回true， 再转换为数字，得到1</span><br><br><span class="hljs-comment">// 所以结果相等</span><br><br></code></pre></td></tr></table></figure><p>我们可以使用隐式的强制转换做一些事情，但是仍然推荐使用严格模式进行比较。</p><p>例子一, 这个例子使用了隐式的类型转换，跟数字进行比较会将字符串转为数字，从而得到正确的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br><span class="hljs-keyword">if</span>(form.<span class="hljs-property">month</span>.<span class="hljs-property">value</span> == (today.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>) &amp;&amp;<br>  form.<span class="hljs-property">day</span>.<span class="hljs-property">value</span> == today.<span class="hljs-title function_">getDate</span>()) &#123;<br>  <span class="hljs-comment">// happy birthday</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>例子二， 这个例子使用了显示的 Number，或者一元运算符 + 将字符串转为数字, 从而清晰的向大家表达了代码到底在做什么样的转换， 不要求读者记住这些转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br><span class="hljs-keyword">if</span>(+form.<span class="hljs-property">month</span>.<span class="hljs-property">value</span> == (today.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>) &amp;&amp;<br> +form.<span class="hljs-property">day</span>.<span class="hljs-property">value</span> == today.<span class="hljs-title function_">getDate</span>()) &#123;<br>  <span class="hljs-comment">// happy birthday</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>例子三， 一个更好的例子 使用严格相等运算， 这个过程没有涉及任何转换，读者读起来更加清晰，否则读者需要记住这些强制转换来解读代码的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br><span class="hljs-keyword">if</span>(+form.<span class="hljs-property">month</span>.<span class="hljs-property">value</span> === (today.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>) &amp;&amp;<br>  +form.<span class="hljs-property">day</span>.<span class="hljs-property">value</span> === today.<span class="hljs-title function_">getDate</span>()) &#123;<br>  <span class="hljs-comment">// happy birthday</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="运算符强制转换规则"><a href="#运算符强制转换规则" class="headerlink" title="== 运算符强制转换规则"></a>== 运算符强制转换规则</h2><table><thead><tr><th>参数类型1</th><th align="right">参数类型2</th><th align="center">参数类型3</th></tr></thead><tbody><tr><td>null</td><td align="right">undefined</td><td align="center">不转换，总是返回true</td></tr><tr><td>null或undefined</td><td align="right">其他任何非null或undefined的类型</td><td align="center">不转换，总是返回false</td></tr><tr><td>原始类型的值：string, number,boolean</td><td align="right">Date对象</td><td align="center">将原始类型转换为数字，将Date对象转换为原始类型（优先尝试toString方法，再尝试valueOf方法）</td></tr><tr><td>原始类型的值：string, number,boolean</td><td align="right">非Date对象</td><td align="center">将原始类型转换为数字，将非Date对象转换为原始类型（优先尝试valueOf方法，再尝试toString方法）</td></tr><tr><td>原始类型的值：string, number,boolean</td><td align="right">原始类型的值：string, number,boolean</td><td align="center">将原始类型转换为数字</td></tr></tbody></table><h2 id="由一张图片引发的思考"><a href="#由一张图片引发的思考" class="headerlink" title="由一张图片引发的思考"></a>由一张图片引发的思考</h2><p><img src="https://cdn.darknights.cn/assets/images/in-post/read-book-effective/js-convert.jpg"></p><h2 id="这几个例子很好的验证了上面的隐式类型转换"><a href="#这几个例子很好的验证了上面的隐式类型转换" class="headerlink" title="这几个例子很好的验证了上面的隐式类型转换"></a>这几个例子很好的验证了上面的隐式类型转换</h2><p>首先我们要知道一些前提</p><ul><li><p>加法运算符会触发三种类型转换， 将值转为原始类型值， 转换为数字， 转换为字符串， 正好对应引擎内部的三种抽象操作， ToPrimitive(), ToNumber(),ToString()， 一旦得到原始类型的值直接开始进行运算</p></li><li><p>javascript 中的Object, 如果调用valueOf方法默认返回对象本身， 所以无论是{}，还是 []使用valueOf方法都会返回对象本身，得不到原始类型的值。</p></li></ul><h2 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h2><ul><li>如果输入的值已经是个原始值,则直接返回它.</li><li>否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.</li><li>否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.</li><li>否则,抛出TypeError异常.</li></ul><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><table><thead><tr><th>参数</th><th align="right">结果</th></tr></thead><tbody><tr><td>undefined</td><td align="right">NaN</td></tr><tr><td>null</td><td align="right">+0</td></tr><tr><td>布尔值</td><td align="right">true被转换为1,false转换为+0</td></tr><tr><td>数字</td><td align="right">无需转换</td></tr><tr><td>字符串</td><td align="right">由字符串解析为数字.例如,”324”被转换为324</td></tr></tbody></table><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><table><thead><tr><th>参数</th><th align="right">结果</th></tr></thead><tbody><tr><td>undefined</td><td align="right">“undefined”</td></tr><tr><td>null</td><td align="right">“null”</td></tr><tr><td>布尔值</td><td align="right">true被转换为”true”,false转换为”false”</td></tr><tr><td>数字</td><td align="right">数字作为字符串,比如. “1.765”</td></tr><tr><td>字符串</td><td align="right">无需转换</td></tr></tbody></table><p>举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Number</span>(obj);<br>obj + obj;  <span class="hljs-comment">// TypeError: Cannot convert object to primitive value</span><br><br><br></code></pre></td></tr></table></figure><h2 id="value1-value2"><a href="#value1-value2" class="headerlink" title="value1 + value2"></a>value1 + value2</h2><p>这个表达式的计算过程是这样的：</p><ul><li>第一步 将两个操作数转为原始类型的值  Date先调用toString()方法， 非Date先调用 valueOf()</li><li>第二步 如果其中任意一个是字符串，则将另一个也转为字符串，让后返回两个字符串相加后的结果</li><li>第三步， 否则将值都转为数字类型然后相加</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;51&#x27;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + true <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5true&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + false <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5false&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + &#123;&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5[object Object]&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + [] <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-keyword">function</span> ()&#123;&#125; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5function ()&#123;&#125;&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5undefined&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + null <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;5null&quot;</span><br><br></code></pre></td></tr></table></figure><p>除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;5&#x27;</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 10</span><br><span class="hljs-literal">true</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;5&#x27;</span> * []    <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> / <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br><span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h2 id="图片例子分析"><a href="#图片例子分析" class="headerlink" title="图片例子分析"></a>图片例子分析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>[] + [] <span class="hljs-comment">// &quot;&quot;</span><br><br>首先转原始类型值先调用valueOf方法在调用toString方法，js对象的<span class="hljs-title function_">valueOf</span>()返回对象本身，<br>所以调用 <span class="hljs-title function_">toString</span>() 返回的空字符串<span class="hljs-string">&quot;&quot;</span><br><br><br>[] + &#123;&#125; <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br>首先转原始类型的值，[] 直接转成字符串，按照+运算符规则，其中任意一个字符串，<br>则另一个也转为字符串 <span class="hljs-title class_">String</span>(&#123;&#125;) =&gt; <span class="hljs-string">&#x27;[object Object]&#x27;</span> 得到最终结果<br><br><br><br><br>&#123;&#125; + &#123;&#125; <span class="hljs-comment">// &quot;[object Object][object Object]&quot;  or &quot;NaN&quot;</span><br><br>这个比较特殊<span class="hljs-title class_">JavaScript</span>引擎将第一个&#123;&#125;解释成了一个空的代码块并且忽略了它，<br> <span class="hljs-title class_">NaN</span>其实是后面的表达式 +&#123;&#125;的计算结果<br> 这里的+ 是一元运算符作用是将操作数转为数字 和<span class="hljs-title class_">Number</span>()函数完全一样。 如 +“<span class="hljs-number">36.5</span>” =&gt; <span class="hljs-number">36.5</span><br><br>转换过程如下<br>+&#123;&#125;<br><span class="hljs-title class_">Number</span>(&#123;&#125;.<span class="hljs-title function_">toString</span>()） <span class="hljs-comment">// 因为&#123;&#125;.valueOf() 返回对象本身不是原始值</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>)<br>最终结果 <span class="hljs-title class_">NaN</span><br><br><span class="hljs-title class_">Firefox</span>和<span class="hljs-title class_">Chrome</span>(和<span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span>一样使用<span class="hljs-variable constant_">V8</span>引擎)的解析结果不同.下面的输入会被解析成一个表达式,结果更符合我们的预料<br><br>&#123;&#125; + &#123;&#125; <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>为什么第一个{}会被解析成代码块呢?原因是,整个输入被解析成了一个语句,如果一个语句是以左大括号开始的,则这对大括号会被解析成一个代码块.所以,你也可以通过强制把输入解析成一个表达式来修复这样的计算结果:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(&#123;&#125; + &#123;&#125;)<br><span class="hljs-string">&#x27;[object Object][object Object]&#x27;</span><br><br>同理<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; + &#123;&#125;)<br><span class="hljs-string">&#x27;[object Object][object Object]&#x27;</span><br><br></code></pre></td></tr></table></figure><p>经过上面的分析过程再来看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;&#125; + []  <span class="hljs-comment">//第一个&#123;&#125;被当成空代码块被忽略</span><br>+[]      <span class="hljs-comment">// 转数字</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;&quot;</span>)      <span class="hljs-comment">//  空字符串转为0</span><br>最终结果<br><span class="hljs-number">0</span><br><br>(&#123;&#125; + [])  <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br></code></pre></td></tr></table></figure><p>参考文章</p><blockquote><ul><li><a href="http://www.cnblogs.com/ziyunfei/archive/2012/09/15/2685885.html">JavaScript中,{}+{}等于多少?</a></li><li><a href="https://github.com/dwqs/blog/issues/17">你有必要知道的 25 个 JavaScript 面试题</a></li><li><a href="https://javascript.ruanyifeng.com/grammar/conversion.html#toc4">数据类型转换</a></li><li><a href="https://blog.csdn.net/divd567/article/details/77247773">JS数据类型转换 - 数字转换</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript (二)</title>
    <link href="/2018/06/21/2018-06-21-read-book-effective-two/"/>
    <url>/2018/06/21/2018-06-21-read-book-effective-two/</url>
    
    <content type="html"><![CDATA[<h2 id="理解JavaScript的浮点数"><a href="#理解JavaScript的浮点数" class="headerlink" title="理解JavaScript的浮点数"></a>理解JavaScript的浮点数</h2><p>大多数编程语言都有多种数据类型，但是Javascript 却只有一种。使用 <code>typeof</code> 运算符查看无论是 ，整数还是浮点数JavaScript都简单的返回一个结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">17</span>; <span class="hljs-comment">// number</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">98.6</span>; <span class="hljs-comment">// number</span><br><span class="hljs-keyword">typeof</span> -<span class="hljs-number">2.1</span>; <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure><p>事实上JavaScript中所有的数字都是双精度浮点数。</p><blockquote><p>这是由IEEE 745标准定制的64位编码数字 —即 “doubles”； JavaScript使用双精度浮点数来完美的表达高到53位精度的整数，-2^53次方到2^53次方的所有整数都是有效的双精度浮点数。因此尽管JavaScript中缺少明显的整数类型，但是完全可以进行整数运算。</p></blockquote><p>位运算比较特殊JavaScript不会直接将操作数作为浮点数进行运算，而是会将其隐式的转换为32位整数后进行运算。以按位或为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-number">8</span> | <span class="hljs-number">1</span><br><br><span class="hljs-number">00000000000000000000000000001000</span><br><br><span class="hljs-number">00000000000000000000000000000001</span><br><br><span class="hljs-number">00000000000000000000000000001001</span><br><br></code></pre></td></tr></table></figure><p>将8 和1分别转为32位的二进制序列然后进行运算， 所有的位运算符的工作方式是相同的。他们先将操作数转换为整数，然后使用整数位模式进行运算，最后将结果转换为标准的JavaScript浮点数。</p><blockquote><p>浮点数的运算需要时刻保持警惕，因为它们出了名的不精确，甚至一些看起来最简单的算术运算都会产生不正确的结果</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;  <span class="hljs-comment">// 0.30000000000000004</span><br><span class="hljs-comment">// 实数满足结合律 即实数 x, y, z 总是满足 (x + y) + z = x + (y + z); 但是对于浮点数来说却不总是这样</span><br><br> (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>) + <span class="hljs-number">0.3</span>  <span class="hljs-comment">// 0.6000000000000001</span><br><br> <span class="hljs-number">0.1</span> + (<span class="hljs-number">0.2</span> + <span class="hljs-number">0.3</span>) <span class="hljs-comment">// 0.6</span><br><br></code></pre></td></tr></table></figure><blockquote><p>浮点数权衡了精度和性能。当我们关心精度时，要小心浮点数的局限性。一个有效的解决方法是尽可能采用整数值运算，因为整数在表示时不需要舍入。只需要担心范围符合 -2^53 到 2^53的整数</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React初步学习</title>
    <link href="/2018/06/19/2018-06-19-react-lesson-one/"/>
    <url>/2018/06/19/2018-06-19-react-lesson-one/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p><a href="https://doc.react-china.org/docs/handling-events.html">react中文文档</a></p><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。<br>这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">isToggleOn</span>: <span class="hljs-literal">true</span>&#125;;<br><br>    <span class="hljs-comment">// This binding is necessary to make `this` work in the callback</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick1</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick1</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>    <span class="hljs-comment">//推荐方法一</span><br>  <span class="hljs-title function_">handleClick1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123;<br>      <span class="hljs-attr">isToggleOn</span>: !prevState.<span class="hljs-property">isToggleOn</span><br>    &#125;));<br>  &#125;<br><br>  <span class="hljs-comment">//推荐方法二</span><br>   handleClick2 = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is:&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick1&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick2&#125;</span>&gt;</span></span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>      &lt;!-- 方法三不推荐 --&gt;<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> this.handleClick3(e)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Toggle</span> /&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="方法三不推荐的原因："><a href="#方法三不推荐的原因：" class="headerlink" title="方法三不推荐的原因："></a>方法三不推荐的原因：</h3><blockquote><p>使用这个语法有个问题就是每次 LoggingButton 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。<br>在render方法中使用Function.prototype.bind会在每次组件渲染时创建一个新的函数，可能会影响性能（参见下文）</p></blockquote><h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><p>通常我们会为事件处理程序传递额外的参数。例如，若是 id 是你要删除那一行的 id，以下两种方式都可以向事件处理程序传递参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteRow</span>(id, e)&#125;&gt;<span class="hljs-title class_">Delete</span> <span class="hljs-title class_">Row</span>&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteRow.bind(this,</span> <span class="hljs-attr">id</span>)&#125;&gt;</span>Delete Row<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Popper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Hello world!&#x27;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">preventPop</span>(<span class="hljs-params">name, e</span>)&#123;    <span class="hljs-comment">//事件对象e要放在最后</span><br>        e.<span class="hljs-title function_">preventDefault</span>();<br>        <span class="hljs-title function_">alert</span>(name);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                &#123;/* Pass params via bind() method. */&#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://reactjs.org&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.preventPop.bind(this,this.state.name)&#125;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>reactjs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>reactjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective JavaScript(一)</title>
    <link href="/2018/06/19/2018-06-19-read-book-effective-one/"/>
    <url>/2018/06/19/2018-06-19-read-book-effective-one/</url>
    
    <content type="html"><![CDATA[<h2 id="了解你使用的JavaScript版本"><a href="#了解你使用的JavaScript版本" class="headerlink" title="了解你使用的JavaScript版本"></a>了解你使用的JavaScript版本</h2><p>由于不同的浏览器，对于JS的实现不同，我们必须精心编写代码保证他们在所有浏览器下工作如一。否则你可能面临这样的困境–应用程序在你自己的计算机上运行良好，但是部署到不同的环境时却无法运行。<br>例如，const关键字在支持非标准特性的JavaScript引擎上测试时运行良好，但是当将它部署到不识别const关键字的web浏览器上就会出现语法错误。<br>为此，ES5引入了一种版本控制的考量<code>严格模式</code>。此特性允许你选择在受限制的JavaScript版本中禁止使用一些JavaScript语言中问题较多或者易于出错的特性。<br>由于其语法设计向后兼容，因此即使在那些没有实现严格模式检查的环境中仍然可以执行严格代码（strict code）</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br></code></pre></td></tr></table></figure><p>该指令只有定义到脚本或函数的顶部才能生效。需要注意的是脚本连接时可能会将非严格模式脚本运行到严格模式下如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-comment">// no strict-mode</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable language_">arguments</span> = [];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种情况会报错，为了解决这个问题，我们通常会使用 立即调用的函数表达式(IIFE Immediately Invoked Function Expression) 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-string">&quot;use strict&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;)();<br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable language_">arguments</span> = [];<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="编写文件使其在两种模式下行为一致"><a href="#编写文件使其在两种模式下行为一致" class="headerlink" title="编写文件使其在两种模式下行为一致"></a>编写文件使其在两种模式下行为一致</h2><p>想要编写一个库来获得最大的兼容性最简单的方法就是在严格模式下编写代码，并显示的将代码内容包裹在本地启用了严格模式的函数中，这种类似前面所说的 将库文件包裹到一个立即调用的函数表达式中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-string">&quot;use strict&quot;</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable language_">arguments</span> = [];<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p><code>为了达到更普遍的兼容性建议在严格模式下编写代码。</code></p>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim快捷键和配置</title>
    <link href="/2018/03/15/2018-03-15-vim-config/"/>
    <url>/2018/03/15/2018-03-15-vim-config/</url>
    
    <content type="html"><![CDATA[<h3 id="vim快捷键和配置"><a href="#vim快捷键和配置" class="headerlink" title="vim快捷键和配置"></a>vim快捷键和配置</h3><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://github.com/SpaceVim/SpaceVim">SpaceVim</a></li><li><a href="http://vim-bootstrap.com/">vim-bootstrap</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>生产工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生产工具</tag>
      
      <tag>IDE</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能网站建设指南</title>
    <link href="/2017/12/20/2017-12-20-read-book-web/"/>
    <url>/2017/12/20/2017-12-20-read-book-web/</url>
    
    <content type="html"><![CDATA[<h1 id="高性能网站建设指南-前端工程师技能精髓"><a href="#高性能网站建设指南-前端工程师技能精髓" class="headerlink" title="高性能网站建设指南-前端工程师技能精髓"></a>高性能网站建设指南-前端工程师技能精髓</h1><h2 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h2><p><code>性能黄金法则</code>提示了只有10%~20%响应时间花在了HTML文档上其他都用在了加载各种组件包括（图片，样式表，脚本，falsh）进行的HTTP请求上。因此改善响应时间的最简单途径就是减少组件数量，并由此减少请求数量</p><p>可以以下通过方式</p><blockquote><p>CSS Sprites</p></blockquote><blockquote><p>内联图片 data:URL</p></blockquote><blockquote><p>合并脚本和样式表</p></blockquote><p>data:URL模式首次在1995年被提议其格式如下 :<code>data:mediatype;base64,data</code><br>其他类似的模式还有<br> ftp:，file:， mailto:， smtp:， pop:， dns:， whois:， finger:， daytime:，news: ， run:<br>需要注意的是内联图片不被IE支持，而且增加了文档的大小如果存在于HTML当中首次下载的文档大小会变大，鉴于此可以将内联图片放到css当中这样可以让图片可以被缓存而且这样减少了一个图片的http请求。</p><h2 id="使用内容发布网络CDN"><a href="#使用内容发布网络CDN" class="headerlink" title="使用内容发布网络CDN"></a>使用内容发布网络CDN</h2><p>合理使用cdn会很大程度增加网站响应速度而且价格不贵，比如本站使用的又拍云（非广告），即使被DDOS了也花不了多少</p><h2 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h2><p>通过设置一个长久有效的Expires头可以使web组件被缓存。web服务器通过Expires头来告诉Web客户端它可以使用一个组件的当前副本直到制定的时间为止。<br>但是由于Expires是一个特定时间，它要求服务器跟客户端始终严格同步（通常很难保证），所以需要跟Cache-Control: max-age=31500000 配合使用该项配置告诉客户端该组件过多长时间才会失效而不是到某一个时间失效。<br>如果两者同时出现max-age指令会覆盖Expires头。<br>比较幸运的是mod_expires Apache模块能够使用Expires头时能像max-age那样以相对的方式设置日期。使用Expire-Default指令来完成。设置如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs lasso">&lt;FilesMatch <span class="hljs-string">&quot;\.(gif|jpg|js|css)$&quot;</span>&gt;<br>    ExpiresDefault <span class="hljs-string">&quot;access plus 10 years&quot;</span><br>&lt;/FileMatch&gt;<br><span class="hljs-comment">//该指令会同时向响应中发送Expires头和Cache-Contral max-age,响应格式如下：</span><br>Expires: Wed, <span class="hljs-number">16</span> Oct <span class="hljs-number">2024</span> <span class="hljs-number">05</span>:<span class="hljs-number">43</span>:<span class="hljs-number">02</span> GMT<br><span class="hljs-keyword">Cache</span><span class="hljs-params">-control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">315360000</span><br><br></code></pre></td></tr></table></figure><p>通过设置Expires头可以避免额外的http请求，减少一半的响应时间。</p><p>##压缩组件<br>使用gzip来压缩组件，从HTTP1.1开始Web客户端可以通过HTTP请求中的: Accept-Enconding: gzip,deflate  来表示对于压缩的支持，如果Web服务器看到请求中有这个头就会使用客户端列出来的方法中的一种来压缩响应。Web服务器通过响应中的Content-Encoding头来通知客户端 : Content-Encoding: gzip.</p><blockquote><p>gzip是目前最流行和最有效的压缩方法， 另外一种deflate的方式效果略逊且不流行，因此gzip使最理想的压缩方式</p></blockquote><p>配置gzip使用的模块取决于Apache的版本</p><ul><li>Apache1.3使用mod_gzip</li><li>Apache2.x使用mod_deflate</li></ul><p>目前的状况是浏览器与服务器直接连接并没有任何问题，但是如果中间有代理服务器的话有两种情况<br>情况一：Web客户端不支持gzip发送到代理服务器，代理服务器向服务器请求得到未压缩的组件，然后组件被代理服务器缓存，此后对该组件的所有请求都走缓存，组件失去了压缩的机会，即使以后的客户端支持gzip也没用了<br>情况二：如何顺序相反缓存的则是gzip压缩后的组件，这样一个不支持gzip的Web浏览器无法正常解压导致组件可能失效。<br>无论哪种情况都不是我们希望见到的，解决这个问题的方式是在Web服务器的响应中添加Vary头。Web服务器可以告诉代理根据一个或多个请求头来改变缓存响应，由于压缩决定基于Accept-Encoding请求头的，因此需要在服务器的Vary响应中包含Accept-Encoding.  如 Vary: Accept-Encoding<br>这使得代理会缓存两个版本的内容如果有设置Accept-Encoding: gzip,deflate的返回压缩版本，没有设置的返回未压缩版本。<br>还可以把在Apache设置支持和不支持gzip白名单将User-Agent加入Vary如 <code>Vary: Accept-Encoding,User-Agent</code></p><h2 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h2><p>最好的实践是将Css放到head标签中防止FOUC（Flash Of Unstyled Content）。</p><blockquote><p>和A不一样，[LINK]只能出现在文档的HEAD中，但出现的次数时任意的</p></blockquote><p>CSS放到底部会在IE导致白屏</p><blockquote><ul><li>在新窗口打开时</li><li>重新加载时</li><li>作为主页时</li></ul></blockquote><h2 id="将脚本放到底部"><a href="#将脚本放到底部" class="headerlink" title="将脚本放到底部"></a>将脚本放到底部</h2><blockquote><ul><li>脚本会阻塞后面组件的下载</li><li>脚本会阻塞后面内容的呈现</li></ul></blockquote><p>所以最佳的位置就是放到页面body最底部</p><h2 id="避免CSS表达式"><a href="#避免CSS表达式" class="headerlink" title="避免CSS表达式"></a>避免CSS表达式</h2><p>css表达式使用不当会导致频繁的求值导致地下的性能</p><blockquote><p>可以明确的一点是不了解底层影响的情况下使用css表达式是非常危险的，所以尽量避免使用CSS表达式。</p></blockquote><h2 id="使用外部的Javascript和CSS"><a href="#使用外部的Javascript和CSS" class="headerlink" title="使用外部的Javascript和CSS"></a>使用外部的Javascript和CSS</h2><p>组件的引入不外乎内联和外置。就纯粹而已内联要快一些但是我们还是会使用外置的css和脚本，这是因为外置的组件是会被缓存的导致以后的请求会从浏览器缓存读渲染会更快，而内联的脚本会导致html体积增大但是HTML是不会缓存的这样每次请求的html体积都会很大，造成额外的带宽消耗。</p><ul><li>加载后下载脚本可以在第一次加载内联的组件然后异步加载外部组件以便为下次加载提供便利这里使用的html是不一样的需要注意。</li><li>动态内联，使用cookie来让后台决定返回那个页面。</li></ul><h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>根据HTTP1.1规范，建议浏览器从每个主机名并行下载两个组件，如果一个web页面平均的将组件放到两个主机名下整体响应时间会减少一半。<br>Yahoo研究表明使用两个主机名比使用1，4，10个主机名能带来更好的性能。因此建议将组件分别放到至少两个但是不超过四个与主机名下，这样不会造成过多的DNS查找，又可以为并行下载。</p><h2 id="精简Javascript"><a href="#精简Javascript" class="headerlink" title="精简Javascript"></a>精简Javascript</h2><p>可以使用gulp等工具对脚本和css进行混淆，精简和压缩，服务端开启gzip，以减少文件的体积大小。</p><h2 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h2><p>比如为了使用<a href="http://www.xxx.com/">www.xxx.com</a> 重定向到 <a href="http://www.xxx.com/">www.xxx.com/</a> 这种是不推荐的，我们只需要使用服务端配置，无需重定向就能拥有如此简洁的url即可</p><blockquote><p>寻找一种避免重定向的方法</p></blockquote><h2 id="删除重复脚本"><a href="#删除重复脚本" class="headerlink" title="删除重复脚本"></a>删除重复脚本</h2><blockquote><p>确保脚本只被包含一次</p></blockquote><p>可以添加文件MD5后缀或者时间戳来保证文件是不同的</p><h2 id="配置或删除ETag"><a href="#配置或删除ETag" class="headerlink" title="配置或删除ETag"></a>配置或删除ETag</h2><p>ETag，一般建议移除ETag</p><blockquote><p>比较最新修改日期 Last-Modified<br>比较实体标签 ETag</p></blockquote><h2 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h2><p>真实情况ajax一般不缓存<br>缓存可以缓存的ajax请求，通过修改cache-control</p><h2 id="析构网站的工具"><a href="#析构网站的工具" class="headerlink" title="析构网站的工具"></a>析构网站的工具</h2><p>YSlow</p>]]></content>
    
    
    <categories>
      
      <category>读书总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>读书总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generator函数的含义和用法</title>
    <link href="/2017/11/20/2017-11-20-js-generator/"/>
    <url>/2017/11/20/2017-11-20-js-generator/</url>
    
    <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>要了解generator首先需要说一下异步和同步，大家都知道，Javascript的语言执行环境是单线程（Single thread）.所谓<code>单线程</code>，就是只一次只能完成一个任务如果有多个任务就需要排队，前面一个任务完成，再执行后面一个任务，一次类推。<br>这种做法</p><blockquote><ul><li>好处是实现起来比较简单，执行环境相对单纯.</li><li>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li></ul></blockquote><p>为了解决上面的问题javascript将语言执行分成了两种： 同步（Synchronous）和异步（Asynchronous）.</p><ul><li>同步模式即从上往下依次执行，等待前一个任务执行完成后在执行下一个任务，执行顺序与代码顺序是一样的。</li><li>异步模式是每一个任务有一个或者多个回调函数，前一个任务结束后不执行下一个任务而是执行毁掉函数，后一个任务不等前一个任务结束就执行。执行顺序与代码顺序是不一致的，异步的。</li></ul><h2 id="异步模式的四种方法"><a href="#异步模式的四种方法" class="headerlink" title="异步模式的四种方法"></a>异步模式的四种方法</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>如果有两个函数f1和f2,后者等待前者的执行结果。但是f1是一个很耗时的任务可以将f2写成f1的回调函数</p><figure class="highlight scss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">f1</span>(callback) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(function() &#123;<br>        <span class="hljs-comment">// f1的任务代码</span><br>        <span class="hljs-built_in">callback</span>();<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><br><span class="hljs-built_in">f1</span>(f2);<br><br></code></pre></td></tr></table></figure><p>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生，直接上代码</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">f1<span class="hljs-selector-class">.on</span>(&#x27;done&#x27;, f2); <span class="hljs-comment">//f1监听&#x27;done&#x27;如果触发该事件执行f2,使用了jQuery的事件监听</span><br>function <span class="hljs-built_in">f1</span>(callback) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(function() &#123;<br>        <span class="hljs-comment">// f1的任务代码</span><br><br>        f1<span class="hljs-selector-class">.trigger</span>(&#x27;done&#x27;);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><br><span class="hljs-built_in">f1</span>(f2);<br></code></pre></td></tr></table></figure><h3 id="发布、订阅"><a href="#发布、订阅" class="headerlink" title="发布、订阅"></a>发布、订阅</h3><p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做<br><a href="http://en.wikipedia.org/wiki/Publish-subscribe_pattern">“发布/订阅模式”（publish-subscribe pattern）</a>，又称<a href="https://en.wikipedia.org/wiki/Observer_pattern">“观察者模式”（observer pattern）</a>。<br>这个模式有<a href="https://msdn.microsoft.com/en-us/magazine/hh201955.aspx?f=255&MSPPError=-2147217396">多种实现</a>,本例子使用<a href="https://gist.github.com/661855">Tiny Pub/Sub</a>,这是一个jQuery插件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">    jQuery.subscribe(<span class="hljs-string">&quot;done&quot;</span>, f2); <span class="hljs-regexp">//</span>首先，f2向<span class="hljs-string">&quot;信号中心&quot;</span>jQuery订阅<span class="hljs-string">&quot;done&quot;</span>信号。<br><br>    <span class="hljs-keyword">function</span> f1()&#123;<br>　　　　setTimeout(<span class="hljs-keyword">function</span> () &#123;<br>　　　　　　<span class="hljs-regexp">//</span> f1的任务代码<br>　　　　　　jQuery.publish(<span class="hljs-string">&quot;done&quot;</span>);<br>　　　　&#125;, <span class="hljs-number">1000</span>);<br>　　&#125;<br><span class="hljs-regexp">//</span>jQuery.publish(<span class="hljs-string">&quot;done&quot;</span>)的意思是，f1执行完成后，向<span class="hljs-string">&quot;信号中心&quot;</span>jQuery发布<span class="hljs-string">&quot;done&quot;</span>信号，从而引发f2的执行。<br><span class="hljs-regexp">//</span>此外，f2完成执行后，也可以取消订阅（unsubscribe）。<br>　　jQuery.unsubscribe(<span class="hljs-string">&quot;done&quot;</span>, f2);<br><br></code></pre></td></tr></table></figure><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。<br>它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">function</span> <span class="hljs-built_in">f1</span>()&#123;<br>　　　　var dfd = $.Deferred()<span class="hljs-comment">;</span><br>　　　　setTimeout(<span class="hljs-meta">function</span> () &#123;<br>　　　　　　<span class="hljs-comment">// f1的任务代码</span><br>　　　　　　dfd.resolve()<span class="hljs-comment">;</span><br>　　　　&#125;, <span class="hljs-number">500</span>)<span class="hljs-comment">;</span><br>　　　　return dfd.promise<span class="hljs-comment">;</span><br>　　&#125;<br><br>　　<span class="hljs-built_in">f1</span>().then(<span class="hljs-built_in">f2</span>)<span class="hljs-comment">;</span><br>　　<span class="hljs-built_in">f1</span>().then(<span class="hljs-built_in">f2</span>).then(<span class="hljs-built_in">f3</span>)<span class="hljs-comment">;</span><br>　　<span class="hljs-built_in">f1</span>().then(<span class="hljs-built_in">f2</span>).fail(<span class="hljs-built_in">f3</span>)<span class="hljs-comment">;</span><br><br><br></code></pre></td></tr></table></figure><p>它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。</p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">Generator 函数的含义与用法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>js基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>ES6学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lodash.js源码阅读分析（一）</title>
    <link href="/2017/11/16/2017-11-16-lodash-one/"/>
    <url>/2017/11/16/2017-11-16-lodash-one/</url>
    
    <content type="html"><![CDATA[<h2 id="Lodash-js源码阅读分析（一）"><a href="#Lodash-js源码阅读分析（一）" class="headerlink" title="Lodash.js源码阅读分析（一）"></a>Lodash.js源码阅读分析（一）</h2><p>通过详细阅读lodash的源码，学习代码风格同时补充基础。</p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="http://michalbe.blogspot.sg/2013/03/javascript-less-known-parts-bitwise.html">JavaScript: The less known parts</a></li><li><a href="https://segmentfault.com/a/1190000002608050">JS 的整型你懂了吗？</a></li></ul><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul><li><a href="http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/">每一个JavaScript开发者应该了解的浮点知识</a></li><li><a href="http://jser.it/blog/2014/07/07/numbers-in-javascript/">Numbers in JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>js基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Lodash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio快捷键</title>
    <link href="/2017/11/15/2017-10-31-quick-key/"/>
    <url>/2017/11/15/2017-10-31-quick-key/</url>
    
    <content type="html"><![CDATA[<h3 id="工欲善其事必先利其器快捷键总结"><a href="#工欲善其事必先利其器快捷键总结" class="headerlink" title="工欲善其事必先利其器快捷键总结"></a>工欲善其事必先利其器快捷键总结</h3><h3 id="项目相关的快捷键"><a href="#项目相关的快捷键" class="headerlink" title="项目相关的快捷键"></a>项目相关的快捷键</h3><p>Ctrl + Shift + B = 生成项目</p><p>Ctrl + Alt + L = 显示Solution Explorer（解决方案资源管理器）</p><p>Shift + Alt+ C = 添加新类</p><p>Shift + Alt + A = 添加新项目到项目</p><h3 id="编辑相关的键盘快捷键"><a href="#编辑相关的键盘快捷键" class="headerlink" title="编辑相关的键盘快捷键"></a>编辑相关的键盘快捷键</h3><p>Ctrl + Enter = 在当前行插入空行</p><p>Ctrl + Shift + Enter = 在当前行下方插入空行</p><p>Ctrl +空格键 = 使用IntelliSense（智能感知）自动完成</p><p>Alt + Shift +箭头键(←,↑,↓,→) = 选择代码的自定义部分</p><p>Ctrl + } = 匹配大括号、括号</p><p>Ctrl + Shift +} = 在匹配的括号、括号内选择文本</p><p>Ctrl + Shift + S = 保存所有文件和项目</p><p>Ctrl + K，Ctrl + C = 注释选定行</p><p>Ctrl + K，Ctrl + U = 取消选定行的注释</p><p>Ctrl + K，Ctrl + D = 正确对齐所有代码</p><p>Shift + End = 从头到尾选择整行</p><p>Shift + Home = 从尾到头选择整行</p><p>Ctrl + Delete = 删除光标右侧的所有字</p><h3 id="导航相关的键盘快捷键"><a href="#导航相关的键盘快捷键" class="headerlink" title="导航相关的键盘快捷键"></a>导航相关的键盘快捷键</h3><p>Ctrl +Up/Down = 滚动窗口但不移动光标</p><p>Ctrl + - = 让光标移动到它先前的位置</p><p>Ctrl ++ = 让光标移动到下一个位置</p><p>F12 = 转到定义</p><h3 id="调试相关的键盘快捷键"><a href="#调试相关的键盘快捷键" class="headerlink" title="调试相关的键盘快捷键"></a>调试相关的键盘快捷键</h3><p>Ctrl + Alt + P = 附加到进程</p><p>F10 = 调试单步执行</p><p>F5 = 开始调试</p><p>Shift + F5 = 停止调试</p><p>Ctrl + Alt + Q = 添加快捷匹配</p><p>F9 = 设置或删除断点</p><h3 id="搜索相关的键盘快捷键"><a href="#搜索相关的键盘快捷键" class="headerlink" title="搜索相关的键盘快捷键"></a>搜索相关的键盘快捷键</h3><p>Ctrl + K  Ctrl + K = 将当前行添加书签</p><p>Ctrl + K  Ctrl + N = 导航至下一个书签</p><p>Ctrl + . = 如果你键入一个类名如Collection<string>，且命名空间导入不正确的话，那么这个快捷方式组合将自动插入导入</p><p>Ctrl + Shift + F = 在文件中查找</p><p>Shift  + F12 = 查找所有引用</p><p>Ctrl + F = 显示查找对话框</p><p>Ctrl + H = 显示替换对话框</p><p>Ctrl + G = 跳转到行号或行</p><p>Ctrl + Shift + F = 查找所选条目在整个解决方案中的引用</p><h3 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h3><p><img src="https://msdn.microsoft.com/zh-cn/library/dn320181.aspx" alt="Visual Studio 的提示和技巧"></p>]]></content>
    
    
    <categories>
      
      <category>生产工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生产工具</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="/2017/11/15/2017-11-15-idea-quick/"/>
    <url>/2017/11/15/2017-11-15-idea-quick/</url>
    
    <content type="html"><![CDATA[<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li> <code>Command + Alt + L</code>： 格式化代码</li><li> <code>Command + Alt + I</code>： 将选中的代码进行自动缩进编排，这个功能在编辑JSP文件时也可以工作</li><li> <code>Command + Alt + o</code>： 优化导入的类和包(去掉无用的import语句)</li><li> <code>Command + /</code>： 注释 //</li><li> <code>Command + shift + /</code>： 注释 /**/</li><li> <code>Ctrl + shift + J</code>： 将两行合并成一行</li></ul><h3 id="定位跳转"><a href="#定位跳转" class="headerlink" title="定位跳转"></a>定位跳转</h3><ul><li> <code>Command + B</code>： 快速打开光标处的类或方法</li><li> <code>Command + Alt + B</code>： 跳转到方法实现处</li><li> <code>Command + Alt + Left/Right</code>： 返回至上次浏览的位置</li><li> <code>Command + Shift + Backspace</code>： 跳转到上次编辑的地方</li><li> <code>F2/Shift+F2</code>： 高亮错误或警告快速定位(跳转至报错的位置)</li><li> <code>Command + G</code>： 定位行(跳到输入的指定行数)</li><li> <code>Command + [ or ]</code>： 可以跑到大括号的开头与结尾(方便if或者方法范围查看)</li><li> <code>Alt + F3</code>： 逐个往下查找相同文本，并高亮显示</li></ul><h3 id="查找定位"><a href="#查找定位" class="headerlink" title="查找定位"></a>查找定位</h3><ul><li> <code>Command + N</code>： 可以快速打开类</li><li> <code>Command + Shift + N</code>： 可以快速打开文件  查找类中的方法或变量</li><li> <code>Command + Alt + Shift + N</code>： 查找类中的方法或变量</li><li> <code>Command + F</code>： 本文件中查找</li><li> <code>Ctrl + Shift + F</code>： 全局查找(在路径中查找)</li><li> <code>Shift + Shift</code>： 全局查找</li></ul><h3 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h3><ul><li> <code>Command + W</code>： 选中单词逐步扩大范围</li><li> <code>Command + R</code>： 在本文件替换文本</li><li> <code>Ctrl + Shift + R</code>： 在本文件替换文本</li><li> <code>Command + X</code>： 删除行</li><li> <code>Command + D</code>： 复制行</li><li> <code>Command + Y</code>： 删除当前行</li><li> <code>Alt + Shift + Up/Down</code>： 当前行上下移动</li><li> <code>Command + Shift + U</code>： 大小写转化</li><li> <code>Command + Shift + Z</code>： 重做，即反撤销(与搜狗输入法查看字符冲突)</li><li> <code>Command + Shift + V</code>： 查看最近复制的多条内容，并选择需要的内容粘贴</li></ul><h3 id="代码-方法-生成"><a href="#代码-方法-生成" class="headerlink" title="代码(方法)生成"></a>代码(方法)生成</h3><ul><li> <code>psvm/sout</code>： main函数/System.out.println();</li><li> <code>Command + J</code>： 查看更多快捷方法</li><li> <code>Command + Shift + 回车</code>： 自动补全、换行</li><li> <code>Ctrl + Space</code>： 代码提示（与系统输入法快捷键冲突） </li><li> <code>Command + Alt + T</code>： 可以把代码包在一个块内，例如：try/catch</li></ul><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li> <code>Command + E</code>： 显示最近操作过的文件</li><li> <code>Alt + F7</code>： 查找整个工程中使用地某一个类、方法或者变量的位置</li><li> <code>Command + F7</code>： 可以查询当前元素在当前文件中的引用，然后按 F3 可以选择</li><li> <code>Command + Shift + F7</code>： 高亮显示所有该文本，按 Esc 高亮消失</li><li> <code>Command + P</code>： 可以显示参数信息</li><li> <code>Command + F12</code>： 可以显示当前文件的结构</li><li> <code>Ctrl + H</code>： 显示类结构图（类的继承层次）</li><li> <code>Command + 6</code>： 查看所有TODO</li><li> <code>Command + 7</code>： 查看本类结构</li><li> <code>Command + +/-</code>： 当前方法展开、折叠</li><li> <code>Command + Shift + +/-</code>： 全部展开、折叠</li></ul><p>Alt+Insert：可以生成构造器/Getter/Setter等(建议使用lombok插件及@Data注解) 未验证<br>Alt+ Up/Down(上下箭头)：在方法间快速移动定位</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html">IntelliJ IDEA For Mac 快捷键</a><h4 id="IntelliJ-IDEA-For-Mac-快捷键"><a href="#IntelliJ-IDEA-For-Mac-快捷键" class="headerlink" title="IntelliJ IDEA For Mac 快捷键"></a>IntelliJ IDEA For Mac 快捷键</h4></li><li>  根据官方pdf翻译：<a href="https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf</a></li><li>  在 IntelliJ IDEA 中有两个 Mac 版本的快捷键，一个叫做：Mac OS X，一个叫做：Mac OS X 10.5+</li><li>  目前都是用：Mac OS X 10.5+</li><li>  有两套的原因：<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206159109-Updated-Mac-OS-X-keymap-Feedback-needed">https://intellij-support.jetbrains.com/hc/en-us/community/posts/206159109-Updated-Mac-OS-X-keymap-Feedback-needed</a><blockquote><p>建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>生产工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生产工具</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SublimeText快捷键</title>
    <link href="/2017/11/15/2017-11-15-sublime-quick/"/>
    <url>/2017/11/15/2017-11-15-sublime-quick/</url>
    
    <content type="html"><![CDATA[<h2 id="Sublime-Text-2-实用快捷键-Mac-OS-X"><a href="#Sublime-Text-2-实用快捷键-Mac-OS-X" class="headerlink" title="Sublime Text 2 - 实用快捷键 (Mac OS X)"></a>Sublime Text 2 - 实用快捷键 (Mac OS X)</h2><h3 id="打开-前往"><a href="#打开-前往" class="headerlink" title="打开/前往"></a>打开/前往</h3><p>| <em>⌘T</em> | 前往文件 |<br>| <em>⌘⌃P</em> | 前往项目 |<br>| <em>⌘R</em> | 前往 method |<br>| <em>⌘⇧P</em> | 命令提示 |<br>| <em>⌃G</em> | 前往行 |<br>| <em>⌃ `</em> | python 控制台 |</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>| <em>⌘L</em> | 选择行 (重复按下将下一行加入选择) |<br>| <em>⌘D</em> | 选择词 (重复按下时多重选择相同的词进行多重编辑) |<br>| <em>⌃⇧M</em> | 选择括号内的内容 |<br>| <em>⌘⇧↩</em> | 在当前行前插入新行 |<br>| <em>⌘↩</em> | 在当前行后插入新行 |<br>| <em>⌃⇧K</em> | 删除行 |<br>| <em>⌘KK</em> | 从光标处删除至行尾 |<br>| <em>⌘K⌫</em> | 从光标处删除至行首 |<br>| <em>⌘⇧D</em> | 复制(多)行 |<br>| <em>⌘J</em> | 合并(多)行 |<br>| <em>⌘KU</em> | 改为大写 |<br>| <em>⌘KL</em> | 改为小写 |<br>| <em>⌘ /</em> | 注释 |<br>| <em>⌘⌥ /</em> | 块注释 |<br>| <em>⌘Y</em> | 恢复或重复 |<br>| <em>⌘⇧V</em> | 粘贴并自动缩进 |<br>| <em>⌃ space</em> | 自动完成(重复按下选择下一个提示) |<br>| <em>⌃M</em> | 跳转至对应的括号 |</p><h3 id="XML-HTML"><a href="#XML-HTML" class="headerlink" title="XML/HTML"></a>XML/HTML</h3><p>| <em>⌘⇧A</em> | 选择标签内的内容 |<br>| <em>⌘⌥ .</em> | 闭合当前标签 |</p><h3 id="查找-替换"><a href="#查找-替换" class="headerlink" title="查找/替换"></a>查找/替换</h3><p>| <em>⌘F</em> | 查找 |<br>| <em>⌘⌥F</em> | 替换 |<br>| <em>⌘⌥G</em> | 查找下一个符合当前所选的内容 |<br>| <em>⌘⌃G</em> | 查找所有符合当前所选的内容进行多重编辑 |<br>| <em>⌘⇧F</em> | 在所有打开的文件中进行查找 |</p><h3 id="拆分窗口-标签页"><a href="#拆分窗口-标签页" class="headerlink" title="拆分窗口/标签页"></a>拆分窗口/标签页</h3><p>| <em>⌘⌥1</em> | 单列 |<br>| <em>⌘⌥2</em> | 双列 |<br>| <em>⌘⌥5</em> | 网格 (4组) |<br>| <em>⌃[1,2,3,4]</em> | 焦点移动至相应组 |<br>| <em>⌃⇧[1,2,3,4]</em> | 将当前文件移动至相应组 |<br>| <em>⌘[1,2,3…]</em> | 选择相应标签页 |</p><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>| <em>⌘F2</em> | 添加/去除书签 |<br>| <em>F2</em> | 下一个书签 |<br>| <em>⇧F2</em> | 前一个书签 |<br>| <em>⌘⇧F2</em> | 清除书签 |</p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>| <em>⌘K space</em> | 设置标记 |<br>| <em>⌘KW</em> | 从光标位置删除至标记 |<br>| <em>⌘KA</em> | 从光标位置选择至标记 |<br>| <em>⌘KG</em> | 清除标记 |</p>]]></content>
    
    
    <categories>
      
      <category>生产工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生产工具</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript的位操作</title>
    <link href="/2017/11/01/2017-11-01-bin-operate/"/>
    <url>/2017/11/01/2017-11-01-bin-operate/</url>
    
    <content type="html"><![CDATA[<h1 id="关于javascript中的-操作"><a href="#关于javascript中的-操作" class="headerlink" title="关于javascript中的~操作"></a>关于javascript中的~操作</h1><p>参考文章中有一道面试题,尽管文章已经有了一部分解释但是还有一些点不够明确在此在进行一次分析</p><blockquote><p>!~location.href.search(‘abc’)</p></blockquote><p>首先再次回顾一下js中的位运算</p><ul><li>&amp; 与</li><li>| 或</li><li>~ 非</li><li>^ 异或</li><li>&lt;&lt; 左移</li><li>&gt;&gt; 算数右移(有符号右移)</li><li>&gt;&gt;&gt; 逻辑右移(无符号右移)</li></ul><p>Number.prototype.toString</p><p>Number.prototype.toString方法可以讲数字转化为字符串，有一个可选的参数，用来决定将数字显示为指定的进制，下面可以查看3的二进制表示</p><p>````<br> 3..toString(2)</p><p> (3).toString(2)</p><p> Number(3).toString(2)   //这里如果直接 3.toString(2)是会报错的</p><blockquote><blockquote><p>11</p></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># &amp; 与</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">&amp;按位与会将操作数和被操作数的相同为进行与运算，如果都为1则为1，如果有一个为0则为0</span><br><br></code></pre></td></tr></table></figure><p>101<br>011</p><hr><p>001</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># \| 或</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">按位或是相同的位置上只要有一个为1就是1，两个都为0则为0</span><br><br></code></pre></td></tr></table></figure><p>101<br>001</p><hr><p>101</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># ~ 非</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">~操作符会将操作数的每一位取反，如果是1则变为0，如果是0则边为1</span><br><br></code></pre></td></tr></table></figure><h2 id="101"><a href="#101" class="headerlink" title="101"></a>101</h2><p>010</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># ^ 异或</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">再来说说异或，这个比较有意思，异或顾名思义看看两个位是否为异——不同，两个位不同则为1，两个位相同则为0</span><br><br><br><br></code></pre></td></tr></table></figure><p>101<br>001</p><hr><p>100</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>再次分析开头的问题<br><br>首先关于indexOf获得的值可能有几种请求 <span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> 从这三种进行分析<br><br>## ~<span class="hljs-number">-1</span><br><br>为了简便计算我这只取<span class="hljs-number">8</span>位<br><br></code></pre></td></tr></table></figure><p>10000001  //这是-1的原码 (真值的绝对值加上符号位)<br>——–  //进行按位非操作后 这里会改变符号<br>01111110  //得到此值为正值要获得该值得真值需要然后取反再减一 注意取反的操作不会改变符号</p><hr><p>00000000  //最后得到的值是0</p><p>//浏览器控制台输出</p><p>~-1<br>0</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>## ~<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>00000000  //这是0的原码 (真值的绝对值加上符号位)<br>——–  //进行按位非操作后 这里会改变符号<br>11111111  //得到此值该值为负值的补码 要获得该值得真值需要对补码求补即取反+1 (注意取反的操作不会改变符号)</p><hr><p>10000001  //最后得到的值是1</p><p>//浏览器控制台输出</p><p>~0<br>-1</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><br><br>## ~<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>00000001  //这是1的原码 (真值的绝对值加上符号位)<br>——–  //进行按位非操作后 这里会改变符号<br>11111110  //得到此值该值为负值的补码 要获得该值得真值需要对补码求补即取反+1 (注意取反的操作不会改变符号)</p><hr><p>10000010  //最后得到的值是2</p><p>//浏览器控制台输出</p><p>~1<br>-2</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br>因此在上面问题出现的时候<br><br></code></pre></td></tr></table></figure><p>~location.href.search(‘abc’)  //未匹配到返回 -1 这里为 ~-1  == 0 ==&gt; !0 == true;<br>~location.href.search(‘abc’)  //未匹配到返回 0 这里为 ~0  == -1 ==&gt; !-1 == false;<br>~location.href.search(‘abc’)  //未匹配到返回 1 这里为 ~1  == -2 ==&gt; !-2== false;</p><p>```</p><p>因此只有返回 -1时</p><p>如果为 -1 说明未匹配到</p><blockquote><p>!~location.href.search(‘abc’) ===&gt; true</p></blockquote><p>得证。</p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="http://yanhaijing.com/javascript/2016/07/20/binary-in-js/">聊聊JavaScript中的二进制数</a></li><li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码, 反码, 补码 详解</a></li></ul><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul><li><a href="http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/">每一个JavaScript开发者应该了解的浮点知识</a></li><li><a href="http://jser.it/blog/2014/07/07/numbers-in-javascript/">Numbers in JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>js基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript的的最大安全数</title>
    <link href="/2017/11/01/2017-11-15-js-base-number/"/>
    <url>/2017/11/01/2017-11-15-js-base-number/</url>
    
    <content type="html"><![CDATA[<h2 id="JS-中的最大安全整数"><a href="#JS-中的最大安全整数" class="headerlink" title="JS 中的最大安全整数"></a>JS 中的最大安全整数</h2><p>JS中所有的数字类型存储都是<a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">双精度浮点数</a>浮点数并不是能够精确表示范围内的所有数的， 虽然 double 浮点型的范围看上去很大: 2.23x10^(-308) ~ 1.79x10^308。 可以表示的最大整数可以很大，但能够精确表示，使用算数运算的并没有这么大。</p><p>例如下面会报错</p><figure class="highlight arcade"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>)<br><span class="hljs-comment">//output: 0.30000000000000004</span><br><br><span class="hljs-comment">//在js中的最大安全整数</span><br>Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) - <span class="hljs-number">1</span>     <span class="hljs-comment">// 9007199254740991</span><br><br><span class="hljs-comment">//在其他语言的64位环境中有符号的 安全（注意这里是指能够安全使用，进行算数运算的范围） 最大整数。</span><br><span class="hljs-number">2</span>^<span class="hljs-number">63</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">//9223372036854775807</span><br><br><br><span class="hljs-comment">//JS 的最大和最小安全值可以这样获得:</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER); <span class="hljs-comment">//9007199254740991</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER); <span class="hljs-comment">//-9007199254740991</span><br><br><br><span class="hljs-comment">//通过下面的例子，你会明白为什么大于这个值的运算是不安全的,这些运算都是错误的结果， 因为它们进行的都是浮点数运算会丢失精度。</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">9223372036854775807</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x === x + <span class="hljs-number">1</span>);<span class="hljs-comment">// output: true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">9223372036854775807</span> + <span class="hljs-number">1000</span>); <span class="hljs-comment">//output: 9223372036854776000</span><br><br></code></pre></td></tr></table></figure><h2 id="为什么是这个值"><a href="#为什么是这个值" class="headerlink" title="为什么是这个值?"></a>为什么是这个值?</h2><p><img src="https://cdn.darknights.cn/assets/images/in-post/js-base/number.png"></p><ul><li>1 位符号位</li><li>11 位指数位</li><li>52 位尾数位</li></ul><p>使用 52 位表示一个数的整数部分，那么最大可以精确表示的数应该是 2^52 - 1 才对， 就像 64 位表示整数时那样: 2^63 - 1 （去掉 1 位符号位）。 但其实浮点数在保存数字的时候做了规格化处理，以 10 进制为例:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20</span>*<span class="hljs-number">10</span>^<span class="hljs-number">2</span> =&gt; <span class="hljs-number">2</span>*<span class="hljs-number">10</span>^<span class="hljs-number">3</span> //小数点前只需要保留 <span class="hljs-number">1</span> 位数<br></code></pre></td></tr></table></figure><p>对于二进制来说， 小数点前保留一位， 规格化后始终是 1.***, 节省了 1 bit，这个 1 并不需要保存。</p><h2 id="大整数与数据库"><a href="#大整数与数据库" class="headerlink" title="大整数与数据库"></a>大整数与数据库</h2><p>Nodejs 越来越多的应用到后端的开发中， 不可避免的需要处理这样的溢出问题， 好在已经有很多优秀的第三方库来解决该问题：<a href="https://github.com/justmoon/node-bignum">bignum</a>、bigint。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">//每种类型的第二行为无符号范围<br>TYPE         BYTE   MIN            MAX<br>TINYINT      <span class="hljs-number">1</span>     -<span class="hljs-number">128</span>            <span class="hljs-number">127</span><br>                                   <span class="hljs-number">255</span><br>SMALLINT     <span class="hljs-number">2</span>    -<span class="hljs-number">32768</span>          <span class="hljs-number">32767</span><br>                                  <span class="hljs-number">65535</span><br>MEDIUMINT    <span class="hljs-number">3</span>    -<span class="hljs-number">8388608</span>       <span class="hljs-number">8388607</span><br>                                 <span class="hljs-number">16777215</span><br>INT          <span class="hljs-number">4</span>   -<span class="hljs-number">2147483648</span>    <span class="hljs-number">2147483647</span><br>                                <span class="hljs-number">4294967295</span><br>BIGINT       <span class="hljs-number">8</span>  -<span class="hljs-number">9223372036854775808</span>    <span class="hljs-number">9223372036854775807</span><br>                                       <span class="hljs-number">18446744073709551615</span><br></code></pre></td></tr></table></figure><p>BIGINT 就是 64 位整数， 一旦要处理的数据量超过了 BIGINT 能存储的范围，便要考虑使用字符串保存， 坏处是数字的算数运算需要通过应用程序使用大整数库来处理，不能依赖于数据库。</p><p>注: 常常看到 BIGINT(5) 或者 INT(10)， 括号里的 5 或 10 只是表示展示宽度，并不影响数的精度范围和存储字节数，需要与 VARCHAR(100)或 DECIMAL(10,2)区分开</p><h2 id="JS右移0位"><a href="#JS右移0位" class="headerlink" title="JS右移0位"></a>JS右移0位</h2><p>在Javascript代码有时候会看到this.length &gt;&gt; 0这样的类似代码，那么this.length &gt;&gt; 0这样的代码有什么用呢？</p><ul><li>&gt;&gt; 代表有符号右移运算符 === 算术右移</li><li>&gt;&gt;&gt; 在Javascript中代表无符号右移运算符 === 逻辑右移<br>移位运算分为左移和右移，其中左移运算都是丢弃最高位，在右端补零。而右移预算则分为逻辑右移<code>>>></code>和算术右移动<code>>></code>，逻辑右移在左端补零，算术右移则在左端扑最高有效位的值。</li></ul><p><code>this.length >> 0</code>的作用更简易的总结：</p><ul><li>所有非数值转换成0</li><li>所有大于等于 0 数取整数部分（快速去掉小数）<br>例：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;hello&#x27;</span> &gt;&gt; <span class="hljs-number">0</span>  <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><span class="hljs-number">32.5</span> &gt;&gt; <span class="hljs-number">0</span>  <span class="hljs-regexp">//</span> <span class="hljs-number">32</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="http://michalbe.blogspot.sg/2013/03/javascript-less-known-parts-bitwise.html">JavaScript: The less known parts</a></li><li><a href="https://segmentfault.com/a/1190000002608050">JS 的整型你懂了吗？</a></li></ul><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul><li><a href="http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/">每一个JavaScript开发者应该了解的浮点知识</a></li><li><a href="http://jser.it/blog/2014/07/07/numbers-in-javascript/">Numbers in JavaScript</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>js基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的后台管理主题模板</title>
    <link href="/2017/10/31/2017-10-31-admin-theme/"/>
    <url>/2017/10/31/2017-10-31-admin-theme/</url>
    
    <content type="html"><![CDATA[<h3 id="前端ui框架排名"><a href="#前端ui框架排名" class="headerlink" title="前端ui框架排名"></a><a href="http://usablica.github.io/front-end-frameworks/compare.html">前端ui框架排名</a></h3><h2 id="常用后台管理主题推荐"><a href="#常用后台管理主题推荐" class="headerlink" title="常用后台管理主题推荐"></a>常用后台管理主题推荐</h2><ul><li><p>jQuey: <a href="http://www.bootcss.com/">Bootstrap</a></p></li><li><p>React: <a href="https://ant.design/index-cn">ant.design</a></p></li><li><p>Vue: <a href="http://element.eleme.io/#/zh-CN/component/layout">Element</a></p></li><li><p>Angular <a href="https://material-ui.com/">Material UI</a></p></li><li><p><a href="http://elemefe.github.io/mint-ui/#/">Mint-ui</a></p></li></ul><h3 id="门户网站ui框架"><a href="#门户网站ui框架" class="headerlink" title="门户网站ui框架"></a>门户网站ui框架</h3><ul><li><a href="https://zurb.com/responsive">Foundation</a></li></ul><h3 id="个人ui框架"><a href="#个人ui框架" class="headerlink" title="个人ui框架"></a>个人ui框架</h3><ul><li><a href="https://www.iviewui.com/">iviewui</a></li><li><a href="https://github.com/airyland/vux">vux</a></li></ul><h3 id="移动端ui框架"><a href="#移动端ui框架" class="headerlink" title="移动端ui框架"></a>移动端ui框架</h3><ul><li><p><a href="http://m.sui.taobao.org/components/">sui</a></p></li><li><p><a href="http://framework7.taobao.org/get-started/#.W5iaWZMzZTY">Framework7</a></p></li><li><p><a href="https://weui.io/">weui</a></p></li><li><p><a href="http://dev.dcloud.net.cn/mui/">mui</a></p></li></ul><h3 id="企业级ui框架"><a href="#企业级ui框架" class="headerlink" title="企业级ui框架"></a>企业级ui框架</h3><ul><li><a href="www.uileader.com">Quick UI</a></li></ul><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul><li><a href="https://purecss.io/">纯css框架Pure.css</a></li><li><a href="https://github.com/Semantic-Org/Semantic-UI">Semantic-UI</a></li><li><a href="http://www.getuikit.net/">uikit</a></li></ul><p>个人感觉基于bootstrap的管理模板都大同小异参考文章中的内容基本可以满足需求推荐以下免费主题供大家参考</p><p><a href="http://thetheme.io/theadmin/">thetheme.io</a></p><p><a href="http://flatfull.com/themes/flatkit/angular/#/app/dashboard">flatfull.com</a></p><p><a href="https://wrappixel.com/demos/free-admin-templates/matrix-admin/index.html">matrix-admin</a></p><p><a href="http://demo.thedevelovers.com/dashboard/klorofil-v2.0/icons.html">KLOROFIL</a></p><p><a href="https://adminlte.io/themes/AdminLTE/pages/UI/sliders.html">adminlte.io</a></p><p><a href="https://wrappixel.com/demos/admin-templates/pixeladmin/inverse/index.html">pixeladmin</a></p><p><a href="http://akveo.com/blur-admin-mint/#/tables/basic">akveo 这个挺快</a></p><p><a href="http://akveo.com/ngx-admin/#/pages/dashboard">ngx-admin</a></p><p>参考文章</p><blockquote><ul><li><a href="https://colorlib.com/wp/free-bootstrap-admin-dashboard-templates/">20 Free Bootstrap 3 Admin Dashboard Templates For Your Web App 2017</a></li><li><a href="https://elements.envato.com/web-templates/admin-templates">admin templates</a></li><li><a href="https://athemes.com/collections/free-bootstrap-admin-templates/">20 Best Free Bootstrap Admin Templates 2017</a><br><a href="https://cssauthor.com/bootstrap-admin-templates/">100+ Best Free Bootstrap Admin Templates</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>管理系统主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码, 反码, 补码 详解</title>
    <link href="/2017/10/31/2017-10-31-bin-calculate/"/>
    <url>/2017/10/31/2017-10-31-bin-calculate/</url>
    
    <content type="html"><![CDATA[<h1 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h1><p> 在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</p><h2 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h2><p>一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p><p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p><p>那么，这里的 00000011 和 10000011 就是机器数。</p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><blockquote><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131?&gt;（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。<br>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p></blockquote><h1 id="原码-反码-补码的基础概念和计算方法"><a href="#原码-反码-补码的基础概念和计算方法" class="headerlink" title="原码, 反码, 补码的基础概念和计算方法"></a>原码, 反码, 补码的基础概念和计算方法</h1><p>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><blockquote><p>[+1]原 = 0000 0001</p></blockquote><blockquote><p>[-1]原 = 1000 0001</p></blockquote><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><blockquote><p>[1111 1111 , 0111 1111] 即 [-127 , 127]</p></blockquote><p>原码是人脑最容易理解和计算的表示方式.</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>反码的表示方法是:</p><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><blockquote><p>[+1] = [00000001]原 = [00000001]反</p></blockquote><blockquote><p>[-1] = [10000001]原 = [11111110]反</p></blockquote><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码的表示方法是:</p><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><blockquote><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p></blockquote><blockquote><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></blockquote><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><h1 id="为何要使用原码-反码和补码"><a href="#为何要使用原码-反码和补码" class="headerlink" title="为何要使用原码, 反码和补码"></a>为何要使用原码, 反码和补码</h1><p>在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法.</p><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p><blockquote><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p></blockquote><p>所以不需要过多解释. 但是对于负数:</p><blockquote><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p></blockquote><p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><p>计算十进制的表达式: 1-1=0</p><blockquote><p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p></blockquote><p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p><p>为了解决原码做减法的问题, 出现了反码:</p><p>计算十进制的表达式: 1-1=0</p><blockquote><p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p></blockquote><p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p><p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p><blockquote><p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p></blockquote><p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p><blockquote><p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p></blockquote><p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p><p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p><p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul><li><a href="http://yanhaijing.com/javascript/2016/07/20/binary-in-js/">聊聊JavaScript中的二进制数</a></li><li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码, 反码, 补码 详解</a></li></ul><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul><li><a href="http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/">每一个JavaScript开发者应该了解的浮点知识</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>娱乐</title>
    <link href="/2017/10/29/2017-10-29-entertainment/"/>
    <url>/2017/10/29/2017-10-29-entertainment/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><p><a href="https://thepiratebay.org/">海盗湾</a></p></li><li><p><a href="https://kickass-top.org/">kickass-top.org</a></p></li><li><p><a href="http://www.btbtdy.com/">BT电影天堂</a></p></li><li><p><a href="https://wall.alphacoders.com/by_collection.php?id=39&lang=Chinese&page=1">壁纸</a></p></li><li><p><a href="https://alpha.wallhaven.cc/toplist?page=5">壁纸2</a></p></li><li><p><a href="https://axhub.im/">原型发布与管理工具</a></p></li><li><p><a href="https://www.10besty.com/best-vps/">2018最好的vps推荐，带测试链接</a></p></li><li><p><a href="https://sspai.com/post/41174">少数派-关于下载</a></p></li><li><p><a href="http://bbs.iosre.com/t/hopper-mac/1428">用Hopper搞定迅雷会员</a></p></li><li><p><a href="http://dy0825.com/">http://dy0825.com/</a></p></li><li><p><a href="http://www.iconfont.cn/">iconfont素材</a></p></li><li><p><a href="https://unsplash.com/">unsplash 图片素材</a></p></li></ul><ul><li><p><a href="http://code.giffox.com/">做个导航页导航页</a></p></li><li><p><a href="http://chuangzaoshi.com/">导航页</a></p></li><li><p><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.13.6b73eea0DWeJvr&id=43924640630&cm_id=140105335569ed55e27b&abbucket=15&skuId=3679227295210">NAS （网络附属存储）</a></p></li><li><p><a href="http://yukai.space/2017/06/05/%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%AE%B6%E9%87%8C%E7%9A%84%E7%94%B5%E8%84%91/">如何从外网访问家里的电脑</a></p></li><li><p><a href="http://www.nasyun.com/forum.php">nas云</a></p></li><li><p><a href="http://www.itmuch.com/install/nginx-yum-install-in-centos7/">在CentOS 7中，使用yum安装Nginx</a></p></li><li><p><a href="http://blog.csdn.net/Hmily_hui/article/details/77743705">搭建Jetbrains家族IDE授权服务器</a></p></li><li><p><a href="http://blog.lanyus.com/archives/174.html">IntelliJ IDEA License Server本地搭建教程</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的使用教程(三)</title>
    <link href="/2017/10/22/2017-10-22-git-senior/"/>
    <url>/2017/10/22/2017-10-22-git-senior/</url>
    
    <content type="html"><![CDATA[<h2 id="git的高级使用教程"><a href="#git的高级使用教程" class="headerlink" title="git的高级使用教程"></a>git的高级使用教程</h2><p>记录一些git的高级用法</p><h2 id="修改tag代码"><a href="#修改tag代码" class="headerlink" title="修改tag代码"></a>修改tag代码</h2><p>在项目中我们会有这样的要求，发布了一个tag v1.0现在这个tag有bug需要修复应该如何操作呢<br>tag其实是一个快照是不能修改代码的但是可以基于tag新建一个分支来修改，这样修改完毕基于新的分支再打tag即可得到修复后的tag</p><figure class="highlight crmsh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs crmsh">$ git fetch origin v1.<span class="hljs-number">0</span><br><br>$ git checkout -b branch_name tag_name //这样会从 <span class="hljs-keyword">tag</span> <span class="hljs-title">创建一个分支，然后就和普通的 git</span> 操作一样了,该分支是基于<span class="hljs-keyword">tag</span>的而不是基于<span class="hljs-literal">master</span>的<br><br>$ git push origin branch_name  //直接将修改好的分支推上去 或者重新打<span class="hljs-keyword">tag</span><br><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h2 id="回滚错误的修改"><a href="#回滚错误的修改" class="headerlink" title="回滚错误的修改"></a>回滚错误的修改</h2><p>建议仔细阅读<a href="https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9#git-revert">git-revert</a><br>该命令只回滚了一个单独的提交，并没有移除后面的提交，并且保留了提交历史。 但是reset直接把状态回调bug之前之后所有的提交都会遗弃，这样并不安全。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git revert &lt;commit&gt;<br><br><br><span class="hljs-comment"># 编辑一些跟踪的文件</span><br><br><span class="hljs-comment"># 提交一份快照</span><br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&quot;Make some changes that will be undone&quot;</span><br><br><span class="hljs-comment"># 撤销刚刚的提交</span><br><span class="hljs-variable">$ </span>git revert <span class="hljs-title class_">HEAD</span><br></code></pre></td></tr></table></figure><p>确保你只对本地的修改使用 git reset，而不是公共更改。如果你需要修复一个公共提交，git revert 命令正是被设计来做这个的</p><h2 id="重写项目历史"><a href="#重写项目历史" class="headerlink" title="重写项目历史"></a>重写项目历史</h2><h3 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h3><p>git commit –amend 命令是修复最新提交的便捷方式，如有需要请在本地使用不要修改公共历史。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">log</span><br><br><span class="hljs-keyword">commit</span> eeeab2ca5f30d70667d6d12ab71f19dd7b958d1c (HEAD -&gt; master)<br>Author: xxx &lt;xxx@xxx.com&gt;<br><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">6</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43</span> <span class="hljs-number">2017</span> +<span class="hljs-number">0800</span><br><br>    fix(测试): 测试提交<br><br>    测试提交<br><br>    Signed-<span class="hljs-keyword">off</span>-<span class="hljs-keyword">by</span>: xxx &lt;xxx@xxx.com&gt;<br><br><br>$ git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span><br><br># 该命令修改后再使用git <span class="hljs-keyword">log</span>得到如下<br><br><span class="hljs-keyword">commit</span> eeeab2ca5f30d70667d6d12ab71f19dd7b958d1c (HEAD -&gt; master)<br>Author: xxx &lt;xxx@xxx.com&gt;<br><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">6</span> <span class="hljs-number">15</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43</span> <span class="hljs-number">2017</span> +<span class="hljs-number">0800</span><br><br>    fix(测试): 测试提交sss<br><br>    测试提交sss<br><br>    Signed-<span class="hljs-keyword">off</span>-<span class="hljs-keyword">by</span>: xxx &lt;xxx@xxx.com&gt;<br><br><br></code></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基（rebase, 事实上这个名字十分诡异, 所以在大多数时候直接用英文术语）是将分支移到一个新的基提交的过程。事实上重写了你的项目历史,过程一般如下所示<br><img src="https://cdn.darknights.cn/assets/images/in-post/git-senior/rebase.svg"></p><p>用法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">git rebase <span class="hljs-tag">&lt;<span class="hljs-name">base</span>&gt;</span><br><br># 将当前分支 rebase 到 <span class="hljs-tag">&lt;<span class="hljs-name">base</span>&gt;</span>，这里可以是任何类型的提交引用（ID、分支名、标签，或是 HEAD 的相对引用）<br></code></pre></td></tr></table></figure><p>一个🌰</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 开始新的功能分支</span><br>$ git checkout -b feat <span class="hljs-keyword">master</span><br><span class="hljs-title"># 编辑文件</span><br><span class="hljs-title">$</span> git commit -a -m <span class="hljs-string">&quot;Start developing a feature&quot;</span><br><br><span class="hljs-comment"># 在 feature 分支开发了一半的时候，我们意识到项目中有一个安全漏洞:</span><br><br><span class="hljs-comment"># 基于master分支创建一个快速修复分支</span><br>$ git checkout -b bug <span class="hljs-keyword">master</span><br><span class="hljs-title"># 编辑文件</span><br><span class="hljs-title">$</span> git commit -a -m <span class="hljs-string">&quot;Fix security hole&quot;</span><br><span class="hljs-comment"># 合并回master</span><br>$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git merge bug<br>$ git branch -d bug<br><br><span class="hljs-comment"># 将 hotfix 分支并回之后 master，我们有了一个分叉的项目历史。</span><br><span class="hljs-comment"># 我们用 rebase 整合 feature 分支以获得线性的历史，而不是使用普通的 git merge。</span><br>$ git checkout feat<br>$ git rebase <span class="hljs-keyword">master</span><br><br><span class="hljs-title">$</span> git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git merge feat<br><br></code></pre></td></tr></table></figure><p>另一个🌰</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 开始新的功能分支</span><br>$ git checkout -b feat <span class="hljs-keyword">master</span><br><span class="hljs-title"># 编辑文件</span><br><span class="hljs-title">$</span> git commit -a -m <span class="hljs-string">&quot;Start developing a feature&quot;</span><br><span class="hljs-comment"># 编辑更多文件</span><br>$ git commit -a -m <span class="hljs-string">&quot;Fix something from the previous commit&quot;</span><br><br><span class="hljs-comment"># 直接在 master 上添加文件</span><br>$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title"># 编辑文件</span><br><span class="hljs-title">$</span> git commit -a -m <span class="hljs-string">&quot;Fix security hole&quot;</span><br><br><span class="hljs-comment"># 开始交互式 rebase</span><br>$ git checkout feat<br>$ git rebase -i <span class="hljs-keyword">master</span><br><br><span class="hljs-title">最后的那个命令会打开一个编辑器，包含 feat</span> 的两个提交，和一些指示：<br><br>pick <span class="hljs-number">32618</span>c4 <span class="hljs-literal">Start</span> developing a feature<br>pick <span class="hljs-number">62</span>eed47 Fix something from the previous commit<br><br><span class="hljs-comment"># 你可以更改每个提交前的 pick 命令来决定在 rebase 时提交移动的方式。</span><br><span class="hljs-comment"># 在我们的例子中，我们只需要用 squash 命令把两个提交并在一起就可以了：</span><br><br>pick <span class="hljs-number">32618</span>c4 <span class="hljs-literal">Start</span> developing a feature<br>squash <span class="hljs-number">62</span>eed47 Fix something from the previous commit<br><br><span class="hljs-comment"># 保存并关闭编辑器以开始 rebase</span><br><span class="hljs-comment"># 最后，你可以执行一个快速向前的合并，来将完善的 feature 分支整合进主代码库：</span><br><br>git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> merge feat<br><br></code></pre></td></tr></table></figure><p>通常情况下建议使用rebase而非merge来拉取上游代码。这样所有的记录会被合并为一次commit,而且没有一些不重要的合并来污染提交的时间线</p><h3 id="本地清理"><a href="#本地清理" class="headerlink" title="本地清理"></a>本地清理</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>git rebase -i <span class="hljs-variable constant_">HEAD</span>~<span class="hljs-number">3</span><br><br><span class="hljs-variable">$ </span>git rebase -i <span class="hljs-variable constant_">HEAD</span>~~~ <span class="hljs-regexp">//</span>这两条一个意思合并注释<br><br></code></pre></td></tr></table></figure><p>参考<a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9">代码合并：Merge、Rebase 的选择</a></p><h3 id="合并分支commit"><a href="#合并分支commit" class="headerlink" title="合并分支commit"></a>合并分支commit</h3><p>当你在新的feat功能开发时可能会有各种commit最后功能完成我可能想将所有commit合成一个，这样历史会比较简洁。这是可能会使用这条命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git merge-base feat master  <span class="hljs-regexp">//</span>该命令找出feat 分支开始分叉的基 返回基提交的ID，然后可以酱紫<br><br>$ git rebase -i IDXXX <span class="hljs-regexp">//</span>此时选择suqash 就可以重新写历史了 当然合并后最后一次的历史也可以使用 git commit --amend改写<br><br><br><br></code></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>在基于 Git 的协作工作流中，将上游更改合并到你的本地仓库是一个常见的工作。我们已经知道应该使用 git fetch，然后是 git merge，但是 git pull 将这两个命令合二为一。</p><p>基于 Rebase 的 Pull</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git pull --rebase &lt;remote&gt;  <span class="hljs-comment">//此命令会合并远程分支和本地分支而非使用git merge;</span><br><br><span class="hljs-symbol">$</span> git checkout master<br><span class="hljs-symbol">$</span> git pull --rebase origin  <span class="hljs-comment">//简单地将你本地的更改放到其他人已经提交的更改之后。</span><br><br></code></pre></td></tr></table></figure><h3 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// 可以直接使用 -f 选项让分支指向另一个提交 该命令会将 <span class="hljs-keyword">master</span> <span class="hljs-title">分支强制指向 HEAD</span> 的第 <span class="hljs-number">3</span> 级父提交。<br>$ git branch -f <span class="hljs-keyword">master</span> <span class="hljs-title">HEAD</span>~<span class="hljs-number">3</span><br><br><br></code></pre></td></tr></table></figure><h3 id="Reset还是Checkout"><a href="#Reset还是Checkout" class="headerlink" title="Reset还是Checkout"></a>Reset还是Checkout</h3><p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%EF%BC%9AReset%E3%80%81Checkout%E3%80%81Revert-%E7%9A%84%E9%80%89%E6%8B%A9">参考此文章</a></p><table><thead><tr><th>命令</th><th align="center">作用域</th><th align="center">常用情景</th></tr></thead><tbody><tr><td>git reset</td><td align="center">提交层面</td><td align="center">在私有分支上舍弃一些没有提交的更改</td></tr><tr><td>git reset</td><td align="center">文件层面</td><td align="center">将文件从缓存区中移除</td></tr><tr><td>git checkout</td><td align="center">提交层面</td><td align="center">切换分支或查看旧版本</td></tr><tr><td>git checkout</td><td align="center">文件层面</td><td align="center">舍弃工作目录中的更改</td></tr><tr><td>git revert</td><td align="center">提交层面</td><td align="center">在公共分支上回滚更改</td></tr><tr><td>git revert</td><td align="center">文件层面</td><td align="center">（然而并没有）</td></tr></tbody></table><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>git cherry-pick 命令「复制」一个提交节点并在当前分支做一次完全一样的新提交。<br>只想将远程仓库的一个特定提交合并到自己的分支中该怎么做呢？可以使用git cherry-pick 来选择给定SHA值的提交，然后将其合并到当前分支中：</p><h2 id="常见的工作流"><a href="#常见的工作流" class="headerlink" title="常见的工作流"></a><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83">常见的工作流</a></h2><p><a href="https://mritd.me/2017/09/05/git-flow-note/">参考此文章</a>总结一下工具</p><h3 id="Git-flow工具"><a href="#Git-flow工具" class="headerlink" title="Git flow工具"></a>Git flow工具</h3><ul><li><a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">Git-flow</a> 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作；使用 git-flow 工具可以以更加简单的命令完成对 Vincent Driessen 分支模型的实践</li><li>另一个工具是 <a href="https://github.com/tj/git-extras">Git-extras</a>，该工具没有 git-flow 那么简单化，不过其提供更加强大的命令支持</li></ul><h3 id="Git-Commit-Message"><a href="#Git-Commit-Message" class="headerlink" title="Git Commit Message"></a>Git Commit Message</h3><p>我们遵循<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0"> Angular 社区规范</a>格式来提交代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>): <span class="hljs-tag">&lt;<span class="hljs-name">subject</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>type: 本次提交类型</li><li>scope: 本次提交影响范围，一般标明影响版本号或者具体的范围如 $browser, $compile, $rootScope, ngHref, ngClick, ngView, etc…</li><li>subject: 本次提交简短说明</li></ul><p>关于 type 提交类型，有如下几种值:</p><ul><li>feat：新功能(feature)</li><li>fix：修补 bug</li><li>docs：文档(documentation)</li><li>style： 格式(不影响代码运行的变动)</li><li>refactor：重构(即不是新增功能，也不是修改 bug 的代码变动)</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><h3 id="Commit小工具"><a href="#Commit小工具" class="headerlink" title="Commit小工具"></a>Commit小工具</h3><ul><li><a href="http://commitizen.github.io/cz-cli/">commitizen-cli</a>比较有名采用node.js编写执行<code>git cz</code>能生成commit模板进行选择</li><li><a href="https://cimhealth.github.io/git-toolkit/">Git-toolkit</a> 基于shell编写执行<code>git ci</code>产生提交模板</li></ul><h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81">Git 钩子</a></h2><h2 id="Git引用日志"><a href="#Git引用日志" class="headerlink" title="Git引用日志"></a><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.5-Git-%E6%8F%90%E4%BA%A4%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8%E6%97%A5%E5%BF%97#%E5%93%88%E5%B8%8C%E5%AD%97%E4%B8%B2">Git引用日志</a></h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><ul><li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki">git-recipes</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简明指南</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">git教程</a></li><li><a href="http://www.infoq.com/cn/news/2016/01/12-git-advanced-commands">你需要知道的12个Git高级命令</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>版本控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的使用教程(二)</title>
    <link href="/2017/10/21/2017-10-21-git-medium/"/>
    <url>/2017/10/21/2017-10-21-git-medium/</url>
    
    <content type="html"><![CDATA[<h2 id="git的中级使用教程"><a href="#git的中级使用教程" class="headerlink" title="git的中级使用教程"></a>git的中级使用教程</h2><p>记录一些使用率中等的git命令</p><h3 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h3><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>使用git status 太长了怎么破</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.st</span> status<br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.co</span> checkout<br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.ci</span> commit<br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.br</span> branch<br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.unstage</span> &#x27;reset HEAD&#x27;<br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.last</span> &#x27;log -<span class="hljs-number">1</span>&#x27;  <span class="hljs-comment">//显示最后一次提交信息</span><br></code></pre></td></tr></table></figure><p>还有这种操作</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ git config --global alias.lg <span class="hljs-string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></code></pre></td></tr></table></figure><p>结果如下<br><img src="https://cdn.darknights.cn/assets/images/in-post/git-medium/0.png"></p><h3 id="生产SSH-Key"><a href="#生产SSH-Key" class="headerlink" title="生产SSH Key"></a>生产SSH Key</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br><br><span class="hljs-regexp">//</span>生产的公钥私钥 会放到服务器的 ~<span class="hljs-regexp">/.ssh/</span>authorized_keys目录下<br><br></code></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>本地文件夹添加远程仓库并且推送上去,基础文章已经写过这里再次复习一遍</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>michaelliao/learngit.git<br><br><span class="hljs-variable">$ </span>git push -u origin master<br><br></code></pre></td></tr></table></figure><h3 id="分支管理策略-no-ff"><a href="#分支管理策略-no-ff" class="headerlink" title="分支管理策略--no-ff"></a>分支管理策略<code>--no-ff</code></h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward模式</code>，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">merge</span> <span class="hljs-comment">--no-ff -m &quot;merge with no-ff&quot; dev</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> readme.txt |    <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br><span class="hljs-comment"> //其他操作一样只是合并的时候可以带上 禁用ff模式并且加上注释。</span><br></code></pre></td></tr></table></figure><p>合并后的结果如下</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --pretty=oneline --abbrev-commit</span><br>*   <span class="hljs-number">7825</span>a50 <span class="hljs-built_in">merge</span> <span class="hljs-keyword">with</span> no-ff<br>|\<br>| * <span class="hljs-number">6224937</span> <span class="hljs-built_in">add</span> <span class="hljs-built_in">merge</span><br>|/<br>*   <span class="hljs-number">59</span>bc1cb conflict fixed<br>...<br></code></pre></td></tr></table></figure><h3 id="保存工作现场"><a href="#保存工作现场" class="headerlink" title="保存工作现场"></a>保存工作现场</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">$ git stash<br>Saved working directory <span class="hljs-keyword">and</span> <span class="hljs-keyword">index</span> state WIP <span class="hljs-keyword">on</span> dev: <span class="hljs-number">6224937</span> <span class="hljs-keyword">add</span> merge<br>HEAD <span class="hljs-keyword">is</span> now at <span class="hljs-number">6224937</span> <span class="hljs-keyword">add</span> merge<br><br>$ git stash list  <span class="hljs-comment">//显示stash列表</span><br><br>$ git stash pop   <span class="hljs-comment">//相当于 git stash apply + git stash drop   恢复最近的一条</span><br><br><br>$ git stash apply stash@<span class="hljs-comment">&#123;0&#125;</span> <span class="hljs-comment">//指定要恢复的stash</span><br><br></code></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git push origin :<span class="hljs-keyword">master</span> <span class="hljs-title">等同于下面的命令推送一个空分支对应远程分支</span><br><span class="hljs-title"></span><br><span class="hljs-title">$</span> git push origin --delete <span class="hljs-keyword">master</span><br><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h3 id="丢弃暂存区文件"><a href="#丢弃暂存区文件" class="headerlink" title="丢弃暂存区文件"></a>丢弃暂存区文件</h3><p>如果一个文件已经add到暂存区，还没有commit，此时如果不想要这个文件了，有两种方法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git reset HEAD   用版本库内容清空暂存区<br><br><span class="hljs-variable">$</span> git <span class="hljs-built_in">rm</span> <span class="hljs-literal">--cache</span> 删除缓存区内容<br></code></pre></td></tr></table></figure><h3 id="允许空提交"><a href="#允许空提交" class="headerlink" title="允许空提交"></a>允许空提交</h3><p>即没有任何更改进行commit, 之所以需要这种是我们开发时制定分支推送会部署代码但是有时候没有代码提交只想单独部署这样可以进行推送从而触发部署</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-built_in">--allow-empty</span> -<span class="hljs-string">m</span> <span class="hljs-string">&quot;empty&quot;</span><br></code></pre></td></tr></table></figure><h3 id="文件夹大小写问题"><a href="#文件夹大小写问题" class="headerlink" title="文件夹大小写问题"></a>文件夹大小写问题</h3><p>git 提交文件夹默认是不区分大小写的也就是说max/file 和Max/file 对于远端来说是一样的这样就会有本地和远端文件夹不一样的问题。带来的后果就是java起名字的时候如果文件夹有大小写有可能不识别会有找不到类的问题</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ git config core.ignorecase <span class="hljs-literal">false</span>  <span class="hljs-comment">//默认是true</span><br><br></code></pre></td></tr></table></figure><h3 id="git-reset的后悔药"><a href="#git-reset的后悔药" class="headerlink" title="git reset的后悔药"></a>git reset的后悔药</h3><p>当使用  <code>git reset --hard xxx</code> 回退到之前的版本,我又想回到最新的版本如何操作呢</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ git <span class="hljs-built_in">ref</span>log<br><br>git <span class="hljs-built_in">ref</span>log --relative-date  <span class="hljs-comment">//用相对的日期显示引用日志。(如 2 周前）。</span><br><br><br><br>ea34578 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">0</span>&#125;: reset: moving to HEAD^<br><span class="hljs-number">3628164</span> <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">1</span>&#125;: commit: append GPL<br>ea34578 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">2</span>&#125;: commit: add distributed<br>cb926e7 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">3</span>&#125;: commit (initial): wrote a readme file<br><br></code></pre></td></tr></table></figure><p>这样之后又可以使用 reset –hard xxx 乘坐时光机返回了。</p><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p>该命令将未跟踪的文件从工作目录中删除，同git status 然后手动删除一样。该命令无法撤销慎重使用。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clean -n  <span class="hljs-regexp">//</span>进行预演告诉你哪些文件会被删除并不是真的删除<br><br>$ git clean -f  <span class="hljs-regexp">//</span>删除所有未跟踪文件 &lt;code&gt;-f&lt;/code&gt;是必须的<br><br>$ git clean -f &lt;path&gt; <span class="hljs-regexp">//</span>移除未跟踪的文件，但限制在某个路径下。<br><br>$ git clean -df <span class="hljs-regexp">//</span>移除未跟踪的文件，以及目录。<br><br>$ git clean -xf <span class="hljs-regexp">//</span>移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。<br><br></code></pre></td></tr></table></figure><h3 id="reset-clean"><a href="#reset-clean" class="headerlink" title="reset+clean"></a>reset+clean</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 编辑了一些文件</span><br><span class="hljs-comment"># 新增了一些文件</span><br><span class="hljs-comment"># 『糟糕』</span><br><br><span class="hljs-comment"># 将跟踪的文件回滚回去</span><br>git reset <span class="hljs-comment">--hard</span><br><br><span class="hljs-comment"># 移除未跟踪的文件</span><br>git clean -df<br></code></pre></td></tr></table></figure><p>在执行了 reset/clean 的流程之后，工作目录和缓存区和最近一次提交看上去一模一样，而 git status会认为这是一个干净的工作目录。你可以重新来过了。</p><p>注意，不像 git reset 的第二个栗子，新的文件没有被加入到仓库中。因此，它们不会受到 git reset –hard 的影响，需要 git clean 来删除它们。</p><h3 id="reset其他用法"><a href="#reset其他用法" class="headerlink" title="reset其他用法"></a>reset其他用法</h3><p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git status<br><span class="hljs-comment"># On branch master</span><br><span class="hljs-comment"># Changes to be committed:</span><br><span class="hljs-comment">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       modified:   readme.txt</span><br><span class="hljs-comment">#</span><br><br>$ git reset HEAD readme.txt<br>Unstaged changes after reset:<br>M       readme.txt<br><br><br><br><span class="hljs-comment"># 另一个例子</span><br><br><span class="hljs-comment"># 编辑了hello.py和main.py</span><br><br><span class="hljs-comment"># 缓存了目录下所有文件</span><br>git <span class="hljs-built_in">add</span> .<br><br><span class="hljs-comment"># 意识到hello.py和main.py中的修改</span><br><span class="hljs-comment"># 应该在不同的快照中提交</span><br><br><span class="hljs-comment"># 取消main.py缓存</span><br>git reset main.py<br><br><span class="hljs-comment"># 只提交hello.py</span><br>git commit -m <span class="hljs-string">&quot;Make some changes to hello.py&quot;</span><br><br><span class="hljs-comment"># 在另一份快照中提交main.py</span><br>git <span class="hljs-built_in">add</span> main.py<br>git commit -m <span class="hljs-string">&quot;Edit main.py&quot;</span><br><br></code></pre></td></tr></table></figure><blockquote><ul><li>git checkout – xxx 丢弃工作区间的修改 此时没有add</li><li>git reset HEAD xxx 将暂存区的文件撤销放回到工作区间 ，此时已经add</li></ul></blockquote><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>这里有个checkout的用法比较少用感觉用reset比较多，通常来说git checkout 会有三种用法： 检出文件，检出提交和检出分支，一般我们只关心前两种</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git checkout master <span class="hljs-comment">//切换分支</span><br><br><span class="hljs-symbol">$</span> git checkout &lt;commit&gt; &lt;<span class="hljs-keyword">file</span>&gt;<br><br><span class="hljs-symbol">$</span> git checkout a1e8fb5 hello.py <span class="hljs-comment">//将某个文件切到某次提交的的样子</span><br><br><br><span class="hljs-symbol">$</span> git checout &lt;commit&gt;  <span class="hljs-comment">//将所有文件切换到某次提交的样子</span><br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用<br>每个仓库的Git配置文件都放在.git/config文件中</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>cat .git/config<br>[core]<br>    repositoryformatversion = <span class="hljs-number">0</span><br>    filemode = <span class="hljs-literal">true</span><br>    bare = <span class="hljs-literal">false</span><br>    logallrefupdates = <span class="hljs-literal">true</span><br>    ignorecase = <span class="hljs-literal">true</span><br>    precomposeunicode = <span class="hljs-literal">true</span><br>[remote <span class="hljs-string">&quot;origin&quot;</span>]<br>    url = git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>michaelliao/learngit.git<br>    fetch = +refs/heads/*<span class="hljs-symbol">:refs/remotes/origin/*</span><br>[branch <span class="hljs-string">&quot;master&quot;</span>]<br>    remote = origin<br>    merge = refs/heads/master<br>[<span class="hljs-keyword">alias</span>]<br>    last = log <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">cd</span> ~<br>$ <span class="hljs-keyword">cat</span> .gitconfig<br>[alias]<br>    <span class="hljs-keyword">co</span> = checkout<br>    ci = commit<br>    <span class="hljs-keyword">br</span> = branch<br>    <span class="hljs-keyword">st</span> = status<br>[user]<br>    name = Your Name<br>    email = your@email.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><h3 id="使用-gitignore"><a href="#使用-gitignore" class="headerlink" title="使用.gitignore"></a>使用.gitignore</h3><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：<br>如果你确实想添加该文件，可以用-f强制添加到Git：<br>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">$ git<span class="hljs-built_in"> add </span>-f App.class<br><br>$ git<span class="hljs-built_in"> check-ignore </span>-v App.class<br><span class="hljs-keyword">.gitignore</span>:3:*.class    App.class<br></code></pre></td></tr></table></figure><h3 id="如何删除一些无用分支"><a href="#如何删除一些无用分支" class="headerlink" title="如何删除一些无用分支"></a>如何删除一些无用分支</h3><p>远程已经删除但是本地还存在。<br>这种操作通常是我新建分支改完bug推送远程合并结束后,远程分支删掉了本地分支也删掉但是branch -a的时候还存在想删除本地远程分支数据库中的分支时使用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>$ git fetch origin <span class="hljs-attr">--prune</span>  <span class="hljs-comment">//update the local database of remote branches</span><br><br>$ git fetch -<span class="hljs-selector-tag">p</span> origin      <span class="hljs-comment">//这两条命令都在做一个事情,将本地分支库和远程分支库进行同步如果远程删掉了本地就删掉</span><br><br>$ git fetch origin -<span class="hljs-selector-tag">p</span> <span class="hljs-attr">--progress</span>  <span class="hljs-comment">//可以显示过程</span><br><br>$ git remote update <span class="hljs-attr">--prune</span> 也可以生效不过我没试过😓<br><br></code></pre></td></tr></table></figure><p>总有最笨的方法</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch -d -r origin/branch_name  <span class="hljs-comment">//不嫌麻烦可以一条条删掉😂</span><br></code></pre></td></tr></table></figure><h2 id="本地分支与远程分支对应"><a href="#本地分支与远程分支对应" class="headerlink" title="本地分支与远程分支对应"></a>本地分支与远程分支对应</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>新建分支直接创建新分支推送到远端即可</p><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>本地没有分支远端有分支dev</p><p>可以git fetch ,然后直接新建分支<b>跟远端分支名字一样</b> dev就可以建立链接。</p><h3 id="另一种解决方案"><a href="#另一种解决方案" class="headerlink" title="另一种解决方案"></a>另一种解决方案</h3><p>情况二的领域中解决方案<br>要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是用这个命令创建本地dev分支</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs q">$ git checkout -b <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span><br><br><br>如果此时报错 no tracking information 需要将远程<span class="hljs-built_in">dev</span>和本地<span class="hljs-built_in">dev</span>分支建立链接<br><br>$ git branch --<span class="hljs-built_in">set</span>-upstream <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span><br><br>$ git branch --track  <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span>  <span class="hljs-comment">//该方法同上</span><br><br><span class="hljs-comment">//也可以选择git fetch 将远程相关的内容全拉取下来然后直接切换分支</span><br><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简明指南</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">git教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>版本控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode,LintCode,Hihocoder刷题指南</title>
    <link href="/2017/10/12/2017-10-12-interview/"/>
    <url>/2017/10/12/2017-10-12-interview/</url>
    
    <content type="html"><![CDATA[<h1 id="通过题目训练来提升自己的编程能力"><a href="#通过题目训练来提升自己的编程能力" class="headerlink" title="通过题目训练来提升自己的编程能力"></a>通过题目训练来提升自己的编程能力</h1><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode.com/">LeetCode</a></h2><h2 id="codeWars"><a href="#codeWars" class="headerlink" title="codeWars"></a><a href="http://www.codewars.com/kata/54b42f9314d9229fd6000d9c/train/javascript">codeWars</a></h2><blockquote><p>LeetCode 是一个非常棒的 OJ（Online Judge）平台，收集了许多公司的面试题目。相对其他 OJ 平台而言，有着下面的几个优点：</p><ul><li>题目全部来自业内大公司的真实面试</li><li>不用处理输入输出，精力全放在解决具体问题上</li><li>题目有丰富的讨论，可以参考别人的思路</li><li>精确了解自己代码在所有提交代码中运行效率的排名</li><li>支持多种主流语言：C/C++，Python, Java</li><li>可以在线进行测试，方便调试</li></ul></blockquote><p><a href="http://www.lintcode.com/zh-cn/">LintCode</a><br><a href="http://hihocoder.com/">Hihocoder</a></p><p>参考文章</p><blockquote><ul><li><a href="https://crispgm.com/page/48-tips-for-jekyll-you-should-know.html">48 个你需要知道的 Jekyll 使用技巧</a></li><li><a href="http://www.zhanxin.info/journal/">掌心</a></li><li><a href="https://blog.ixxoo.me/">likebeta’s Blog</a></li><li><a href="http://blog.csdn.net/maoxunxing/article/details/40479753">jekyll翻译文章</a></li><li><a href="http://ibloodline.com/articles/2014/12/15/jekyll-syntax.html">jekyll语法简单笔记</a></li><li><a href="http://alfred-sun.github.io/blog/2014/12/05/github-pages/">GitHub Pages 静态博客 - 个人建站实录</a></li><li><a href="http://harttle.com/2013/10/18/github-homepage-tutorial.html">部署自己的博客</a></li><li><a href="https://mritd.me/2017/02/25/jekyll-blog-+-travis-ci-auto-deploy/">杨缘的博客参考</a></li><li><a href="http://yerl.cn/blog/use-jekyll-build-your-blog">poison</a></li><li><a href="http://jekyllcn.com/docs/plugins/">jekyll官网中文</a></li><li><a href="http://www.thomaszhao.cn/2015/01/08/how-do-i-build-this-jekyll-blog/">适合程序员的Blog – 基于github pages + jekyll + markdown打造自己的blog</a></li><li><a href="http://www.w3cboy.com/post/2016/03/travisci-hexo-deploy/">使用travis-ci自动部署hexo博客</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>工作面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的使用教程(一)</title>
    <link href="/2017/10/12/2017-10-20-git-base/"/>
    <url>/2017/10/12/2017-10-20-git-base/</url>
    
    <content type="html"><![CDATA[<h2 id="git的初级使用教程"><a href="#git的初级使用教程" class="headerlink" title="git的初级使用教程"></a>git的初级使用教程</h2><p>记录常用的git命令,方便自己查询</p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><figure class="highlight crystal"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span> git init<br></code></pre></td></tr></table></figure><p>Create a new repository</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git <span class="hljs-built_in">clone</span> git@github.com:sundongzhi/chouti-react.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">cd</span> chouti-react</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">touch</span> README.md</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git add README.md</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git commit -m <span class="hljs-string">&quot;add README&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git push -u origin master</span><br></code></pre></td></tr></table></figure><p>Existing folder</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">cd</span> existing_folder</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git init</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git remote add origin git@github.com:sundongzhi/chouti-react.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git push -u origin master</span><br></code></pre></td></tr></table></figure><p>Existing Git repository</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">cd</span> existing_repo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git remote rename origin old-origin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git remote add origin git@github.com:sundongzhi/chouti-react.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git push -u origin --all</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> git push -u origin --tags</span><br></code></pre></td></tr></table></figure><h3 id="clone本地仓库"><a href="#clone本地仓库" class="headerlink" title="clone本地仓库"></a>clone本地仓库</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$  git <span class="hljs-keyword">clone</span> <span class="hljs-title">/path</span>/to/repository<br></code></pre></td></tr></table></figure><h3 id="从远程仓库clone"><a href="#从远程仓库clone" class="headerlink" title="从远程仓库clone"></a>从远程仓库clone</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span> git clone username<span class="hljs-variable">@host</span><span class="hljs-symbol">:/path/to/repository</span><br></code></pre></td></tr></table></figure><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><blockquote><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。</p></blockquote><p><img src="https://cdn.darknights.cn/assets/images/in-post/git-base/trees.png"></p><h3 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>  git add &lt;filename&gt;<br><span class="hljs-symbol">$</span>  git add *<br><span class="hljs-symbol">$</span>  git add .     <span class="hljs-comment">//添加到缓存区</span><br><br><span class="hljs-symbol">$</span>  git commit -m <span class="hljs-string">&quot;代码提交信息&quot;</span>   <span class="hljs-comment">//提交到本地仓库</span><br><br><span class="hljs-symbol">$</span> git commit -a  相当于 git add + git commit<br></code></pre></td></tr></table></figure><h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$  git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>可以把 master 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$  git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>&lt;server&gt;<br></code></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">git</span> <span class="hljs-string">remote</span> -<span class="hljs-string">v</span> //显示远程仓库信息<br><br>$ <span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">rm</span> <span class="hljs-string">origin</span>  //删除远程链接<br><br>$ <span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">git</span>@<span class="hljs-string">github</span>.<span class="hljs-string">com:michaelliao/</span><span class="hljs-string">learngit</span>.<span class="hljs-string">git</span>  //更改远程仓库地址,通常用来切换<span class="hljs-string">ssh</span>和<span class="hljs-string">https</span><br><br></code></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。<br><img src="https://cdn.darknights.cn/assets/images/in-post/git-base/branches.png"></p><p>创建一个叫做“feature_x”的分支，并切换过去：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git branch 查看本地分支<br><br><span class="hljs-variable">$ </span>git branch -a 查看本地和本地fetch到的远程分支都显示出来<br><br><span class="hljs-variable">$ </span>git branch -r 查看本地fetch到的远程分支(只显示本地存储的远程分支)<br><br><span class="hljs-variable">$ </span>git checkout -b feature_x<br><br><br></code></pre></td></tr></table></figure><p>切换回主分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$  git checkout <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><p>再把新建的分支删掉：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$  git branch -d feature_x <span class="hljs-regexp">//</span>删除已经合并的分支<br>$  git branch -D feature_x  <span class="hljs-regexp">//</span>强行删除未合并的分支<br></code></pre></td></tr></table></figure><p>重命名分支</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git branch -m devel develop<br></code></pre></td></tr></table></figure><p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$  git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;branch&gt;<br></code></pre></td></tr></table></figure><h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>  git pull   <span class="hljs-comment">//相当于 git fetch and git merge两个操作</span><br><span class="hljs-symbol">$</span>  git diff &lt;source_branch&gt; &lt;target_branch&gt;  <span class="hljs-comment">//如果有冲突解决完冲突可以这样查看两个分支差别</span><br></code></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>以执行如下命令创建一个叫做 1.0.0 的标签：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">$  git tag v1.<span class="hljs-number">0.0</span> <span class="hljs-number">1</span>b2e1d63ff <span class="hljs-regexp">//</span>b2e1d63ff 是你想要标记的提交 ID 的前 <span class="hljs-number">10</span> 位字符<br><br>$  git tag  <span class="hljs-regexp">//</span>显示所有tag标签<br><br>$  git show v1.<span class="hljs-number">0</span> <span class="hljs-regexp">//</span>查看标签信息<br><br><span class="hljs-regexp">//</span>打一个完整的标签 -a 制定标签的名字  -m 注释   最后的数字代表HEAD制定从哪次提交打标签<br>$ git tag -a v0.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">3628164</span><br><br><br>$ git tag -d v1.<span class="hljs-number">0</span> <span class="hljs-regexp">//</span>删除本地标签<br><br>$ git push origin :refs<span class="hljs-regexp">/tags/</span>v0.<span class="hljs-number">9</span>   <span class="hljs-regexp">//</span>删除远程标签 需要先将本地标签删除<br><br>$ git push origin v1.<span class="hljs-number">0</span>   <span class="hljs-regexp">//</span>将标签推送到远程仓库<br><br><br><br>$ git push origin --tags <span class="hljs-regexp">//</span>一次性推送全部尚未推送到远程的本地标签：<br><br><span class="hljs-regexp">//</span>使用 gpg(GnuPG)签名来打标签但是不常用<br>$ git tag -s v0.<span class="hljs-number">2</span> -m <span class="hljs-string">&quot;signed version 0.2 released&quot;</span> fec145a<br><br><br></code></pre></td></tr></table></figure><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>更多高级用法<a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.3-Git-log-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95">参考这里</a></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> <span class="hljs-comment">//查看所有日志</span><br><br><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> --author=toshiba  <span class="hljs-comment">//查看某人的日志</span><br><br><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> --pretty=oneline  <span class="hljs-comment">//压缩后的日志每个提交只占一行</span><br><br><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> --graph --oneline --decorate --<span class="hljs-keyword">all</span>  <span class="hljs-comment">//ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</span><br><br><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br><br><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> --name-status  <span class="hljs-comment">//查看都有哪些文件修改过了</span><br><br><span class="hljs-symbol">$</span>  git <span class="hljs-built_in">log</span> --help  <span class="hljs-comment">//更多的帮助信息</span><br></code></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment">#拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。</span><br><br>$ git fetch <span class="hljs-variable">&lt;remote&gt;</span><br><br><br><span class="hljs-comment">#和上一个命令相同，但只拉取指定的分支。</span><br><br>$git fetch <span class="hljs-variable">&lt;remote&gt;</span> <span class="hljs-variable">&lt;branch&gt;</span><br></code></pre></td></tr></table></figure><h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$  git checkout -- &lt;filename&gt; <span class="hljs-regexp">//</span>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。<br>    <span class="hljs-regexp">//</span>已添加到暂存区的改动以及新文件都不会受到影响。<br></code></pre></td></tr></table></figure><p>如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$  git fetch <span class="hljs-built_in">origin</span><br>$  git <span class="hljs-built_in">reset</span> --hard <span class="hljs-built_in">origin</span>/master<br></code></pre></td></tr></table></figure><h3 id="reset参数"><a href="#reset参数" class="headerlink" title="reset参数"></a>reset参数</h3><p>除了在当前分支上操作，你还可以通过传入这些标记来修改你的缓存区或工作目录：</p><ul><li>–soft – 缓存区和工作目录都不会被改变</li><li>–mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</li><li>–hard – 缓存区和工作目录都同步到你指定的提交</li></ul><h3 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$  gitk           <span class="hljs-comment">//内建的图形化 git</span><br><br>$  git config color.ui <span class="hljs-literal">true</span>          <span class="hljs-comment">//彩色的 git 输出</span><br><br>$  git config --global color.ui <span class="hljs-literal">true</span><br><br>$  git config format.pretty oneline  <span class="hljs-comment">//显示历史记录时，每个提交的信息只显示一行</span><br><br>$  git add -i <span class="hljs-comment">//交互式添加文件到暂存区：</span><br><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简明指南</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>版本控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用travis-ci集成项目,自动部署博客站点</title>
    <link href="/2017/09/05/2017-09-27-blog-static-nginx/"/>
    <url>/2017/09/05/2017-09-27-blog-static-nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="第一次搭建博客"><a href="#第一次搭建博客" class="headerlink" title="第一次搭建博客"></a>第一次搭建博客</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://crispgm.com/page/48-tips-for-jekyll-you-should-know.html">48 个你需要知道的 Jekyll 使用技巧</a></li><li><a href="http://www.zhanxin.info/journal/">掌心</a></li><li><a href="https://blog.ixxoo.me/">likebeta’s Blog</a></li><li><a href="http://blog.csdn.net/maoxunxing/article/details/40479753">jekyll翻译文章</a></li><li><a href="http://ibloodline.com/articles/2014/12/15/jekyll-syntax.html">jekyll语法简单笔记</a></li><li><a href="http://alfred-sun.github.io/blog/2014/12/05/github-pages/">GitHub Pages 静态博客 - 个人建站实录</a></li><li><a href="http://harttle.com/2013/10/18/github-homepage-tutorial.html">部署自己的博客</a></li><li><a href="https://mritd.me/2017/02/25/jekyll-blog-+-travis-ci-auto-deploy/">杨缘的博客参考</a></li><li><a href="http://yerl.cn/blog/use-jekyll-build-your-blog">poison</a></li><li><a href="http://jekyllcn.com/docs/plugins/">jekyll官网中文</a></li><li><a href="http://www.w3cboy.com/post/2016/03/travisci-hexo-deploy/">使用travis-ci自动部署hexo博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建jekyll 博客流程记录</title>
    <link href="/2017/09/05/2017-09-05-jekyll-site/"/>
    <url>/2017/09/05/2017-09-05-jekyll-site/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次搭建博客"><a href="#第一次搭建博客" class="headerlink" title="第一次搭建博客"></a>第一次搭建博客</h2><p>不知为何最近突然想写个博客网站了，以前的话都是在一些博客园，新浪微博啥的浪一波时间长了也不想写了就慢慢荒废了，之所以想自己搞个一方面是把一些技术点记录一下，同时对自己也是一个督促，再就是我有个写小说的梦想想搞个栏目写写随笔等杂七杂八的东东。经过一番努力该博客终于可以勉强拿出手了。在此要感谢两位大神:</p><blockquote><ul><li><a href="http://huangxuan.me/">黄玄</a></li><li><a href="https://mritd.me/">漠然</a></li></ul></blockquote><p>我的博客是基于黄玄的博客主题来更改的虽然遇到一些问题但是经过一番查找还是完美的解决了。<br>而漠然这位仁兄是我好兄弟对于我博客的搭建提供了各种技术支持和疑难解答对此再次表示感谢。</p><h2 id="搭建博客的基本流程"><a href="#搭建博客的基本流程" class="headerlink" title="搭建博客的基本流程"></a>搭建博客的基本流程</h2><h3 id="安装Ruby-Rails"><a href="#安装Ruby-Rails" class="headerlink" title="安装Ruby, Rails"></a>安装Ruby, Rails</h3><p>建议在Linux的发行版本(Ubuntu,CentOs, Redhat, ArchLinux…) 或者 Mac Os X安装。</p><ul><li><a href="https://github.com/ruby-china/homeland/wiki/Mac-OS-X-%E4%B8%8A%E5%AE%89%E8%A3%85-Ruby">Mac OS X上安装ruby</a> 来安装</li><li>如果需要不同版本的ruby可以<a href="https://ruby-china.org/wiki/install_ruby_guide">安装 RVM</a>来进行ruby版本管理</li></ul><h3 id="安装jekyll"><a href="#安装jekyll" class="headerlink" title="安装jekyll"></a>安装jekyll</h3><p>该博客使用了 <a href="https://jekyllrb.com/">Jekyll</a>, 当然好多同学可能会用 <a href="https://hexo.io/themes/">Hexo</a> 这个就是萝卜青菜了。<br>如果你选择使用Jekyll请安装下面步骤安装生成:</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">~ $ gem install jekyll bundler<br>~ $ jekyll new my-awesome-site<br>~ $ cd my-awesome-site<br>~/my-awesome-site $ bundle exec jekyll serve<br><span class="hljs-meta prompt_"># </span><span class="language-bash">=&gt; Now browse to http://localhost:4000</span><br><br></code></pre></td></tr></table></figure><p>生产的项目结构类似</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml    <span class="hljs-comment">//项目相关配置文件</span><br>├── <span class="hljs-variable">_data</span><br>|   └── <span class="hljs-built_in">members</span>.yml   <span class="hljs-comment">//一些需要的数据</span><br>├── <span class="hljs-variable">_drafts</span>           <span class="hljs-comment">//草稿</span><br>|   ├── begin-<span class="hljs-keyword">with</span>-the-crazy-ideas.md<br>|   └── on-simplicity-<span class="hljs-built_in">in</span>-technology.md<br>├── <span class="hljs-variable">_includes</span>         <span class="hljs-comment">//公共的部分</span><br>|   ├── footer.html<br>|   └── header.html<br>├── <span class="hljs-variable">_layouts</span>           <span class="hljs-comment">//布局文件</span><br>|   ├── <span class="hljs-keyword">default</span>.html<br>|   └── post.html<br>├── <span class="hljs-variable">_posts</span>             <span class="hljs-comment">//发布的文章</span><br>|   ├── <span class="hljs-number">2007</span>-<span class="hljs-number">10</span>-<span class="hljs-number">29</span>-why-every-programmer-should-play-nethack.md<br>|   └── <span class="hljs-number">2009</span>-<span class="hljs-number">04</span>-<span class="hljs-number">26</span>-barcamp-boston-<span class="hljs-number">4</span>-roundup.md<br>├── <span class="hljs-variable">_sass</span>              <span class="hljs-comment">//sass文件路径编译后生产css</span><br>|   ├── <span class="hljs-variable">_base</span>.scss<br>|   └── <span class="hljs-variable">_layout</span>.scss<br>├── <span class="hljs-variable">_site</span>              <span class="hljs-comment">//所有文件编译生产静态文件都存放到这里</span><br>├── .jekyll-metadata<br>└── index.html <span class="hljs-meta"># can also be an <span class="hljs-string">&#x27;index.md&#x27;</span> with valid YAML Frontmatter</span><br></code></pre></td></tr></table></figure><p>具体还有其他目录请参考<a href="https://jekyllrb.com/docs/structure/">jekyll目录结构</a></p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>到这里你应该可以访问一个页面了,但是离我们心中的博客相差甚远。我们需要给项目增加一个 <a href="http://jekyllthemes.org/">Jekyll 主题</a> ,当然如果在套用别人主题的时候有问题可以看一下<br><a href="http://www.jianshu.com/p/4224b8ea0ec0">Liquid语法</a>,和markdown语法,因为我在套用黄玄的博客时就遇到了语法问题,可能是ruby版本更新导致。这些语法问题都可以在文档中找到答案,所以还是要仔细读文档</p><p>到此博客已经能够访问并且有了主题,如果添加新的文章只需要按照固定格式套用即可。</p><p>参考文章</p><blockquote><ul><li><a href="https://crispgm.com/page/48-tips-for-jekyll-you-should-know.html">48 个你需要知道的 Jekyll 使用技巧</a></li><li><a href="http://www.zhanxin.info/journal/">掌心</a></li><li><a href="https://blog.ixxoo.me/">likebeta’s Blog</a></li><li><a href="http://blog.csdn.net/maoxunxing/article/details/40479753">jekyll翻译文章</a></li><li><a href="http://ibloodline.com/articles/2014/12/15/jekyll-syntax.html">jekyll语法简单笔记</a></li><li><a href="http://alfred-sun.github.io/blog/2014/12/05/github-pages/">GitHub Pages 静态博客 - 个人建站实录</a></li><li><a href="http://harttle.com/2013/10/18/github-homepage-tutorial.html">部署自己的博客</a></li><li><a href="https://mritd.me/2017/02/25/jekyll-blog-+-travis-ci-auto-deploy/">杨缘的博客参考</a></li><li><a href="http://yerl.cn/blog/use-jekyll-build-your-blog">poison</a></li><li><a href="http://jekyllcn.com/docs/plugins/">jekyll官网中文</a></li><li><a href="http://www.thomaszhao.cn/2015/01/08/how-do-i-build-this-jekyll-blog/">适合程序员的Blog – 基于github pages + jekyll + markdown打造自己的blog</a></li><li><a href="http://www.w3cboy.com/post/2016/03/travisci-hexo-deploy/">使用travis-ci自动部署hexo博客</a></li><li><a href="http://t.hengwei.me/post/%E4%B8%BAjekyll%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95%E4%B8%8Escrollspy%E6%95%88%E6%9E%9C.html">为Jekyll博客添加目录与ScrollSpy效果</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
